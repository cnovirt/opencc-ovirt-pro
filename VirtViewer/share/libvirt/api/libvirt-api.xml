<?xml version="1.0" encoding="UTF-8"?>
<api name='libvirt'>
  <files>
    <file name='libvirt-common'>
     <summary>common macros and enums for the libvirt and libvirt-admin library</summary>
     <description>Provides common macros and enums needed by both libvirt and libvirt-admin libraries  Copyright (C) 2015 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='LIBVIR_CHECK_VERSION' type='macro'/>
     <exports symbol='LIBVIR_VERSION_NUMBER' type='macro'/>
     <exports symbol='VIR_TYPED_PARAM_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_CONNECT_CLOSE_REASON_CLIENT' type='enum'/>
     <exports symbol='VIR_CONNECT_CLOSE_REASON_EOF' type='enum'/>
     <exports symbol='VIR_CONNECT_CLOSE_REASON_ERROR' type='enum'/>
     <exports symbol='VIR_CONNECT_CLOSE_REASON_KEEPALIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_CLOSE_REASON_LAST' type='enum'/>
     <exports symbol='VIR_TYPED_PARAM_BOOLEAN' type='enum'/>
     <exports symbol='VIR_TYPED_PARAM_DOUBLE' type='enum'/>
     <exports symbol='VIR_TYPED_PARAM_INT' type='enum'/>
     <exports symbol='VIR_TYPED_PARAM_LAST' type='enum'/>
     <exports symbol='VIR_TYPED_PARAM_LLONG' type='enum'/>
     <exports symbol='VIR_TYPED_PARAM_STRING' type='enum'/>
     <exports symbol='VIR_TYPED_PARAM_STRING_OKAY' type='enum'/>
     <exports symbol='VIR_TYPED_PARAM_UINT' type='enum'/>
     <exports symbol='VIR_TYPED_PARAM_ULLONG' type='enum'/>
     <exports symbol='virConnectCloseReason' type='typedef'/>
     <exports symbol='virTypedParameter' type='typedef'/>
     <exports symbol='virTypedParameterFlags' type='typedef'/>
     <exports symbol='virTypedParameterPtr' type='typedef'/>
     <exports symbol='virTypedParameterType' type='typedef'/>
     <exports symbol='_virTypedParameter' type='struct'/>
     <exports symbol='virFreeCallback' type='function'/>
     <exports symbol='virTypedParamsAddBoolean' type='function'/>
     <exports symbol='virTypedParamsAddDouble' type='function'/>
     <exports symbol='virTypedParamsAddFromString' type='function'/>
     <exports symbol='virTypedParamsAddInt' type='function'/>
     <exports symbol='virTypedParamsAddLLong' type='function'/>
     <exports symbol='virTypedParamsAddString' type='function'/>
     <exports symbol='virTypedParamsAddStringList' type='function'/>
     <exports symbol='virTypedParamsAddUInt' type='function'/>
     <exports symbol='virTypedParamsAddULLong' type='function'/>
     <exports symbol='virTypedParamsClear' type='function'/>
     <exports symbol='virTypedParamsFree' type='function'/>
     <exports symbol='virTypedParamsGet' type='function'/>
     <exports symbol='virTypedParamsGetBoolean' type='function'/>
     <exports symbol='virTypedParamsGetDouble' type='function'/>
     <exports symbol='virTypedParamsGetInt' type='function'/>
     <exports symbol='virTypedParamsGetLLong' type='function'/>
     <exports symbol='virTypedParamsGetString' type='function'/>
     <exports symbol='virTypedParamsGetUInt' type='function'/>
     <exports symbol='virTypedParamsGetULLong' type='function'/>
    </file>
    <file name='libvirt-domain-checkpoint'>
     <summary>APIs for management of domain checkpoints</summary>
     <description>Provides APIs for the management of domain checkpoints  Copyright (C) 2006-2019 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_CREATE_QUIESCE' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_CREATE_REDEFINE' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_DELETE_CHILDREN' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_DELETE_CHILDREN_ONLY' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_DELETE_METADATA_ONLY' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_LIST_DESCENDANTS' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_LIST_LEAVES' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_LIST_NO_LEAVES' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_LIST_ROOTS' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_LIST_TOPOLOGICAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_XML_NO_DOMAIN' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_XML_SECURE' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHECKPOINT_XML_SIZE' type='enum'/>
     <exports symbol='virDomainCheckpoint' type='typedef'/>
     <exports symbol='virDomainCheckpointCreateFlags' type='typedef'/>
     <exports symbol='virDomainCheckpointDeleteFlags' type='typedef'/>
     <exports symbol='virDomainCheckpointListFlags' type='typedef'/>
     <exports symbol='virDomainCheckpointPtr' type='typedef'/>
     <exports symbol='virDomainCheckpointXMLFlags' type='typedef'/>
     <exports symbol='virDomainCheckpointCreateXML' type='function'/>
     <exports symbol='virDomainCheckpointDelete' type='function'/>
     <exports symbol='virDomainCheckpointFree' type='function'/>
     <exports symbol='virDomainCheckpointGetConnect' type='function'/>
     <exports symbol='virDomainCheckpointGetDomain' type='function'/>
     <exports symbol='virDomainCheckpointGetName' type='function'/>
     <exports symbol='virDomainCheckpointGetParent' type='function'/>
     <exports symbol='virDomainCheckpointGetXMLDesc' type='function'/>
     <exports symbol='virDomainCheckpointListAllChildren' type='function'/>
     <exports symbol='virDomainCheckpointLookupByName' type='function'/>
     <exports symbol='virDomainCheckpointRef' type='function'/>
     <exports symbol='virDomainListAllCheckpoints' type='function'/>
    </file>
    <file name='libvirt-domain-snapshot'>
     <summary>APIs for management of domain snapshots</summary>
     <description>Provides APIs for the management of domain snapshots  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_HALT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_LIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_LEAVES' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_METADATA' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_ROOTS' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_LIST_TOPOLOGICAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_REVERT_FORCE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_XML_SECURE' type='enum'/>
     <exports symbol='virDomainSnapshot' type='typedef'/>
     <exports symbol='virDomainSnapshotCreateFlags' type='typedef'/>
     <exports symbol='virDomainSnapshotDeleteFlags' type='typedef'/>
     <exports symbol='virDomainSnapshotListFlags' type='typedef'/>
     <exports symbol='virDomainSnapshotPtr' type='typedef'/>
     <exports symbol='virDomainSnapshotRevertFlags' type='typedef'/>
     <exports symbol='virDomainSnapshotXMLFlags' type='typedef'/>
     <exports symbol='virDomainHasCurrentSnapshot' type='function'/>
     <exports symbol='virDomainListAllSnapshots' type='function'/>
     <exports symbol='virDomainRevertToSnapshot' type='function'/>
     <exports symbol='virDomainSnapshotCreateXML' type='function'/>
     <exports symbol='virDomainSnapshotCurrent' type='function'/>
     <exports symbol='virDomainSnapshotDelete' type='function'/>
     <exports symbol='virDomainSnapshotFree' type='function'/>
     <exports symbol='virDomainSnapshotGetConnect' type='function'/>
     <exports symbol='virDomainSnapshotGetDomain' type='function'/>
     <exports symbol='virDomainSnapshotGetName' type='function'/>
     <exports symbol='virDomainSnapshotGetParent' type='function'/>
     <exports symbol='virDomainSnapshotGetXMLDesc' type='function'/>
     <exports symbol='virDomainSnapshotHasMetadata' type='function'/>
     <exports symbol='virDomainSnapshotIsCurrent' type='function'/>
     <exports symbol='virDomainSnapshotListAllChildren' type='function'/>
     <exports symbol='virDomainSnapshotListChildrenNames' type='function'/>
     <exports symbol='virDomainSnapshotListNames' type='function'/>
     <exports symbol='virDomainSnapshotLookupByName' type='function'/>
     <exports symbol='virDomainSnapshotNum' type='function'/>
     <exports symbol='virDomainSnapshotNumChildren' type='function'/>
     <exports symbol='virDomainSnapshotRef' type='function'/>
    </file>
    <file name='libvirt-domain'>
     <summary>APIs for management of domains</summary>
     <description>Provides APIs for the management of domains  Copyright (C) 2006-2015 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_COPY_CPUMAP' type='macro'/>
     <exports symbol='VIR_CPU_MAPLEN' type='macro'/>
     <exports symbol='VIR_CPU_USABLE' type='macro'/>
     <exports symbol='VIR_CPU_USED' type='macro'/>
     <exports symbol='VIR_DOMAIN_BANDWIDTH_IN_AVERAGE' type='macro'/>
     <exports symbol='VIR_DOMAIN_BANDWIDTH_IN_BURST' type='macro'/>
     <exports symbol='VIR_DOMAIN_BANDWIDTH_IN_FLOOR' type='macro'/>
     <exports symbol='VIR_DOMAIN_BANDWIDTH_IN_PEAK' type='macro'/>
     <exports symbol='VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE' type='macro'/>
     <exports symbol='VIR_DOMAIN_BANDWIDTH_OUT_BURST' type='macro'/>
     <exports symbol='VIR_DOMAIN_BANDWIDTH_OUT_PEAK' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLKIO_DEVICE_READ_BPS' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLKIO_DEVICE_WEIGHT' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLKIO_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLKIO_WEIGHT' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COPY_BANDWIDTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COPY_BUF_SIZE' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COPY_GRANULARITY' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_ERRS' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_READ_BYTES' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_READ_REQ' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_WRITE_REQ' type='macro'/>
     <exports symbol='VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES' type='macro'/>
     <exports symbol='VIR_DOMAIN_CPU_STATS_CPUTIME' type='macro'/>
     <exports symbol='VIR_DOMAIN_CPU_STATS_SYSTEMTIME' type='macro'/>
     <exports symbol='VIR_DOMAIN_CPU_STATS_USERTIME' type='macro'/>
     <exports symbol='VIR_DOMAIN_CPU_STATS_VCPUTIME' type='macro'/>
     <exports symbol='VIR_DOMAIN_EVENT_CALLBACK' type='macro'/>
     <exports symbol='VIR_DOMAIN_IOTHREAD_POLL_GROW' type='macro'/>
     <exports symbol='VIR_DOMAIN_IOTHREAD_POLL_MAX_NS' type='macro'/>
     <exports symbol='VIR_DOMAIN_IOTHREAD_POLL_SHRINK' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_COMPRESSION_BYTES' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_COMPRESSION_CACHE' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_COMPRESSION_PAGES' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DATA_PROCESSED' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DATA_REMAINING' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DATA_TOTAL' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DISK_BPS' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DISK_PROCESSED' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DISK_REMAINING' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DISK_TEMP_TOTAL' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DISK_TEMP_USED' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DISK_TOTAL' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DOWNTIME' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_DOWNTIME_NET' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_ERRMSG' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_BPS' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_CONSTANT' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_ITERATION' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_NORMAL' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_PROCESSED' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_REMAINING' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_MEMORY_TOTAL' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_SETUP_TIME' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_SUCCESS' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_TIME_ELAPSED' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_TIME_ELAPSED_NET' type='macro'/>
     <exports symbol='VIR_DOMAIN_JOB_TIME_REMAINING' type='macro'/>
     <exports symbol='VIR_DOMAIN_LAUNCH_SECURITY_SEV_MEASUREMENT' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_HARD_LIMIT' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_MIN_GUARANTEE' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_UNLIMITED' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_SOFT_LIMIT' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT' type='macro'/>
     <exports symbol='VIR_DOMAIN_NUMA_MODE' type='macro'/>
     <exports symbol='VIR_DOMAIN_NUMA_NODESET' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_CAP' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_CPU_SHARES' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_LIMIT' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_RESERVATION' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_SHARES' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_VCPU_PERIOD' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_VCPU_QUOTA' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHEDULER_WEIGHT' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_SEND_KEY_MAX_KEYS' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_DISK' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_VCPUPIN' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD' type='macro'/>
     <exports symbol='VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA' type='macro'/>
     <exports symbol='VIR_GET_CPUMAP' type='macro'/>
     <exports symbol='VIR_KEYCODE_SET_RFB' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_BANDWIDTH' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_COMPRESSION' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_DEST_NAME' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_DEST_XML' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_DISKS_PORT' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_GRAPHICS_URI' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_LISTEN_ADDRESS' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_MIGRATE_DISKS' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_PERSIST_XML' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_TLS_DESTINATION' type='macro'/>
     <exports symbol='VIR_MIGRATE_PARAM_URI' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_ALIGNMENT_FAULTS' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_BRANCH_INSTRUCTIONS' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_BRANCH_MISSES' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_BUS_CYCLES' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_CACHE_MISSES' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_CACHE_REFERENCES' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_CMT' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_CONTEXT_SWITCHES' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_CPU_CLOCK' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_CPU_CYCLES' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_CPU_MIGRATIONS' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_EMULATION_FAULTS' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_INSTRUCTIONS' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_MBML' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_MBMT' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_PAGE_FAULTS' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_PAGE_FAULTS_MAJ' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_PAGE_FAULTS_MIN' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_REF_CPU_CYCLES' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_STALLED_CYCLES_BACKEND' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND' type='macro'/>
     <exports symbol='VIR_PERF_PARAM_TASK_CLOCK' type='macro'/>
     <exports symbol='VIR_UNUSE_CPU' type='macro'/>
     <exports symbol='VIR_USE_CPU' type='macro'/>
     <exports symbol='_virBlkioParameter' type='macro'/>
     <exports symbol='_virMemoryParameter' type='macro'/>
     <exports symbol='_virSchedParameter' type='macro'/>
     <exports symbol='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_CHANNEL' type='enum'/>
     <exports symbol='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_DOMAIN_STARTED' type='enum'/>
     <exports symbol='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_LAST' type='enum'/>
     <exports symbol='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_UNKNOWN' type='enum'/>
     <exports symbol='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_CONNECTED' type='enum'/>
     <exports symbol='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_DISCONNECTED' type='enum'/>
     <exports symbol='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_LAST' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF' type='enum'/>
     <exports symbol='VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_ACTIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_AUTOSTART' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_HAS_CHECKPOINT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_INACTIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_NO_CHECKPOINT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_OTHER' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_PAUSED' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_PERSISTENT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_RUNNING' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_SHUTOFF' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_DOMAINS_TRANSIENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_AFFECT_CONFIG' type='enum'/>
     <exports symbol='VIR_DOMAIN_AFFECT_CURRENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_AFFECT_LIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_AGENT_RESPONSE_TIMEOUT_BLOCK' type='enum'/>
     <exports symbol='VIR_DOMAIN_AGENT_RESPONSE_TIMEOUT_DEFAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_AGENT_RESPONSE_TIMEOUT_NOWAIT' type='enum'/>
     <exports symbol='VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLKIO_PARAM_BOOLEAN' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLKIO_PARAM_DOUBLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLKIO_PARAM_INT' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLKIO_PARAM_LLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLKIO_PARAM_UINT' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLKIO_PARAM_ULLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCKED' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCKED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCKED_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COMMIT_ACTIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COMMIT_DELETE' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COMMIT_RELATIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COMMIT_SHALLOW' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COPY_REUSE_EXT' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COPY_SHALLOW' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_CANCELED' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_COMPLETED' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_FAILED' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_READY' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_TYPE_BACKUP' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_TYPE_COPY' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_TYPE_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_TYPE_PULL' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_REBASE_COPY' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_REBASE_COPY_DEV' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_REBASE_COPY_RAW' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_REBASE_RELATIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_REBASE_SHALLOW' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCK_RESIZE_BYTES' type='enum'/>
     <exports symbol='VIR_DOMAIN_CHANNEL_FORCE' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONSOLE_FORCE' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONSOLE_SAFE' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_ERROR' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_ERROR_REASON_INTERNAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_ERROR_REASON_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_ERROR_REASON_MONITOR' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_ERROR_REASON_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_ERROR_REASON_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_JOB' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_OCCUPIED' type='enum'/>
     <exports symbol='VIR_DOMAIN_CONTROL_OK' type='enum'/>
     <exports symbol='VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_LZO' type='enum'/>
     <exports symbol='VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_SNAPPY' type='enum'/>
     <exports symbol='VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_ZLIB' type='enum'/>
     <exports symbol='VIR_DOMAIN_CORE_DUMP_FORMAT_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_CORE_DUMP_FORMAT_RAW' type='enum'/>
     <exports symbol='VIR_DOMAIN_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_CRASHED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_CRASHED_PANICKED' type='enum'/>
     <exports symbol='VIR_DOMAIN_CRASHED_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_DEFINE_VALIDATE' type='enum'/>
     <exports symbol='VIR_DOMAIN_DESTROY_DEFAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_DESTROY_GRACEFUL' type='enum'/>
     <exports symbol='VIR_DOMAIN_DEVICE_MODIFY_CONFIG' type='enum'/>
     <exports symbol='VIR_DOMAIN_DEVICE_MODIFY_CURRENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_DEVICE_MODIFY_FORCE' type='enum'/>
     <exports symbol='VIR_DOMAIN_DEVICE_MODIFY_LIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_DISK_ERROR_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_DISK_ERROR_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_DISK_ERROR_NO_SPACE' type='enum'/>
     <exports symbol='VIR_DOMAIN_DISK_ERROR_UNSPEC' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_CRASHED_CRASHLOADED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_CRASHED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_CRASHED_PANICKED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED_ADDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED_RENAMED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED_UPDATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DISK_CHANGE_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_CONNECT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_AGENT_LIFECYCLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_BLOCK_JOB' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_CONTROL_ERROR' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_DEVICE_ADDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_DISK_CHANGE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_GRAPHICS' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_IO_ERROR' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_JOB_COMPLETED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_LIFECYCLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_METADATA_CHANGE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_MIGRATION_ITERATION' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_PMSUSPEND' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_PMWAKEUP' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_REBOOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_RTC_CHANGE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_TRAY_CHANGE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_TUNABLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_WATCHDOG' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_IO_ERROR_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_IO_ERROR_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_IO_ERROR_PAUSE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_IO_ERROR_REPORT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_PMSUSPENDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_PMSUSPENDED_DISK' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_PMSUSPENDED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED_POSTCOPY' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED_UNPAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SHUTDOWN_GUEST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SHUTDOWN_HOST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SHUTDOWN_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_BOOTED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_RESTORED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_WAKEUP' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_DESTROYED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_FAILED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_SAVED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_IOERROR' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_PAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_RESTORED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_UNDEFINED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_UNDEFINED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_UNDEFINED_REMOVED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_UNDEFINED_RENAMED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_DEBUG' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_INJECTNMI' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_PAUSE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_RESET' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_GET_HOSTNAME_AGENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_GET_HOSTNAME_LEASE' type='enum'/>
     <exports symbol='VIR_DOMAIN_GUEST_INFO_FILESYSTEM' type='enum'/>
     <exports symbol='VIR_DOMAIN_GUEST_INFO_HOSTNAME' type='enum'/>
     <exports symbol='VIR_DOMAIN_GUEST_INFO_OS' type='enum'/>
     <exports symbol='VIR_DOMAIN_GUEST_INFO_TIMEZONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_GUEST_INFO_USERS' type='enum'/>
     <exports symbol='VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP' type='enum'/>
     <exports symbol='VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_BOUNDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_CANCELLED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_COMPLETED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_FAILED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_BACKUP' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_DUMP' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_RESTORE' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_SAVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_SNAPSHOT_REVERT' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_START' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_OPERATION_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_STATS_COMPLETED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_STATS_KEEP_COMPLETED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_UNBOUNDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_ACTION_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_ACTION_RESTART' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_CRASH' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_POWEROFF' type='enum'/>
     <exports symbol='VIR_DOMAIN_LIFECYCLE_REBOOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_BOOLEAN' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_DOUBLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_INT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_LLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_UINT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_ULLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_AVAILABLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_DISK_CACHES' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGALLOC' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGFAIL' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_NR' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_RSS' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_SWAP_IN' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_SWAP_OUT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_UNUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_USABLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEM_CONFIG' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEM_CURRENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEM_LIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEM_MAXIMUM' type='enum'/>
     <exports symbol='VIR_DOMAIN_METADATA_DESCRIPTION' type='enum'/>
     <exports symbol='VIR_DOMAIN_METADATA_ELEMENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_METADATA_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_METADATA_TITLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY' type='enum'/>
     <exports symbol='VIR_DOMAIN_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_NOSTATE' type='enum'/>
     <exports symbol='VIR_DOMAIN_NOSTATE_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_NOSTATE_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_NUMATUNE_MEM_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_NUMATUNE_MEM_PREFERRED' type='enum'/>
     <exports symbol='VIR_DOMAIN_NUMATUNE_MEM_STRICT' type='enum'/>
     <exports symbol='VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH' type='enum'/>
     <exports symbol='VIR_DOMAIN_PASSWORD_ENCRYPTED' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_DUMP' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_IOERROR' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_MIGRATION' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_POSTCOPY' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_POSTCOPY_FAILED' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_SAVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_SHUTTING_DOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_STARTING_UP' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_USER' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED_WATCHDOG' type='enum'/>
     <exports symbol='VIR_DOMAIN_PMSUSPENDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_PMSUSPENDED_DISK_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_PMSUSPENDED_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_PMSUSPENDED_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_ABRT' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_ALRM' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_BUS' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_CHLD' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_CONT' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_FPE' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_HUP' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_ILL' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_INT' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_KILL' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_NOP' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_PIPE' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_POLL' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_PROF' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_PWR' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_QUIT' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT0' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT1' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT10' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT11' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT12' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT13' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT14' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT15' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT16' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT17' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT18' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT19' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT2' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT20' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT21' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT22' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT23' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT24' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT25' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT26' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT27' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT28' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT29' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT3' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT30' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT31' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT32' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT4' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT5' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT6' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT7' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT8' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_RT9' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_SEGV' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_STKFLT' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_STOP' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_SYS' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_TERM' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_TRAP' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_TSTP' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_TTIN' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_TTOU' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_URG' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_USR1' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_USR2' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_VTALRM' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_WINCH' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_XCPU' type='enum'/>
     <exports symbol='VIR_DOMAIN_PROCESS_SIGNAL_XFSZ' type='enum'/>
     <exports symbol='VIR_DOMAIN_REBOOT_ACPI_POWER_BTN' type='enum'/>
     <exports symbol='VIR_DOMAIN_REBOOT_DEFAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_REBOOT_GUEST_AGENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_REBOOT_INITCTL' type='enum'/>
     <exports symbol='VIR_DOMAIN_REBOOT_PARAVIRT' type='enum'/>
     <exports symbol='VIR_DOMAIN_REBOOT_SIGNAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_BOOTED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_MIGRATION_CANCELED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_POSTCOPY' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_RESTORED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_SAVE_CANCELED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_UNPAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING_WAKEUP' type='enum'/>
     <exports symbol='VIR_DOMAIN_SAVE_BYPASS_CACHE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SAVE_IMAGE_XML_SECURE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SAVE_PAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SAVE_RUNNING' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_BOOLEAN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_DOUBLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_INT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_LLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_UINT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_ULLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN_DEFAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN_GUEST_AGENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN_INITCTL' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN_PARAVIRT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN_SIGNAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN_USER' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_DAEMON' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_DESTROYED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_FAILED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_SAVED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF_UNKNOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_START_AUTODESTROY' type='enum'/>
     <exports symbol='VIR_DOMAIN_START_BYPASS_CACHE' type='enum'/>
     <exports symbol='VIR_DOMAIN_START_FORCE_BOOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_START_PAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_START_VALIDATE' type='enum'/>
     <exports symbol='VIR_DOMAIN_STATS_BALLOON' type='enum'/>
     <exports symbol='VIR_DOMAIN_STATS_BLOCK' type='enum'/>
     <exports symbol='VIR_DOMAIN_STATS_CPU_TOTAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_STATS_INTERFACE' type='enum'/>
     <exports symbol='VIR_DOMAIN_STATS_IOTHREAD' type='enum'/>
     <exports symbol='VIR_DOMAIN_STATS_MEMORY' type='enum'/>
     <exports symbol='VIR_DOMAIN_STATS_PERF' type='enum'/>
     <exports symbol='VIR_DOMAIN_STATS_STATE' type='enum'/>
     <exports symbol='VIR_DOMAIN_STATS_VCPU' type='enum'/>
     <exports symbol='VIR_DOMAIN_TIME_SYNC' type='enum'/>
     <exports symbol='VIR_DOMAIN_UNDEFINE_CHECKPOINTS_METADATA' type='enum'/>
     <exports symbol='VIR_DOMAIN_UNDEFINE_KEEP_NVRAM' type='enum'/>
     <exports symbol='VIR_DOMAIN_UNDEFINE_MANAGED_SAVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_UNDEFINE_NVRAM' type='enum'/>
     <exports symbol='VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA' type='enum'/>
     <exports symbol='VIR_DOMAIN_VCPU_CONFIG' type='enum'/>
     <exports symbol='VIR_DOMAIN_VCPU_CURRENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_VCPU_GUEST' type='enum'/>
     <exports symbol='VIR_DOMAIN_VCPU_HOTPLUGGABLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_VCPU_LIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_VCPU_MAXIMUM' type='enum'/>
     <exports symbol='VIR_DOMAIN_XML_INACTIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_XML_MIGRATABLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_XML_SECURE' type='enum'/>
     <exports symbol='VIR_DOMAIN_XML_UPDATE_CPU' type='enum'/>
     <exports symbol='VIR_DUMP_BYPASS_CACHE' type='enum'/>
     <exports symbol='VIR_DUMP_CRASH' type='enum'/>
     <exports symbol='VIR_DUMP_LIVE' type='enum'/>
     <exports symbol='VIR_DUMP_MEMORY_ONLY' type='enum'/>
     <exports symbol='VIR_DUMP_RESET' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_ATSET1' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_ATSET2' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_ATSET3' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_LAST' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_LINUX' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_OSX' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_QNUM' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_USB' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_WIN32' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_XT' type='enum'/>
     <exports symbol='VIR_KEYCODE_SET_XT_KBD' type='enum'/>
     <exports symbol='VIR_MEMORY_PHYSICAL' type='enum'/>
     <exports symbol='VIR_MEMORY_VIRTUAL' type='enum'/>
     <exports symbol='VIR_MIGRATE_ABORT_ON_ERROR' type='enum'/>
     <exports symbol='VIR_MIGRATE_AUTO_CONVERGE' type='enum'/>
     <exports symbol='VIR_MIGRATE_CHANGE_PROTECTION' type='enum'/>
     <exports symbol='VIR_MIGRATE_COMPRESSED' type='enum'/>
     <exports symbol='VIR_MIGRATE_LIVE' type='enum'/>
     <exports symbol='VIR_MIGRATE_NON_SHARED_DISK' type='enum'/>
     <exports symbol='VIR_MIGRATE_NON_SHARED_INC' type='enum'/>
     <exports symbol='VIR_MIGRATE_OFFLINE' type='enum'/>
     <exports symbol='VIR_MIGRATE_PARALLEL' type='enum'/>
     <exports symbol='VIR_MIGRATE_PAUSED' type='enum'/>
     <exports symbol='VIR_MIGRATE_PEER2PEER' type='enum'/>
     <exports symbol='VIR_MIGRATE_PERSIST_DEST' type='enum'/>
     <exports symbol='VIR_MIGRATE_POSTCOPY' type='enum'/>
     <exports symbol='VIR_MIGRATE_RDMA_PIN_ALL' type='enum'/>
     <exports symbol='VIR_MIGRATE_TLS' type='enum'/>
     <exports symbol='VIR_MIGRATE_TUNNELLED' type='enum'/>
     <exports symbol='VIR_MIGRATE_UNDEFINE_SOURCE' type='enum'/>
     <exports symbol='VIR_MIGRATE_UNSAFE' type='enum'/>
     <exports symbol='VIR_VCPU_BLOCKED' type='enum'/>
     <exports symbol='VIR_VCPU_LAST' type='enum'/>
     <exports symbol='VIR_VCPU_OFFLINE' type='enum'/>
     <exports symbol='VIR_VCPU_RUNNING' type='enum'/>
     <exports symbol='virBlkioParameter' type='typedef'/>
     <exports symbol='virBlkioParameterPtr' type='typedef'/>
     <exports symbol='virBlkioParameterType' type='typedef'/>
     <exports symbol='virConnectDomainEventAgentLifecycleReason' type='typedef'/>
     <exports symbol='virConnectDomainEventAgentLifecycleState' type='typedef'/>
     <exports symbol='virConnectDomainEventBlockJobStatus' type='typedef'/>
     <exports symbol='virConnectDomainEventDiskChangeReason' type='typedef'/>
     <exports symbol='virConnectGetAllDomainStatsFlags' type='typedef'/>
     <exports symbol='virConnectListAllDomainsFlags' type='typedef'/>
     <exports symbol='virDomain' type='typedef'/>
     <exports symbol='virDomainAgentResponseTimeoutValues' type='typedef'/>
     <exports symbol='virDomainBackupBeginFlags' type='typedef'/>
     <exports symbol='virDomainBlockCommitFlags' type='typedef'/>
     <exports symbol='virDomainBlockCopyFlags' type='typedef'/>
     <exports symbol='virDomainBlockInfo' type='typedef'/>
     <exports symbol='virDomainBlockInfoPtr' type='typedef'/>
     <exports symbol='virDomainBlockJobAbortFlags' type='typedef'/>
     <exports symbol='virDomainBlockJobCursor' type='typedef'/>
     <exports symbol='virDomainBlockJobInfo' type='typedef'/>
     <exports symbol='virDomainBlockJobInfoFlags' type='typedef'/>
     <exports symbol='virDomainBlockJobInfoPtr' type='typedef'/>
     <exports symbol='virDomainBlockJobSetSpeedFlags' type='typedef'/>
     <exports symbol='virDomainBlockJobType' type='typedef'/>
     <exports symbol='virDomainBlockPullFlags' type='typedef'/>
     <exports symbol='virDomainBlockRebaseFlags' type='typedef'/>
     <exports symbol='virDomainBlockResizeFlags' type='typedef'/>
     <exports symbol='virDomainBlockStatsPtr' type='typedef'/>
     <exports symbol='virDomainBlockStatsStruct' type='typedef'/>
     <exports symbol='virDomainBlockedReason' type='typedef'/>
     <exports symbol='virDomainChannelFlags' type='typedef'/>
     <exports symbol='virDomainConsoleFlags' type='typedef'/>
     <exports symbol='virDomainControlErrorReason' type='typedef'/>
     <exports symbol='virDomainControlInfo' type='typedef'/>
     <exports symbol='virDomainControlInfoPtr' type='typedef'/>
     <exports symbol='virDomainControlState' type='typedef'/>
     <exports symbol='virDomainCoreDumpFlags' type='typedef'/>
     <exports symbol='virDomainCoreDumpFormat' type='typedef'/>
     <exports symbol='virDomainCrashedReason' type='typedef'/>
     <exports symbol='virDomainCreateFlags' type='typedef'/>
     <exports symbol='virDomainDefineFlags' type='typedef'/>
     <exports symbol='virDomainDestroyFlagsValues' type='typedef'/>
     <exports symbol='virDomainDeviceModifyFlags' type='typedef'/>
     <exports symbol='virDomainDiskError' type='typedef'/>
     <exports symbol='virDomainDiskErrorCode' type='typedef'/>
     <exports symbol='virDomainDiskErrorPtr' type='typedef'/>
     <exports symbol='virDomainEventCrashedDetailType' type='typedef'/>
     <exports symbol='virDomainEventDefinedDetailType' type='typedef'/>
     <exports symbol='virDomainEventGraphicsAddress' type='typedef'/>
     <exports symbol='virDomainEventGraphicsAddressPtr' type='typedef'/>
     <exports symbol='virDomainEventGraphicsAddressType' type='typedef'/>
     <exports symbol='virDomainEventGraphicsPhase' type='typedef'/>
     <exports symbol='virDomainEventGraphicsSubject' type='typedef'/>
     <exports symbol='virDomainEventGraphicsSubjectIdentity' type='typedef'/>
     <exports symbol='virDomainEventGraphicsSubjectIdentityPtr' type='typedef'/>
     <exports symbol='virDomainEventGraphicsSubjectPtr' type='typedef'/>
     <exports symbol='virDomainEventID' type='typedef'/>
     <exports symbol='virDomainEventIOErrorAction' type='typedef'/>
     <exports symbol='virDomainEventPMSuspendedDetailType' type='typedef'/>
     <exports symbol='virDomainEventResumedDetailType' type='typedef'/>
     <exports symbol='virDomainEventShutdownDetailType' type='typedef'/>
     <exports symbol='virDomainEventStartedDetailType' type='typedef'/>
     <exports symbol='virDomainEventStoppedDetailType' type='typedef'/>
     <exports symbol='virDomainEventSuspendedDetailType' type='typedef'/>
     <exports symbol='virDomainEventTrayChangeReason' type='typedef'/>
     <exports symbol='virDomainEventType' type='typedef'/>
     <exports symbol='virDomainEventUndefinedDetailType' type='typedef'/>
     <exports symbol='virDomainEventWatchdogAction' type='typedef'/>
     <exports symbol='virDomainFSInfo' type='typedef'/>
     <exports symbol='virDomainFSInfoPtr' type='typedef'/>
     <exports symbol='virDomainGetHostnameFlags' type='typedef'/>
     <exports symbol='virDomainGetJobStatsFlags' type='typedef'/>
     <exports symbol='virDomainGuestInfoTypes' type='typedef'/>
     <exports symbol='virDomainIOThreadInfo' type='typedef'/>
     <exports symbol='virDomainIOThreadInfoPtr' type='typedef'/>
     <exports symbol='virDomainIPAddress' type='typedef'/>
     <exports symbol='virDomainIPAddressPtr' type='typedef'/>
     <exports symbol='virDomainInfo' type='typedef'/>
     <exports symbol='virDomainInfoPtr' type='typedef'/>
     <exports symbol='virDomainInterface' type='typedef'/>
     <exports symbol='virDomainInterfaceAddressesSource' type='typedef'/>
     <exports symbol='virDomainInterfacePtr' type='typedef'/>
     <exports symbol='virDomainInterfaceStatsPtr' type='typedef'/>
     <exports symbol='virDomainInterfaceStatsStruct' type='typedef'/>
     <exports symbol='virDomainJobInfo' type='typedef'/>
     <exports symbol='virDomainJobInfoPtr' type='typedef'/>
     <exports symbol='virDomainJobOperation' type='typedef'/>
     <exports symbol='virDomainJobType' type='typedef'/>
     <exports symbol='virDomainLifecycle' type='typedef'/>
     <exports symbol='virDomainLifecycleAction' type='typedef'/>
     <exports symbol='virDomainMemoryFlags' type='typedef'/>
     <exports symbol='virDomainMemoryModFlags' type='typedef'/>
     <exports symbol='virDomainMemoryStatPtr' type='typedef'/>
     <exports symbol='virDomainMemoryStatStruct' type='typedef'/>
     <exports symbol='virDomainMemoryStatTags' type='typedef'/>
     <exports symbol='virDomainMetadataType' type='typedef'/>
     <exports symbol='virDomainMigrateFlags' type='typedef'/>
     <exports symbol='virDomainMigrateMaxSpeedFlags' type='typedef'/>
     <exports symbol='virDomainModificationImpact' type='typedef'/>
     <exports symbol='virDomainNostateReason' type='typedef'/>
     <exports symbol='virDomainNumatuneMemMode' type='typedef'/>
     <exports symbol='virDomainOpenGraphicsFlags' type='typedef'/>
     <exports symbol='virDomainPMSuspendedDiskReason' type='typedef'/>
     <exports symbol='virDomainPMSuspendedReason' type='typedef'/>
     <exports symbol='virDomainPausedReason' type='typedef'/>
     <exports symbol='virDomainProcessSignal' type='typedef'/>
     <exports symbol='virDomainPtr' type='typedef'/>
     <exports symbol='virDomainRebootFlagValues' type='typedef'/>
     <exports symbol='virDomainRunningReason' type='typedef'/>
     <exports symbol='virDomainSaveImageXMLFlags' type='typedef'/>
     <exports symbol='virDomainSaveRestoreFlags' type='typedef'/>
     <exports symbol='virDomainSetTimeFlags' type='typedef'/>
     <exports symbol='virDomainSetUserPasswordFlags' type='typedef'/>
     <exports symbol='virDomainShutdownFlagValues' type='typedef'/>
     <exports symbol='virDomainShutdownReason' type='typedef'/>
     <exports symbol='virDomainShutoffReason' type='typedef'/>
     <exports symbol='virDomainState' type='typedef'/>
     <exports symbol='virDomainStatsRecord' type='typedef'/>
     <exports symbol='virDomainStatsRecordPtr' type='typedef'/>
     <exports symbol='virDomainStatsTypes' type='typedef'/>
     <exports symbol='virDomainUndefineFlagsValues' type='typedef'/>
     <exports symbol='virDomainVcpuFlags' type='typedef'/>
     <exports symbol='virDomainXMLFlags' type='typedef'/>
     <exports symbol='virKeycodeSet' type='typedef'/>
     <exports symbol='virMemoryParameter' type='typedef'/>
     <exports symbol='virMemoryParameterPtr' type='typedef'/>
     <exports symbol='virMemoryParameterType' type='typedef'/>
     <exports symbol='virSchedParameter' type='typedef'/>
     <exports symbol='virSchedParameterPtr' type='typedef'/>
     <exports symbol='virSchedParameterType' type='typedef'/>
     <exports symbol='virVcpuInfo' type='typedef'/>
     <exports symbol='virVcpuInfoPtr' type='typedef'/>
     <exports symbol='virVcpuState' type='typedef'/>
     <exports symbol='_virDomainBlockInfo' type='struct'/>
     <exports symbol='_virDomainBlockJobInfo' type='struct'/>
     <exports symbol='_virDomainBlockStats' type='struct'/>
     <exports symbol='_virDomainControlInfo' type='struct'/>
     <exports symbol='_virDomainDiskError' type='struct'/>
     <exports symbol='_virDomainEventGraphicsAddress' type='struct'/>
     <exports symbol='_virDomainEventGraphicsSubject' type='struct'/>
     <exports symbol='_virDomainEventGraphicsSubjectIdentity' type='struct'/>
     <exports symbol='_virDomainFSInfo' type='struct'/>
     <exports symbol='_virDomainIOThreadInfo' type='struct'/>
     <exports symbol='_virDomainInfo' type='struct'/>
     <exports symbol='_virDomainInterface' type='struct'/>
     <exports symbol='_virDomainInterfaceIPAddress' type='struct'/>
     <exports symbol='_virDomainInterfaceStats' type='struct'/>
     <exports symbol='_virDomainJobInfo' type='struct'/>
     <exports symbol='_virDomainMemoryStat' type='struct'/>
     <exports symbol='_virDomainStatsRecord' type='struct'/>
     <exports symbol='_virVcpuInfo' type='struct'/>
     <exports symbol='virConnectDomainEventAgentLifecycleCallback' type='function'/>
     <exports symbol='virConnectDomainEventBalloonChangeCallback' type='function'/>
     <exports symbol='virConnectDomainEventBlockJobCallback' type='function'/>
     <exports symbol='virConnectDomainEventBlockThresholdCallback' type='function'/>
     <exports symbol='virConnectDomainEventCallback' type='function'/>
     <exports symbol='virConnectDomainEventDeregister' type='function'/>
     <exports symbol='virConnectDomainEventDeregisterAny' type='function'/>
     <exports symbol='virConnectDomainEventDeviceAddedCallback' type='function'/>
     <exports symbol='virConnectDomainEventDeviceRemovalFailedCallback' type='function'/>
     <exports symbol='virConnectDomainEventDeviceRemovedCallback' type='function'/>
     <exports symbol='virConnectDomainEventDiskChangeCallback' type='function'/>
     <exports symbol='virConnectDomainEventGenericCallback' type='function'/>
     <exports symbol='virConnectDomainEventGraphicsCallback' type='function'/>
     <exports symbol='virConnectDomainEventIOErrorCallback' type='function'/>
     <exports symbol='virConnectDomainEventIOErrorReasonCallback' type='function'/>
     <exports symbol='virConnectDomainEventJobCompletedCallback' type='function'/>
     <exports symbol='virConnectDomainEventMetadataChangeCallback' type='function'/>
     <exports symbol='virConnectDomainEventMigrationIterationCallback' type='function'/>
     <exports symbol='virConnectDomainEventPMSuspendCallback' type='function'/>
     <exports symbol='virConnectDomainEventPMSuspendDiskCallback' type='function'/>
     <exports symbol='virConnectDomainEventPMWakeupCallback' type='function'/>
     <exports symbol='virConnectDomainEventRTCChangeCallback' type='function'/>
     <exports symbol='virConnectDomainEventRegister' type='function'/>
     <exports symbol='virConnectDomainEventRegisterAny' type='function'/>
     <exports symbol='virConnectDomainEventTrayChangeCallback' type='function'/>
     <exports symbol='virConnectDomainEventTunableCallback' type='function'/>
     <exports symbol='virConnectDomainEventWatchdogCallback' type='function'/>
     <exports symbol='virConnectDomainXMLFromNative' type='function'/>
     <exports symbol='virConnectDomainXMLToNative' type='function'/>
     <exports symbol='virConnectGetAllDomainStats' type='function'/>
     <exports symbol='virConnectGetDomainCapabilities' type='function'/>
     <exports symbol='virConnectListAllDomains' type='function'/>
     <exports symbol='virConnectListDefinedDomains' type='function'/>
     <exports symbol='virConnectListDomains' type='function'/>
     <exports symbol='virConnectNumOfDefinedDomains' type='function'/>
     <exports symbol='virConnectNumOfDomains' type='function'/>
     <exports symbol='virDomainAbortJob' type='function'/>
     <exports symbol='virDomainAddIOThread' type='function'/>
     <exports symbol='virDomainAgentSetResponseTimeout' type='function'/>
     <exports symbol='virDomainAttachDevice' type='function'/>
     <exports symbol='virDomainAttachDeviceFlags' type='function'/>
     <exports symbol='virDomainBackupBegin' type='function'/>
     <exports symbol='virDomainBackupGetXMLDesc' type='function'/>
     <exports symbol='virDomainBlockCommit' type='function'/>
     <exports symbol='virDomainBlockCopy' type='function'/>
     <exports symbol='virDomainBlockJobAbort' type='function'/>
     <exports symbol='virDomainBlockJobSetSpeed' type='function'/>
     <exports symbol='virDomainBlockPeek' type='function'/>
     <exports symbol='virDomainBlockPull' type='function'/>
     <exports symbol='virDomainBlockRebase' type='function'/>
     <exports symbol='virDomainBlockResize' type='function'/>
     <exports symbol='virDomainBlockStats' type='function'/>
     <exports symbol='virDomainBlockStatsFlags' type='function'/>
     <exports symbol='virDomainCoreDump' type='function'/>
     <exports symbol='virDomainCoreDumpWithFormat' type='function'/>
     <exports symbol='virDomainCreate' type='function'/>
     <exports symbol='virDomainCreateLinux' type='function'/>
     <exports symbol='virDomainCreateWithFiles' type='function'/>
     <exports symbol='virDomainCreateWithFlags' type='function'/>
     <exports symbol='virDomainCreateXML' type='function'/>
     <exports symbol='virDomainCreateXMLWithFiles' type='function'/>
     <exports symbol='virDomainDefineXML' type='function'/>
     <exports symbol='virDomainDefineXMLFlags' type='function'/>
     <exports symbol='virDomainDelIOThread' type='function'/>
     <exports symbol='virDomainDestroy' type='function'/>
     <exports symbol='virDomainDestroyFlags' type='function'/>
     <exports symbol='virDomainDetachDevice' type='function'/>
     <exports symbol='virDomainDetachDeviceAlias' type='function'/>
     <exports symbol='virDomainDetachDeviceFlags' type='function'/>
     <exports symbol='virDomainFSFreeze' type='function'/>
     <exports symbol='virDomainFSInfoFree' type='function'/>
     <exports symbol='virDomainFSThaw' type='function'/>
     <exports symbol='virDomainFSTrim' type='function'/>
     <exports symbol='virDomainFree' type='function'/>
     <exports symbol='virDomainGetAutostart' type='function'/>
     <exports symbol='virDomainGetBlkioParameters' type='function'/>
     <exports symbol='virDomainGetBlockInfo' type='function'/>
     <exports symbol='virDomainGetBlockIoTune' type='function'/>
     <exports symbol='virDomainGetBlockJobInfo' type='function'/>
     <exports symbol='virDomainGetCPUStats' type='function'/>
     <exports symbol='virDomainGetConnect' type='function'/>
     <exports symbol='virDomainGetControlInfo' type='function'/>
     <exports symbol='virDomainGetDiskErrors' type='function'/>
     <exports symbol='virDomainGetEmulatorPinInfo' type='function'/>
     <exports symbol='virDomainGetFSInfo' type='function'/>
     <exports symbol='virDomainGetGuestInfo' type='function'/>
     <exports symbol='virDomainGetGuestVcpus' type='function'/>
     <exports symbol='virDomainGetHostname' type='function'/>
     <exports symbol='virDomainGetID' type='function'/>
     <exports symbol='virDomainGetIOThreadInfo' type='function'/>
     <exports symbol='virDomainGetInfo' type='function'/>
     <exports symbol='virDomainGetInterfaceParameters' type='function'/>
     <exports symbol='virDomainGetJobInfo' type='function'/>
     <exports symbol='virDomainGetJobStats' type='function'/>
     <exports symbol='virDomainGetLaunchSecurityInfo' type='function'/>
     <exports symbol='virDomainGetMaxMemory' type='function'/>
     <exports symbol='virDomainGetMaxVcpus' type='function'/>
     <exports symbol='virDomainGetMemoryParameters' type='function'/>
     <exports symbol='virDomainGetMetadata' type='function'/>
     <exports symbol='virDomainGetName' type='function'/>
     <exports symbol='virDomainGetNumaParameters' type='function'/>
     <exports symbol='virDomainGetOSType' type='function'/>
     <exports symbol='virDomainGetPerfEvents' type='function'/>
     <exports symbol='virDomainGetSchedulerParameters' type='function'/>
     <exports symbol='virDomainGetSchedulerParametersFlags' type='function'/>
     <exports symbol='virDomainGetSchedulerType' type='function'/>
     <exports symbol='virDomainGetSecurityLabel' type='function'/>
     <exports symbol='virDomainGetSecurityLabelList' type='function'/>
     <exports symbol='virDomainGetState' type='function'/>
     <exports symbol='virDomainGetTime' type='function'/>
     <exports symbol='virDomainGetUUID' type='function'/>
     <exports symbol='virDomainGetUUIDString' type='function'/>
     <exports symbol='virDomainGetVcpuPinInfo' type='function'/>
     <exports symbol='virDomainGetVcpus' type='function'/>
     <exports symbol='virDomainGetVcpusFlags' type='function'/>
     <exports symbol='virDomainGetXMLDesc' type='function'/>
     <exports symbol='virDomainHasManagedSaveImage' type='function'/>
     <exports symbol='virDomainIOThreadInfoFree' type='function'/>
     <exports symbol='virDomainInjectNMI' type='function'/>
     <exports symbol='virDomainInterfaceAddresses' type='function'/>
     <exports symbol='virDomainInterfaceFree' type='function'/>
     <exports symbol='virDomainInterfaceStats' type='function'/>
     <exports symbol='virDomainIsActive' type='function'/>
     <exports symbol='virDomainIsPersistent' type='function'/>
     <exports symbol='virDomainIsUpdated' type='function'/>
     <exports symbol='virDomainListGetStats' type='function'/>
     <exports symbol='virDomainLookupByID' type='function'/>
     <exports symbol='virDomainLookupByName' type='function'/>
     <exports symbol='virDomainLookupByUUID' type='function'/>
     <exports symbol='virDomainLookupByUUIDString' type='function'/>
     <exports symbol='virDomainManagedSave' type='function'/>
     <exports symbol='virDomainManagedSaveDefineXML' type='function'/>
     <exports symbol='virDomainManagedSaveGetXMLDesc' type='function'/>
     <exports symbol='virDomainManagedSaveRemove' type='function'/>
     <exports symbol='virDomainMemoryPeek' type='function'/>
     <exports symbol='virDomainMemoryStats' type='function'/>
     <exports symbol='virDomainMigrate' type='function'/>
     <exports symbol='virDomainMigrate2' type='function'/>
     <exports symbol='virDomainMigrate3' type='function'/>
     <exports symbol='virDomainMigrateGetCompressionCache' type='function'/>
     <exports symbol='virDomainMigrateGetMaxDowntime' type='function'/>
     <exports symbol='virDomainMigrateGetMaxSpeed' type='function'/>
     <exports symbol='virDomainMigrateSetCompressionCache' type='function'/>
     <exports symbol='virDomainMigrateSetMaxDowntime' type='function'/>
     <exports symbol='virDomainMigrateSetMaxSpeed' type='function'/>
     <exports symbol='virDomainMigrateStartPostCopy' type='function'/>
     <exports symbol='virDomainMigrateToURI' type='function'/>
     <exports symbol='virDomainMigrateToURI2' type='function'/>
     <exports symbol='virDomainMigrateToURI3' type='function'/>
     <exports symbol='virDomainOpenChannel' type='function'/>
     <exports symbol='virDomainOpenConsole' type='function'/>
     <exports symbol='virDomainOpenGraphics' type='function'/>
     <exports symbol='virDomainOpenGraphicsFD' type='function'/>
     <exports symbol='virDomainPMSuspendForDuration' type='function'/>
     <exports symbol='virDomainPMWakeup' type='function'/>
     <exports symbol='virDomainPinEmulator' type='function'/>
     <exports symbol='virDomainPinIOThread' type='function'/>
     <exports symbol='virDomainPinVcpu' type='function'/>
     <exports symbol='virDomainPinVcpuFlags' type='function'/>
     <exports symbol='virDomainReboot' type='function'/>
     <exports symbol='virDomainRef' type='function'/>
     <exports symbol='virDomainRename' type='function'/>
     <exports symbol='virDomainReset' type='function'/>
     <exports symbol='virDomainRestore' type='function'/>
     <exports symbol='virDomainRestoreFlags' type='function'/>
     <exports symbol='virDomainResume' type='function'/>
     <exports symbol='virDomainSave' type='function'/>
     <exports symbol='virDomainSaveFlags' type='function'/>
     <exports symbol='virDomainSaveImageDefineXML' type='function'/>
     <exports symbol='virDomainSaveImageGetXMLDesc' type='function'/>
     <exports symbol='virDomainScreenshot' type='function'/>
     <exports symbol='virDomainSendKey' type='function'/>
     <exports symbol='virDomainSendProcessSignal' type='function'/>
     <exports symbol='virDomainSetAutostart' type='function'/>
     <exports symbol='virDomainSetBlkioParameters' type='function'/>
     <exports symbol='virDomainSetBlockIoTune' type='function'/>
     <exports symbol='virDomainSetBlockThreshold' type='function'/>
     <exports symbol='virDomainSetGuestVcpus' type='function'/>
     <exports symbol='virDomainSetIOThreadParams' type='function'/>
     <exports symbol='virDomainSetInterfaceParameters' type='function'/>
     <exports symbol='virDomainSetLifecycleAction' type='function'/>
     <exports symbol='virDomainSetMaxMemory' type='function'/>
     <exports symbol='virDomainSetMemory' type='function'/>
     <exports symbol='virDomainSetMemoryFlags' type='function'/>
     <exports symbol='virDomainSetMemoryParameters' type='function'/>
     <exports symbol='virDomainSetMemoryStatsPeriod' type='function'/>
     <exports symbol='virDomainSetMetadata' type='function'/>
     <exports symbol='virDomainSetNumaParameters' type='function'/>
     <exports symbol='virDomainSetPerfEvents' type='function'/>
     <exports symbol='virDomainSetSchedulerParameters' type='function'/>
     <exports symbol='virDomainSetSchedulerParametersFlags' type='function'/>
     <exports symbol='virDomainSetTime' type='function'/>
     <exports symbol='virDomainSetUserPassword' type='function'/>
     <exports symbol='virDomainSetVcpu' type='function'/>
     <exports symbol='virDomainSetVcpus' type='function'/>
     <exports symbol='virDomainSetVcpusFlags' type='function'/>
     <exports symbol='virDomainShutdown' type='function'/>
     <exports symbol='virDomainShutdownFlags' type='function'/>
     <exports symbol='virDomainStatsRecordListFree' type='function'/>
     <exports symbol='virDomainSuspend' type='function'/>
     <exports symbol='virDomainUndefine' type='function'/>
     <exports symbol='virDomainUndefineFlags' type='function'/>
     <exports symbol='virDomainUpdateDeviceFlags' type='function'/>
    </file>
    <file name='libvirt-event'>
     <summary>APIs for management of events</summary>
     <description>Provides APIs for the management of events  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_EVENT_HANDLE_ERROR' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_HANGUP' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_READABLE' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_WRITABLE' type='enum'/>
     <exports symbol='virEventHandleType' type='typedef'/>
     <exports symbol='virEventAddHandle' type='function'/>
     <exports symbol='virEventAddHandleFunc' type='function'/>
     <exports symbol='virEventAddTimeout' type='function'/>
     <exports symbol='virEventAddTimeoutFunc' type='function'/>
     <exports symbol='virEventHandleCallback' type='function'/>
     <exports symbol='virEventRegisterDefaultImpl' type='function'/>
     <exports symbol='virEventRegisterImpl' type='function'/>
     <exports symbol='virEventRemoveHandle' type='function'/>
     <exports symbol='virEventRemoveHandleFunc' type='function'/>
     <exports symbol='virEventRemoveTimeout' type='function'/>
     <exports symbol='virEventRemoveTimeoutFunc' type='function'/>
     <exports symbol='virEventRunDefaultImpl' type='function'/>
     <exports symbol='virEventTimeoutCallback' type='function'/>
     <exports symbol='virEventUpdateHandle' type='function'/>
     <exports symbol='virEventUpdateHandleFunc' type='function'/>
     <exports symbol='virEventUpdateTimeout' type='function'/>
     <exports symbol='virEventUpdateTimeoutFunc' type='function'/>
    </file>
    <file name='libvirt-host'>
     <summary>APIs for management of hosts</summary>
     <description>Provides APIs for the management of hosts  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_CONNECT_IDENTITY_GROUP_NAME' type='macro'/>
     <exports symbol='VIR_CONNECT_IDENTITY_PROCESS_ID' type='macro'/>
     <exports symbol='VIR_CONNECT_IDENTITY_PROCESS_TIME' type='macro'/>
     <exports symbol='VIR_CONNECT_IDENTITY_SASL_USER_NAME' type='macro'/>
     <exports symbol='VIR_CONNECT_IDENTITY_SELINUX_CONTEXT' type='macro'/>
     <exports symbol='VIR_CONNECT_IDENTITY_UNIX_GROUP_ID' type='macro'/>
     <exports symbol='VIR_CONNECT_IDENTITY_UNIX_USER_ID' type='macro'/>
     <exports symbol='VIR_CONNECT_IDENTITY_USER_NAME' type='macro'/>
     <exports symbol='VIR_CONNECT_IDENTITY_X509_DISTINGUISHED_NAME' type='macro'/>
     <exports symbol='VIR_NODEINFO_MAXCPUS' type='macro'/>
     <exports symbol='VIR_NODE_CPU_STATS_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_NODE_CPU_STATS_IDLE' type='macro'/>
     <exports symbol='VIR_NODE_CPU_STATS_INTR' type='macro'/>
     <exports symbol='VIR_NODE_CPU_STATS_IOWAIT' type='macro'/>
     <exports symbol='VIR_NODE_CPU_STATS_KERNEL' type='macro'/>
     <exports symbol='VIR_NODE_CPU_STATS_USER' type='macro'/>
     <exports symbol='VIR_NODE_CPU_STATS_UTILIZATION' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_SHARED_FULL_SCANS' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_SHARED_PAGES_SHARED' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_SHARED_PAGES_SHARING' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_SHARED_PAGES_TO_SCAN' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_SHARED_PAGES_UNSHARED' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_SHARED_PAGES_VOLATILE' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_SHARED_SLEEP_MILLISECS' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_STATS_BUFFERS' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_STATS_CACHED' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_STATS_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_STATS_FREE' type='macro'/>
     <exports symbol='VIR_NODE_MEMORY_STATS_TOTAL' type='macro'/>
     <exports symbol='VIR_NODE_SEV_CBITPOS' type='macro'/>
     <exports symbol='VIR_NODE_SEV_CERT_CHAIN' type='macro'/>
     <exports symbol='VIR_NODE_SEV_PDH' type='macro'/>
     <exports symbol='VIR_NODE_SEV_REDUCED_PHYS_BITS' type='macro'/>
     <exports symbol='VIR_SECURITY_DOI_BUFLEN' type='macro'/>
     <exports symbol='VIR_SECURITY_LABEL_BUFLEN' type='macro'/>
     <exports symbol='VIR_SECURITY_MODEL_BUFLEN' type='macro'/>
     <exports symbol='VIR_UUID_BUFLEN' type='macro'/>
     <exports symbol='VIR_UUID_STRING_BUFLEN' type='macro'/>
     <exports symbol='VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES' type='enum'/>
     <exports symbol='VIR_CONNECT_BASELINE_CPU_MIGRATABLE' type='enum'/>
     <exports symbol='VIR_CONNECT_COMPARE_CPU_FAIL_INCOMPATIBLE' type='enum'/>
     <exports symbol='VIR_CONNECT_NO_ALIASES' type='enum'/>
     <exports symbol='VIR_CONNECT_RO' type='enum'/>
     <exports symbol='VIR_CPU_COMPARE_ERROR' type='enum'/>
     <exports symbol='VIR_CPU_COMPARE_IDENTICAL' type='enum'/>
     <exports symbol='VIR_CPU_COMPARE_INCOMPATIBLE' type='enum'/>
     <exports symbol='VIR_CPU_COMPARE_LAST' type='enum'/>
     <exports symbol='VIR_CPU_COMPARE_SUPERSET' type='enum'/>
     <exports symbol='VIR_CRED_AUTHNAME' type='enum'/>
     <exports symbol='VIR_CRED_CNONCE' type='enum'/>
     <exports symbol='VIR_CRED_ECHOPROMPT' type='enum'/>
     <exports symbol='VIR_CRED_EXTERNAL' type='enum'/>
     <exports symbol='VIR_CRED_LANGUAGE' type='enum'/>
     <exports symbol='VIR_CRED_LAST' type='enum'/>
     <exports symbol='VIR_CRED_NOECHOPROMPT' type='enum'/>
     <exports symbol='VIR_CRED_PASSPHRASE' type='enum'/>
     <exports symbol='VIR_CRED_REALM' type='enum'/>
     <exports symbol='VIR_CRED_USERNAME' type='enum'/>
     <exports symbol='VIR_NODE_ALLOC_PAGES_ADD' type='enum'/>
     <exports symbol='VIR_NODE_ALLOC_PAGES_SET' type='enum'/>
     <exports symbol='VIR_NODE_CPU_STATS_ALL_CPUS' type='enum'/>
     <exports symbol='VIR_NODE_MEMORY_STATS_ALL_CELLS' type='enum'/>
     <exports symbol='VIR_NODE_SUSPEND_TARGET_DISK' type='enum'/>
     <exports symbol='VIR_NODE_SUSPEND_TARGET_HYBRID' type='enum'/>
     <exports symbol='VIR_NODE_SUSPEND_TARGET_LAST' type='enum'/>
     <exports symbol='VIR_NODE_SUSPEND_TARGET_MEM' type='enum'/>
     <exports symbol='virCPUCompareResult' type='typedef'/>
     <exports symbol='virConnect' type='typedef'/>
     <exports symbol='virConnectAuth' type='typedef'/>
     <exports symbol='virConnectAuthPtr' type='typedef'/>
     <exports symbol='virConnectBaselineCPUFlags' type='typedef'/>
     <exports symbol='virConnectCompareCPUFlags' type='typedef'/>
     <exports symbol='virConnectCredential' type='typedef'/>
     <exports symbol='virConnectCredentialPtr' type='typedef'/>
     <exports symbol='virConnectCredentialType' type='typedef'/>
     <exports symbol='virConnectFlags' type='typedef'/>
     <exports symbol='virConnectPtr' type='typedef'/>
     <exports symbol='virNodeAllocPagesFlags' type='typedef'/>
     <exports symbol='virNodeCPUStats' type='typedef'/>
     <exports symbol='virNodeCPUStatsPtr' type='typedef'/>
     <exports symbol='virNodeGetCPUStatsAllCPUs' type='typedef'/>
     <exports symbol='virNodeGetMemoryStatsAllCells' type='typedef'/>
     <exports symbol='virNodeInfo' type='typedef'/>
     <exports symbol='virNodeInfoPtr' type='typedef'/>
     <exports symbol='virNodeMemoryStats' type='typedef'/>
     <exports symbol='virNodeMemoryStatsPtr' type='typedef'/>
     <exports symbol='virNodeSuspendTarget' type='typedef'/>
     <exports symbol='virSecurityLabel' type='typedef'/>
     <exports symbol='virSecurityLabelPtr' type='typedef'/>
     <exports symbol='virSecurityModel' type='typedef'/>
     <exports symbol='virSecurityModelPtr' type='typedef'/>
     <exports symbol='virStream' type='typedef'/>
     <exports symbol='virStreamPtr' type='typedef'/>
     <exports symbol='_virConnectAuth' type='struct'/>
     <exports symbol='_virConnectCredential' type='struct'/>
     <exports symbol='_virNodeCPUStats' type='struct'/>
     <exports symbol='_virNodeInfo' type='struct'/>
     <exports symbol='_virNodeMemoryStats' type='struct'/>
     <exports symbol='_virSecurityLabel' type='struct'/>
     <exports symbol='_virSecurityModel' type='struct'/>
     <exports symbol='virConnectAuthPtrDefault' type='variable'/>
     <exports symbol='virConnectAuthCallbackPtr' type='function'/>
     <exports symbol='virConnectBaselineCPU' type='function'/>
     <exports symbol='virConnectBaselineHypervisorCPU' type='function'/>
     <exports symbol='virConnectClose' type='function'/>
     <exports symbol='virConnectCloseFunc' type='function'/>
     <exports symbol='virConnectCompareCPU' type='function'/>
     <exports symbol='virConnectCompareHypervisorCPU' type='function'/>
     <exports symbol='virConnectGetCPUModelNames' type='function'/>
     <exports symbol='virConnectGetCapabilities' type='function'/>
     <exports symbol='virConnectGetHostname' type='function'/>
     <exports symbol='virConnectGetLibVersion' type='function'/>
     <exports symbol='virConnectGetMaxVcpus' type='function'/>
     <exports symbol='virConnectGetSysinfo' type='function'/>
     <exports symbol='virConnectGetType' type='function'/>
     <exports symbol='virConnectGetURI' type='function'/>
     <exports symbol='virConnectGetVersion' type='function'/>
     <exports symbol='virConnectIsAlive' type='function'/>
     <exports symbol='virConnectIsEncrypted' type='function'/>
     <exports symbol='virConnectIsSecure' type='function'/>
     <exports symbol='virConnectOpen' type='function'/>
     <exports symbol='virConnectOpenAuth' type='function'/>
     <exports symbol='virConnectOpenReadOnly' type='function'/>
     <exports symbol='virConnectRef' type='function'/>
     <exports symbol='virConnectRegisterCloseCallback' type='function'/>
     <exports symbol='virConnectSetIdentity' type='function'/>
     <exports symbol='virConnectSetKeepAlive' type='function'/>
     <exports symbol='virConnectUnregisterCloseCallback' type='function'/>
     <exports symbol='virGetVersion' type='function'/>
     <exports symbol='virInitialize' type='function'/>
     <exports symbol='virNodeAllocPages' type='function'/>
     <exports symbol='virNodeGetCPUMap' type='function'/>
     <exports symbol='virNodeGetCPUStats' type='function'/>
     <exports symbol='virNodeGetCellsFreeMemory' type='function'/>
     <exports symbol='virNodeGetFreeMemory' type='function'/>
     <exports symbol='virNodeGetFreePages' type='function'/>
     <exports symbol='virNodeGetInfo' type='function'/>
     <exports symbol='virNodeGetMemoryParameters' type='function'/>
     <exports symbol='virNodeGetMemoryStats' type='function'/>
     <exports symbol='virNodeGetSEVInfo' type='function'/>
     <exports symbol='virNodeGetSecurityModel' type='function'/>
     <exports symbol='virNodeSetMemoryParameters' type='function'/>
     <exports symbol='virNodeSuspendForDuration' type='function'/>
    </file>
    <file name='libvirt-interface'>
     <summary>APIs for management of interfaces</summary>
     <description>Provides APIs for the management of interfaces  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_CONNECT_LIST_INTERFACES_ACTIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_INTERFACES_INACTIVE' type='enum'/>
     <exports symbol='VIR_INTERFACE_XML_INACTIVE' type='enum'/>
     <exports symbol='virConnectListAllInterfacesFlags' type='typedef'/>
     <exports symbol='virInterface' type='typedef'/>
     <exports symbol='virInterfacePtr' type='typedef'/>
     <exports symbol='virInterfaceXMLFlags' type='typedef'/>
     <exports symbol='virConnectListAllInterfaces' type='function'/>
     <exports symbol='virConnectListDefinedInterfaces' type='function'/>
     <exports symbol='virConnectListInterfaces' type='function'/>
     <exports symbol='virConnectNumOfDefinedInterfaces' type='function'/>
     <exports symbol='virConnectNumOfInterfaces' type='function'/>
     <exports symbol='virInterfaceChangeBegin' type='function'/>
     <exports symbol='virInterfaceChangeCommit' type='function'/>
     <exports symbol='virInterfaceChangeRollback' type='function'/>
     <exports symbol='virInterfaceCreate' type='function'/>
     <exports symbol='virInterfaceDefineXML' type='function'/>
     <exports symbol='virInterfaceDestroy' type='function'/>
     <exports symbol='virInterfaceFree' type='function'/>
     <exports symbol='virInterfaceGetConnect' type='function'/>
     <exports symbol='virInterfaceGetMACString' type='function'/>
     <exports symbol='virInterfaceGetName' type='function'/>
     <exports symbol='virInterfaceGetXMLDesc' type='function'/>
     <exports symbol='virInterfaceIsActive' type='function'/>
     <exports symbol='virInterfaceLookupByMACString' type='function'/>
     <exports symbol='virInterfaceLookupByName' type='function'/>
     <exports symbol='virInterfaceRef' type='function'/>
     <exports symbol='virInterfaceUndefine' type='function'/>
    </file>
    <file name='libvirt-network'>
     <summary>APIs for management of networks</summary>
     <description>Provides APIs for the management of networks  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_NETWORK_EVENT_CALLBACK' type='macro'/>
     <exports symbol='VIR_NETWORK_PORT_BANDWIDTH_IN_AVERAGE' type='macro'/>
     <exports symbol='VIR_NETWORK_PORT_BANDWIDTH_IN_BURST' type='macro'/>
     <exports symbol='VIR_NETWORK_PORT_BANDWIDTH_IN_FLOOR' type='macro'/>
     <exports symbol='VIR_NETWORK_PORT_BANDWIDTH_IN_PEAK' type='macro'/>
     <exports symbol='VIR_NETWORK_PORT_BANDWIDTH_OUT_AVERAGE' type='macro'/>
     <exports symbol='VIR_NETWORK_PORT_BANDWIDTH_OUT_BURST' type='macro'/>
     <exports symbol='VIR_NETWORK_PORT_BANDWIDTH_OUT_PEAK' type='macro'/>
     <exports symbol='VIR_CONNECT_LIST_NETWORKS_ACTIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NETWORKS_AUTOSTART' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NETWORKS_INACTIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NETWORKS_PERSISTENT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NETWORKS_TRANSIENT' type='enum'/>
     <exports symbol='VIR_IP_ADDR_TYPE_IPV4' type='enum'/>
     <exports symbol='VIR_IP_ADDR_TYPE_IPV6' type='enum'/>
     <exports symbol='VIR_IP_ADDR_TYPE_LAST' type='enum'/>
     <exports symbol='VIR_NETWORK_EVENT_DEFINED' type='enum'/>
     <exports symbol='VIR_NETWORK_EVENT_ID_LAST' type='enum'/>
     <exports symbol='VIR_NETWORK_EVENT_ID_LIFECYCLE' type='enum'/>
     <exports symbol='VIR_NETWORK_EVENT_LAST' type='enum'/>
     <exports symbol='VIR_NETWORK_EVENT_STARTED' type='enum'/>
     <exports symbol='VIR_NETWORK_EVENT_STOPPED' type='enum'/>
     <exports symbol='VIR_NETWORK_EVENT_UNDEFINED' type='enum'/>
     <exports symbol='VIR_NETWORK_PORT_CREATE_RECLAIM' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_BRIDGE' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_DNS_HOST' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_DNS_SRV' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_DNS_TXT' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_DOMAIN' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_FORWARD' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_FORWARD_INTERFACE' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_FORWARD_PF' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_IP' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_IP_DHCP_HOST' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_IP_DHCP_RANGE' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_LAST' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_NONE' type='enum'/>
     <exports symbol='VIR_NETWORK_SECTION_PORTGROUP' type='enum'/>
     <exports symbol='VIR_NETWORK_UPDATE_AFFECT_CONFIG' type='enum'/>
     <exports symbol='VIR_NETWORK_UPDATE_AFFECT_CURRENT' type='enum'/>
     <exports symbol='VIR_NETWORK_UPDATE_AFFECT_LIVE' type='enum'/>
     <exports symbol='VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST' type='enum'/>
     <exports symbol='VIR_NETWORK_UPDATE_COMMAND_ADD_LAST' type='enum'/>
     <exports symbol='VIR_NETWORK_UPDATE_COMMAND_DELETE' type='enum'/>
     <exports symbol='VIR_NETWORK_UPDATE_COMMAND_LAST' type='enum'/>
     <exports symbol='VIR_NETWORK_UPDATE_COMMAND_MODIFY' type='enum'/>
     <exports symbol='VIR_NETWORK_UPDATE_COMMAND_NONE' type='enum'/>
     <exports symbol='VIR_NETWORK_XML_INACTIVE' type='enum'/>
     <exports symbol='virConnectListAllNetworksFlags' type='typedef'/>
     <exports symbol='virIPAddrType' type='typedef'/>
     <exports symbol='virNetwork' type='typedef'/>
     <exports symbol='virNetworkDHCPLease' type='typedef'/>
     <exports symbol='virNetworkDHCPLeasePtr' type='typedef'/>
     <exports symbol='virNetworkEventID' type='typedef'/>
     <exports symbol='virNetworkEventLifecycleType' type='typedef'/>
     <exports symbol='virNetworkPort' type='typedef'/>
     <exports symbol='virNetworkPortCreateFlags' type='typedef'/>
     <exports symbol='virNetworkPortPtr' type='typedef'/>
     <exports symbol='virNetworkPtr' type='typedef'/>
     <exports symbol='virNetworkUpdateCommand' type='typedef'/>
     <exports symbol='virNetworkUpdateFlags' type='typedef'/>
     <exports symbol='virNetworkUpdateSection' type='typedef'/>
     <exports symbol='virNetworkXMLFlags' type='typedef'/>
     <exports symbol='_virNetworkDHCPLease' type='struct'/>
     <exports symbol='virConnectListAllNetworks' type='function'/>
     <exports symbol='virConnectListDefinedNetworks' type='function'/>
     <exports symbol='virConnectListNetworks' type='function'/>
     <exports symbol='virConnectNetworkEventDeregisterAny' type='function'/>
     <exports symbol='virConnectNetworkEventGenericCallback' type='function'/>
     <exports symbol='virConnectNetworkEventLifecycleCallback' type='function'/>
     <exports symbol='virConnectNetworkEventRegisterAny' type='function'/>
     <exports symbol='virConnectNumOfDefinedNetworks' type='function'/>
     <exports symbol='virConnectNumOfNetworks' type='function'/>
     <exports symbol='virNetworkCreate' type='function'/>
     <exports symbol='virNetworkCreateXML' type='function'/>
     <exports symbol='virNetworkDHCPLeaseFree' type='function'/>
     <exports symbol='virNetworkDefineXML' type='function'/>
     <exports symbol='virNetworkDestroy' type='function'/>
     <exports symbol='virNetworkFree' type='function'/>
     <exports symbol='virNetworkGetAutostart' type='function'/>
     <exports symbol='virNetworkGetBridgeName' type='function'/>
     <exports symbol='virNetworkGetConnect' type='function'/>
     <exports symbol='virNetworkGetDHCPLeases' type='function'/>
     <exports symbol='virNetworkGetName' type='function'/>
     <exports symbol='virNetworkGetUUID' type='function'/>
     <exports symbol='virNetworkGetUUIDString' type='function'/>
     <exports symbol='virNetworkGetXMLDesc' type='function'/>
     <exports symbol='virNetworkIsActive' type='function'/>
     <exports symbol='virNetworkIsPersistent' type='function'/>
     <exports symbol='virNetworkListAllPorts' type='function'/>
     <exports symbol='virNetworkLookupByName' type='function'/>
     <exports symbol='virNetworkLookupByUUID' type='function'/>
     <exports symbol='virNetworkLookupByUUIDString' type='function'/>
     <exports symbol='virNetworkPortCreateXML' type='function'/>
     <exports symbol='virNetworkPortDelete' type='function'/>
     <exports symbol='virNetworkPortFree' type='function'/>
     <exports symbol='virNetworkPortGetNetwork' type='function'/>
     <exports symbol='virNetworkPortGetParameters' type='function'/>
     <exports symbol='virNetworkPortGetUUID' type='function'/>
     <exports symbol='virNetworkPortGetUUIDString' type='function'/>
     <exports symbol='virNetworkPortGetXMLDesc' type='function'/>
     <exports symbol='virNetworkPortLookupByUUID' type='function'/>
     <exports symbol='virNetworkPortLookupByUUIDString' type='function'/>
     <exports symbol='virNetworkPortRef' type='function'/>
     <exports symbol='virNetworkPortSetParameters' type='function'/>
     <exports symbol='virNetworkRef' type='function'/>
     <exports symbol='virNetworkSetAutostart' type='function'/>
     <exports symbol='virNetworkUndefine' type='function'/>
     <exports symbol='virNetworkUpdate' type='function'/>
    </file>
    <file name='libvirt-nodedev'>
     <summary>APIs for management of nodedevs</summary>
     <description>Provides APIs for the management of nodedevs  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_NODE_DEVICE_EVENT_CALLBACK' type='macro'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_DRM' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV_TYPES' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS' type='enum'/>
     <exports symbol='VIR_NODE_DEVICE_EVENT_CREATED' type='enum'/>
     <exports symbol='VIR_NODE_DEVICE_EVENT_DELETED' type='enum'/>
     <exports symbol='VIR_NODE_DEVICE_EVENT_ID_LAST' type='enum'/>
     <exports symbol='VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE' type='enum'/>
     <exports symbol='VIR_NODE_DEVICE_EVENT_ID_UPDATE' type='enum'/>
     <exports symbol='VIR_NODE_DEVICE_EVENT_LAST' type='enum'/>
     <exports symbol='virConnectListAllNodeDeviceFlags' type='typedef'/>
     <exports symbol='virNodeDevice' type='typedef'/>
     <exports symbol='virNodeDeviceEventID' type='typedef'/>
     <exports symbol='virNodeDeviceEventLifecycleType' type='typedef'/>
     <exports symbol='virNodeDevicePtr' type='typedef'/>
     <exports symbol='virConnectListAllNodeDevices' type='function'/>
     <exports symbol='virConnectNodeDeviceEventDeregisterAny' type='function'/>
     <exports symbol='virConnectNodeDeviceEventGenericCallback' type='function'/>
     <exports symbol='virConnectNodeDeviceEventLifecycleCallback' type='function'/>
     <exports symbol='virConnectNodeDeviceEventRegisterAny' type='function'/>
     <exports symbol='virNodeDeviceCreateXML' type='function'/>
     <exports symbol='virNodeDeviceDestroy' type='function'/>
     <exports symbol='virNodeDeviceDetachFlags' type='function'/>
     <exports symbol='virNodeDeviceDettach' type='function'/>
     <exports symbol='virNodeDeviceFree' type='function'/>
     <exports symbol='virNodeDeviceGetName' type='function'/>
     <exports symbol='virNodeDeviceGetParent' type='function'/>
     <exports symbol='virNodeDeviceGetXMLDesc' type='function'/>
     <exports symbol='virNodeDeviceListCaps' type='function'/>
     <exports symbol='virNodeDeviceLookupByName' type='function'/>
     <exports symbol='virNodeDeviceLookupSCSIHostByWWN' type='function'/>
     <exports symbol='virNodeDeviceNumOfCaps' type='function'/>
     <exports symbol='virNodeDeviceReAttach' type='function'/>
     <exports symbol='virNodeDeviceRef' type='function'/>
     <exports symbol='virNodeDeviceReset' type='function'/>
     <exports symbol='virNodeListDevices' type='function'/>
     <exports symbol='virNodeNumOfDevices' type='function'/>
    </file>
    <file name='libvirt-nwfilter'>
     <summary>APIs for management of nwfilters</summary>
     <description>Provides APIs for the management of nwfilters  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='virNWFilter' type='typedef'/>
     <exports symbol='virNWFilterBinding' type='typedef'/>
     <exports symbol='virNWFilterBindingPtr' type='typedef'/>
     <exports symbol='virNWFilterPtr' type='typedef'/>
     <exports symbol='virConnectListAllNWFilterBindings' type='function'/>
     <exports symbol='virConnectListAllNWFilters' type='function'/>
     <exports symbol='virConnectListNWFilters' type='function'/>
     <exports symbol='virConnectNumOfNWFilters' type='function'/>
     <exports symbol='virNWFilterBindingCreateXML' type='function'/>
     <exports symbol='virNWFilterBindingDelete' type='function'/>
     <exports symbol='virNWFilterBindingFree' type='function'/>
     <exports symbol='virNWFilterBindingGetFilterName' type='function'/>
     <exports symbol='virNWFilterBindingGetPortDev' type='function'/>
     <exports symbol='virNWFilterBindingGetXMLDesc' type='function'/>
     <exports symbol='virNWFilterBindingLookupByPortDev' type='function'/>
     <exports symbol='virNWFilterBindingRef' type='function'/>
     <exports symbol='virNWFilterDefineXML' type='function'/>
     <exports symbol='virNWFilterFree' type='function'/>
     <exports symbol='virNWFilterGetName' type='function'/>
     <exports symbol='virNWFilterGetUUID' type='function'/>
     <exports symbol='virNWFilterGetUUIDString' type='function'/>
     <exports symbol='virNWFilterGetXMLDesc' type='function'/>
     <exports symbol='virNWFilterLookupByName' type='function'/>
     <exports symbol='virNWFilterLookupByUUID' type='function'/>
     <exports symbol='virNWFilterLookupByUUIDString' type='function'/>
     <exports symbol='virNWFilterRef' type='function'/>
     <exports symbol='virNWFilterUndefine' type='function'/>
    </file>
    <file name='libvirt-secret'>
     <summary>APIs for management of secrets</summary>
     <description>Provides APIs for the management of secrets  Copyright (C) 2006-2014, 2016 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_SECRET_EVENT_CALLBACK' type='macro'/>
     <exports symbol='VIR_CONNECT_LIST_SECRETS_EPHEMERAL' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_SECRETS_NO_PRIVATE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_SECRETS_PRIVATE' type='enum'/>
     <exports symbol='VIR_SECRET_EVENT_DEFINED' type='enum'/>
     <exports symbol='VIR_SECRET_EVENT_ID_LAST' type='enum'/>
     <exports symbol='VIR_SECRET_EVENT_ID_LIFECYCLE' type='enum'/>
     <exports symbol='VIR_SECRET_EVENT_ID_VALUE_CHANGED' type='enum'/>
     <exports symbol='VIR_SECRET_EVENT_LAST' type='enum'/>
     <exports symbol='VIR_SECRET_EVENT_UNDEFINED' type='enum'/>
     <exports symbol='VIR_SECRET_USAGE_TYPE_CEPH' type='enum'/>
     <exports symbol='VIR_SECRET_USAGE_TYPE_ISCSI' type='enum'/>
     <exports symbol='VIR_SECRET_USAGE_TYPE_LAST' type='enum'/>
     <exports symbol='VIR_SECRET_USAGE_TYPE_NONE' type='enum'/>
     <exports symbol='VIR_SECRET_USAGE_TYPE_TLS' type='enum'/>
     <exports symbol='VIR_SECRET_USAGE_TYPE_VOLUME' type='enum'/>
     <exports symbol='VIR_SECRET_USAGE_TYPE_VTPM' type='enum'/>
     <exports symbol='virConnectListAllSecretsFlags' type='typedef'/>
     <exports symbol='virSecret' type='typedef'/>
     <exports symbol='virSecretEventID' type='typedef'/>
     <exports symbol='virSecretEventLifecycleType' type='typedef'/>
     <exports symbol='virSecretPtr' type='typedef'/>
     <exports symbol='virSecretUsageType' type='typedef'/>
     <exports symbol='virConnectListAllSecrets' type='function'/>
     <exports symbol='virConnectListSecrets' type='function'/>
     <exports symbol='virConnectNumOfSecrets' type='function'/>
     <exports symbol='virConnectSecretEventDeregisterAny' type='function'/>
     <exports symbol='virConnectSecretEventGenericCallback' type='function'/>
     <exports symbol='virConnectSecretEventLifecycleCallback' type='function'/>
     <exports symbol='virConnectSecretEventRegisterAny' type='function'/>
     <exports symbol='virSecretDefineXML' type='function'/>
     <exports symbol='virSecretFree' type='function'/>
     <exports symbol='virSecretGetConnect' type='function'/>
     <exports symbol='virSecretGetUUID' type='function'/>
     <exports symbol='virSecretGetUUIDString' type='function'/>
     <exports symbol='virSecretGetUsageID' type='function'/>
     <exports symbol='virSecretGetUsageType' type='function'/>
     <exports symbol='virSecretGetValue' type='function'/>
     <exports symbol='virSecretGetXMLDesc' type='function'/>
     <exports symbol='virSecretLookupByUUID' type='function'/>
     <exports symbol='virSecretLookupByUUIDString' type='function'/>
     <exports symbol='virSecretLookupByUsage' type='function'/>
     <exports symbol='virSecretRef' type='function'/>
     <exports symbol='virSecretSetValue' type='function'/>
     <exports symbol='virSecretUndefine' type='function'/>
    </file>
    <file name='libvirt-storage'>
     <summary>APIs for management of storage pools and volumes</summary>
     <description>Provides APIs for the management of storage pools and volumes  Copyright (C) 2006-2016 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_STORAGE_POOL_EVENT_CALLBACK' type='macro'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_DIR' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_DISK' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_FS' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_GLUSTER' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI_DIRECT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_MPATH' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_NETFS' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_RBD' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_SCSI' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_VSTORAGE' type='enum'/>
     <exports symbol='VIR_CONNECT_LIST_STORAGE_POOLS_ZFS' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILDING' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_NEW' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_NO_OVERWRITE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_OVERWRITE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_REPAIR' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_RESIZE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_CREATE_NORMAL' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_CREATE_WITH_BUILD' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_CREATE_WITH_BUILD_NO_OVERWRITE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_CREATE_WITH_BUILD_OVERWRITE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_DEGRADED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_DELETE_NORMAL' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_DELETE_ZEROED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_CREATED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_DEFINED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_DELETED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_ID_LAST' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_ID_LIFECYCLE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_ID_REFRESH' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_LAST' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_STARTED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_STOPPED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_EVENT_UNDEFINED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_INACCESSIBLE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_INACTIVE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_RUNNING' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_STATE_LAST' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_BLOCK' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_CREATE_REFLINK' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_DELETE_NORMAL' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_DELETE_WITH_SNAPSHOTS' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_DELETE_ZEROED' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_DIR' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_FILE' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_GET_PHYSICAL' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_LAST' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_NETDIR' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_NETWORK' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_PLOOP' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_RESIZE_ALLOCATE' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_RESIZE_DELTA' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_RESIZE_SHRINK' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_USE_ALLOCATION' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_BSI' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_DOD' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_GUTMANN' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_LAST' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_NNSA' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_RANDOM' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_TRIM' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_WIPE_ALG_ZERO' type='enum'/>
     <exports symbol='VIR_STORAGE_XML_INACTIVE' type='enum'/>
     <exports symbol='virConnectListAllStoragePoolsFlags' type='typedef'/>
     <exports symbol='virStoragePool' type='typedef'/>
     <exports symbol='virStoragePoolBuildFlags' type='typedef'/>
     <exports symbol='virStoragePoolCreateFlags' type='typedef'/>
     <exports symbol='virStoragePoolDeleteFlags' type='typedef'/>
     <exports symbol='virStoragePoolEventID' type='typedef'/>
     <exports symbol='virStoragePoolEventLifecycleType' type='typedef'/>
     <exports symbol='virStoragePoolInfo' type='typedef'/>
     <exports symbol='virStoragePoolInfoPtr' type='typedef'/>
     <exports symbol='virStoragePoolPtr' type='typedef'/>
     <exports symbol='virStoragePoolState' type='typedef'/>
     <exports symbol='virStorageVol' type='typedef'/>
     <exports symbol='virStorageVolCreateFlags' type='typedef'/>
     <exports symbol='virStorageVolDeleteFlags' type='typedef'/>
     <exports symbol='virStorageVolDownloadFlags' type='typedef'/>
     <exports symbol='virStorageVolInfo' type='typedef'/>
     <exports symbol='virStorageVolInfoFlags' type='typedef'/>
     <exports symbol='virStorageVolInfoPtr' type='typedef'/>
     <exports symbol='virStorageVolPtr' type='typedef'/>
     <exports symbol='virStorageVolResizeFlags' type='typedef'/>
     <exports symbol='virStorageVolType' type='typedef'/>
     <exports symbol='virStorageVolUploadFlags' type='typedef'/>
     <exports symbol='virStorageVolWipeAlgorithm' type='typedef'/>
     <exports symbol='virStorageXMLFlags' type='typedef'/>
     <exports symbol='_virStoragePoolInfo' type='struct'/>
     <exports symbol='_virStorageVolInfo' type='struct'/>
     <exports symbol='virConnectFindStoragePoolSources' type='function'/>
     <exports symbol='virConnectGetStoragePoolCapabilities' type='function'/>
     <exports symbol='virConnectListAllStoragePools' type='function'/>
     <exports symbol='virConnectListDefinedStoragePools' type='function'/>
     <exports symbol='virConnectListStoragePools' type='function'/>
     <exports symbol='virConnectNumOfDefinedStoragePools' type='function'/>
     <exports symbol='virConnectNumOfStoragePools' type='function'/>
     <exports symbol='virConnectStoragePoolEventDeregisterAny' type='function'/>
     <exports symbol='virConnectStoragePoolEventGenericCallback' type='function'/>
     <exports symbol='virConnectStoragePoolEventLifecycleCallback' type='function'/>
     <exports symbol='virConnectStoragePoolEventRegisterAny' type='function'/>
     <exports symbol='virStoragePoolBuild' type='function'/>
     <exports symbol='virStoragePoolCreate' type='function'/>
     <exports symbol='virStoragePoolCreateXML' type='function'/>
     <exports symbol='virStoragePoolDefineXML' type='function'/>
     <exports symbol='virStoragePoolDelete' type='function'/>
     <exports symbol='virStoragePoolDestroy' type='function'/>
     <exports symbol='virStoragePoolFree' type='function'/>
     <exports symbol='virStoragePoolGetAutostart' type='function'/>
     <exports symbol='virStoragePoolGetConnect' type='function'/>
     <exports symbol='virStoragePoolGetInfo' type='function'/>
     <exports symbol='virStoragePoolGetName' type='function'/>
     <exports symbol='virStoragePoolGetUUID' type='function'/>
     <exports symbol='virStoragePoolGetUUIDString' type='function'/>
     <exports symbol='virStoragePoolGetXMLDesc' type='function'/>
     <exports symbol='virStoragePoolIsActive' type='function'/>
     <exports symbol='virStoragePoolIsPersistent' type='function'/>
     <exports symbol='virStoragePoolListAllVolumes' type='function'/>
     <exports symbol='virStoragePoolListVolumes' type='function'/>
     <exports symbol='virStoragePoolLookupByName' type='function'/>
     <exports symbol='virStoragePoolLookupByTargetPath' type='function'/>
     <exports symbol='virStoragePoolLookupByUUID' type='function'/>
     <exports symbol='virStoragePoolLookupByUUIDString' type='function'/>
     <exports symbol='virStoragePoolLookupByVolume' type='function'/>
     <exports symbol='virStoragePoolNumOfVolumes' type='function'/>
     <exports symbol='virStoragePoolRef' type='function'/>
     <exports symbol='virStoragePoolRefresh' type='function'/>
     <exports symbol='virStoragePoolSetAutostart' type='function'/>
     <exports symbol='virStoragePoolUndefine' type='function'/>
     <exports symbol='virStorageVolCreateXML' type='function'/>
     <exports symbol='virStorageVolCreateXMLFrom' type='function'/>
     <exports symbol='virStorageVolDelete' type='function'/>
     <exports symbol='virStorageVolDownload' type='function'/>
     <exports symbol='virStorageVolFree' type='function'/>
     <exports symbol='virStorageVolGetConnect' type='function'/>
     <exports symbol='virStorageVolGetInfo' type='function'/>
     <exports symbol='virStorageVolGetInfoFlags' type='function'/>
     <exports symbol='virStorageVolGetKey' type='function'/>
     <exports symbol='virStorageVolGetName' type='function'/>
     <exports symbol='virStorageVolGetPath' type='function'/>
     <exports symbol='virStorageVolGetXMLDesc' type='function'/>
     <exports symbol='virStorageVolLookupByKey' type='function'/>
     <exports symbol='virStorageVolLookupByName' type='function'/>
     <exports symbol='virStorageVolLookupByPath' type='function'/>
     <exports symbol='virStorageVolRef' type='function'/>
     <exports symbol='virStorageVolResize' type='function'/>
     <exports symbol='virStorageVolUpload' type='function'/>
     <exports symbol='virStorageVolWipe' type='function'/>
     <exports symbol='virStorageVolWipePattern' type='function'/>
    </file>
    <file name='libvirt-stream'>
     <summary>APIs for management of streams</summary>
     <description>Provides APIs for the management of streams  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_STREAM_EVENT_ERROR' type='enum'/>
     <exports symbol='VIR_STREAM_EVENT_HANGUP' type='enum'/>
     <exports symbol='VIR_STREAM_EVENT_READABLE' type='enum'/>
     <exports symbol='VIR_STREAM_EVENT_WRITABLE' type='enum'/>
     <exports symbol='VIR_STREAM_NONBLOCK' type='enum'/>
     <exports symbol='VIR_STREAM_RECV_STOP_AT_HOLE' type='enum'/>
     <exports symbol='virStreamEventType' type='typedef'/>
     <exports symbol='virStreamFlags' type='typedef'/>
     <exports symbol='virStreamRecvFlagsValues' type='typedef'/>
     <exports symbol='virStreamAbort' type='function'/>
     <exports symbol='virStreamEventAddCallback' type='function'/>
     <exports symbol='virStreamEventCallback' type='function'/>
     <exports symbol='virStreamEventRemoveCallback' type='function'/>
     <exports symbol='virStreamEventUpdateCallback' type='function'/>
     <exports symbol='virStreamFinish' type='function'/>
     <exports symbol='virStreamFree' type='function'/>
     <exports symbol='virStreamNew' type='function'/>
     <exports symbol='virStreamRecv' type='function'/>
     <exports symbol='virStreamRecvAll' type='function'/>
     <exports symbol='virStreamRecvFlags' type='function'/>
     <exports symbol='virStreamRecvHole' type='function'/>
     <exports symbol='virStreamRef' type='function'/>
     <exports symbol='virStreamSend' type='function'/>
     <exports symbol='virStreamSendAll' type='function'/>
     <exports symbol='virStreamSendHole' type='function'/>
     <exports symbol='virStreamSinkFunc' type='function'/>
     <exports symbol='virStreamSinkHoleFunc' type='function'/>
     <exports symbol='virStreamSourceFunc' type='function'/>
     <exports symbol='virStreamSourceHoleFunc' type='function'/>
     <exports symbol='virStreamSourceSkipFunc' type='function'/>
     <exports symbol='virStreamSparseRecvAll' type='function'/>
     <exports symbol='virStreamSparseSendAll' type='function'/>
    </file>
    <file name='virterror'>
     <summary>error handling interfaces for the libvirt library</summary>
     <description>Provides the interfaces of the libvirt library to handle errors raised while using the library.  Copyright (C) 2006-2019 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </description>
     <exports symbol='VIR_ERR_ACCESS_DENIED' type='enum'/>
     <exports symbol='VIR_ERR_AGENT_UNRESPONSIVE' type='enum'/>
     <exports symbol='VIR_ERR_AGENT_UNSYNCED' type='enum'/>
     <exports symbol='VIR_ERR_ARGUMENT_UNSUPPORTED' type='enum'/>
     <exports symbol='VIR_ERR_AUTH_CANCELLED' type='enum'/>
     <exports symbol='VIR_ERR_AUTH_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_AUTH_UNAVAILABLE' type='enum'/>
     <exports symbol='VIR_ERR_BLOCK_COPY_ACTIVE' type='enum'/>
     <exports symbol='VIR_ERR_BUILD_FIREWALL' type='enum'/>
     <exports symbol='VIR_ERR_CALL_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_CONFIG_UNSUPPORTED' type='enum'/>
     <exports symbol='VIR_ERR_CONF_SYNTAX' type='enum'/>
     <exports symbol='VIR_ERR_CPU_INCOMPATIBLE' type='enum'/>
     <exports symbol='VIR_ERR_DBUS_SERVICE' type='enum'/>
     <exports symbol='VIR_ERR_DEVICE_MISSING' type='enum'/>
     <exports symbol='VIR_ERR_DOMAIN_LAST' type='enum'/>
     <exports symbol='VIR_ERR_DOM_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_DRIVER_FULL' type='enum'/>
     <exports symbol='VIR_ERR_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_GET_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_GNUTLS_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_HOOK_SCRIPT_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_HTTP_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_INTERNAL_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_ARG' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_CONN' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_DOMAIN' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_DOMAIN_CHECKPOINT' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_DOMAIN_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_INTERFACE' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_MAC' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NETWORK_PORT' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NODE_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NWFILTER' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NWFILTER_BINDING' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_SECRET' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_STORAGE_POOL' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_STORAGE_VOL' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_STREAM' type='enum'/>
     <exports symbol='VIR_ERR_LIBSSH' type='enum'/>
     <exports symbol='VIR_ERR_MIGRATE_FINISH_OK' type='enum'/>
     <exports symbol='VIR_ERR_MIGRATE_PERSIST_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_MIGRATE_UNSAFE' type='enum'/>
     <exports symbol='VIR_ERR_MULTIPLE_INTERFACES' type='enum'/>
     <exports symbol='VIR_ERR_NETWORK_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_NETWORK_PORT_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_NONE' type='enum'/>
     <exports symbol='VIR_ERR_NO_CLIENT' type='enum'/>
     <exports symbol='VIR_ERR_NO_CONNECT' type='enum'/>
     <exports symbol='VIR_ERR_NO_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_NO_DOMAIN' type='enum'/>
     <exports symbol='VIR_ERR_NO_DOMAIN_BACKUP' type='enum'/>
     <exports symbol='VIR_ERR_NO_DOMAIN_CHECKPOINT' type='enum'/>
     <exports symbol='VIR_ERR_NO_DOMAIN_METADATA' type='enum'/>
     <exports symbol='VIR_ERR_NO_DOMAIN_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_ERR_NO_HOSTNAME' type='enum'/>
     <exports symbol='VIR_ERR_NO_INTERFACE' type='enum'/>
     <exports symbol='VIR_ERR_NO_KERNEL' type='enum'/>
     <exports symbol='VIR_ERR_NO_MEMORY' type='enum'/>
     <exports symbol='VIR_ERR_NO_NAME' type='enum'/>
     <exports symbol='VIR_ERR_NO_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_NO_NETWORK_PORT' type='enum'/>
     <exports symbol='VIR_ERR_NO_NODE_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_NO_NWFILTER' type='enum'/>
     <exports symbol='VIR_ERR_NO_NWFILTER_BINDING' type='enum'/>
     <exports symbol='VIR_ERR_NO_OS' type='enum'/>
     <exports symbol='VIR_ERR_NO_ROOT' type='enum'/>
     <exports symbol='VIR_ERR_NO_SECRET' type='enum'/>
     <exports symbol='VIR_ERR_NO_SECURITY_MODEL' type='enum'/>
     <exports symbol='VIR_ERR_NO_SERVER' type='enum'/>
     <exports symbol='VIR_ERR_NO_SOURCE' type='enum'/>
     <exports symbol='VIR_ERR_NO_STORAGE_POOL' type='enum'/>
     <exports symbol='VIR_ERR_NO_STORAGE_VOL' type='enum'/>
     <exports symbol='VIR_ERR_NO_SUPPORT' type='enum'/>
     <exports symbol='VIR_ERR_NO_TARGET' type='enum'/>
     <exports symbol='VIR_ERR_NO_XEN' type='enum'/>
     <exports symbol='VIR_ERR_NO_XENSTORE' type='enum'/>
     <exports symbol='VIR_ERR_NUMBER_LAST' type='enum'/>
     <exports symbol='VIR_ERR_OK' type='enum'/>
     <exports symbol='VIR_ERR_OPEN_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_ABORTED' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_DENIED' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_INVALID' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_TIMEOUT' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_UNSUPPORTED' type='enum'/>
     <exports symbol='VIR_ERR_OS_TYPE' type='enum'/>
     <exports symbol='VIR_ERR_OVERFLOW' type='enum'/>
     <exports symbol='VIR_ERR_PARSE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_POST_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_READ_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_RESOURCE_BUSY' type='enum'/>
     <exports symbol='VIR_ERR_RPC' type='enum'/>
     <exports symbol='VIR_ERR_SEXPR_SERIAL' type='enum'/>
     <exports symbol='VIR_ERR_SNAPSHOT_REVERT_RISKY' type='enum'/>
     <exports symbol='VIR_ERR_SSH' type='enum'/>
     <exports symbol='VIR_ERR_STORAGE_POOL_BUILT' type='enum'/>
     <exports symbol='VIR_ERR_STORAGE_PROBE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_STORAGE_VOL_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_SYSTEM_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_UNKNOWN_HOST' type='enum'/>
     <exports symbol='VIR_ERR_WARNING' type='enum'/>
     <exports symbol='VIR_ERR_WRITE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_XEN_CALL' type='enum'/>
     <exports symbol='VIR_ERR_XML_DETAIL' type='enum'/>
     <exports symbol='VIR_ERR_XML_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_XML_INVALID_SCHEMA' type='enum'/>
     <exports symbol='VIR_FROM_ACCESS' type='enum'/>
     <exports symbol='VIR_FROM_ADMIN' type='enum'/>
     <exports symbol='VIR_FROM_AUDIT' type='enum'/>
     <exports symbol='VIR_FROM_AUTH' type='enum'/>
     <exports symbol='VIR_FROM_BHYVE' type='enum'/>
     <exports symbol='VIR_FROM_BPF' type='enum'/>
     <exports symbol='VIR_FROM_CAPABILITIES' type='enum'/>
     <exports symbol='VIR_FROM_CGROUP' type='enum'/>
     <exports symbol='VIR_FROM_CONF' type='enum'/>
     <exports symbol='VIR_FROM_CPU' type='enum'/>
     <exports symbol='VIR_FROM_CRYPTO' type='enum'/>
     <exports symbol='VIR_FROM_DBUS' type='enum'/>
     <exports symbol='VIR_FROM_DEVICE' type='enum'/>
     <exports symbol='VIR_FROM_DOM' type='enum'/>
     <exports symbol='VIR_FROM_DOMAIN' type='enum'/>
     <exports symbol='VIR_FROM_DOMAIN_CHECKPOINT' type='enum'/>
     <exports symbol='VIR_FROM_DOMAIN_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_FROM_ESX' type='enum'/>
     <exports symbol='VIR_FROM_EVENT' type='enum'/>
     <exports symbol='VIR_FROM_FIREWALL' type='enum'/>
     <exports symbol='VIR_FROM_FIREWALLD' type='enum'/>
     <exports symbol='VIR_FROM_HOOK' type='enum'/>
     <exports symbol='VIR_FROM_HYPERV' type='enum'/>
     <exports symbol='VIR_FROM_IDENTITY' type='enum'/>
     <exports symbol='VIR_FROM_INITCTL' type='enum'/>
     <exports symbol='VIR_FROM_INTERFACE' type='enum'/>
     <exports symbol='VIR_FROM_LIBSSH' type='enum'/>
     <exports symbol='VIR_FROM_LIBXL' type='enum'/>
     <exports symbol='VIR_FROM_LOCKING' type='enum'/>
     <exports symbol='VIR_FROM_LOCKSPACE' type='enum'/>
     <exports symbol='VIR_FROM_LOGGING' type='enum'/>
     <exports symbol='VIR_FROM_LXC' type='enum'/>
     <exports symbol='VIR_FROM_NET' type='enum'/>
     <exports symbol='VIR_FROM_NETWORK' type='enum'/>
     <exports symbol='VIR_FROM_NODEDEV' type='enum'/>
     <exports symbol='VIR_FROM_NONE' type='enum'/>
     <exports symbol='VIR_FROM_NWFILTER' type='enum'/>
     <exports symbol='VIR_FROM_ONE' type='enum'/>
     <exports symbol='VIR_FROM_OPENVZ' type='enum'/>
     <exports symbol='VIR_FROM_PARALLELS' type='enum'/>
     <exports symbol='VIR_FROM_PERF' type='enum'/>
     <exports symbol='VIR_FROM_PHYP' type='enum'/>
     <exports symbol='VIR_FROM_POLKIT' type='enum'/>
     <exports symbol='VIR_FROM_PROXY' type='enum'/>
     <exports symbol='VIR_FROM_QEMU' type='enum'/>
     <exports symbol='VIR_FROM_REMOTE' type='enum'/>
     <exports symbol='VIR_FROM_RESCTRL' type='enum'/>
     <exports symbol='VIR_FROM_RPC' type='enum'/>
     <exports symbol='VIR_FROM_SECRET' type='enum'/>
     <exports symbol='VIR_FROM_SECURITY' type='enum'/>
     <exports symbol='VIR_FROM_SEXPR' type='enum'/>
     <exports symbol='VIR_FROM_SSH' type='enum'/>
     <exports symbol='VIR_FROM_STATS_LINUX' type='enum'/>
     <exports symbol='VIR_FROM_STORAGE' type='enum'/>
     <exports symbol='VIR_FROM_STREAMS' type='enum'/>
     <exports symbol='VIR_FROM_SYSINFO' type='enum'/>
     <exports symbol='VIR_FROM_SYSTEMD' type='enum'/>
     <exports symbol='VIR_FROM_TEST' type='enum'/>
     <exports symbol='VIR_FROM_THREAD' type='enum'/>
     <exports symbol='VIR_FROM_TPM' type='enum'/>
     <exports symbol='VIR_FROM_UML' type='enum'/>
     <exports symbol='VIR_FROM_URI' type='enum'/>
     <exports symbol='VIR_FROM_VBOX' type='enum'/>
     <exports symbol='VIR_FROM_VMWARE' type='enum'/>
     <exports symbol='VIR_FROM_XEN' type='enum'/>
     <exports symbol='VIR_FROM_XENAPI' type='enum'/>
     <exports symbol='VIR_FROM_XEND' type='enum'/>
     <exports symbol='VIR_FROM_XENSTORE' type='enum'/>
     <exports symbol='VIR_FROM_XENXL' type='enum'/>
     <exports symbol='VIR_FROM_XENXM' type='enum'/>
     <exports symbol='VIR_FROM_XEN_INOTIFY' type='enum'/>
     <exports symbol='VIR_FROM_XML' type='enum'/>
     <exports symbol='VIR_WAR_NO_INTERFACE' type='enum'/>
     <exports symbol='VIR_WAR_NO_NETWORK' type='enum'/>
     <exports symbol='VIR_WAR_NO_NODE' type='enum'/>
     <exports symbol='VIR_WAR_NO_NWFILTER' type='enum'/>
     <exports symbol='VIR_WAR_NO_SECRET' type='enum'/>
     <exports symbol='VIR_WAR_NO_STORAGE' type='enum'/>
     <exports symbol='virError' type='typedef'/>
     <exports symbol='virErrorDomain' type='typedef'/>
     <exports symbol='virErrorLevel' type='typedef'/>
     <exports symbol='virErrorNumber' type='typedef'/>
     <exports symbol='virErrorPtr' type='typedef'/>
     <exports symbol='_virError' type='struct'/>
     <exports symbol='virConnCopyLastError' type='function'/>
     <exports symbol='virConnGetLastError' type='function'/>
     <exports symbol='virConnResetLastError' type='function'/>
     <exports symbol='virConnSetErrorFunc' type='function'/>
     <exports symbol='virCopyLastError' type='function'/>
     <exports symbol='virDefaultErrorFunc' type='function'/>
     <exports symbol='virErrorFunc' type='function'/>
     <exports symbol='virFreeError' type='function'/>
     <exports symbol='virGetLastError' type='function'/>
     <exports symbol='virGetLastErrorCode' type='function'/>
     <exports symbol='virGetLastErrorDomain' type='function'/>
     <exports symbol='virGetLastErrorMessage' type='function'/>
     <exports symbol='virResetError' type='function'/>
     <exports symbol='virResetLastError' type='function'/>
     <exports symbol='virSaveLastError' type='function'/>
     <exports symbol='virSetErrorFunc' type='function'/>
    </file>
  </files>
  <symbols>
    <macro name='LIBVIR_CHECK_VERSION' file='libvirt-common' params='major,minor,micro' raw='((major) * 1000000 + (minor) * 1000 + (micro) &lt;= LIBVIR_VERSION_NUMBER)'>
      <info><![CDATA[Macro for developers to easily check what version of the library their code is compiling against. e.g. #if LIBVIR_CHECK_VERSION(1,1,3) // some code that only works in 1.1.3 and newer #endif]]></info>
      <arg name='major' info='major component of the version number'/>
      <arg name='minor' info='minor component of the version number'/>
      <arg name='micro' info='micro component of the version number'/>
    </macro>
    <macro name='LIBVIR_VERSION_NUMBER' file='libvirt-common' raw='6006000'>
      <info><![CDATA[Macro providing the version of the library as version * 1,000,000 + minor * 1000 + micro]]></info>
    </macro>
    <macro name='VIR_CONNECT_IDENTITY_GROUP_NAME' file='libvirt-host' string='group-name'>
      <info><![CDATA[The operating system group name as VIR_TYPED_PARAM_STRING.]]></info>
    </macro>
    <macro name='VIR_CONNECT_IDENTITY_PROCESS_ID' file='libvirt-host' string='process-id'>
      <info><![CDATA[The operating system process ID as VIR_TYPED_PARAM_LLONG.]]></info>
    </macro>
    <macro name='VIR_CONNECT_IDENTITY_PROCESS_TIME' file='libvirt-host' string='process-time'>
      <info><![CDATA[The operating system process start time as VIR_TYPED_PARAM_ULLONG.  The units the time is measured in vary according to the host operating system. On Linux this is usually clock ticks (as reported in /proc/$PID/stat field 22).]]></info>
    </macro>
    <macro name='VIR_CONNECT_IDENTITY_SASL_USER_NAME' file='libvirt-host' string='sasl-user-name'>
      <info><![CDATA[The SASL authenticated username as VIR_TYPED_PARAM_STRING]]></info>
    </macro>
    <macro name='VIR_CONNECT_IDENTITY_SELINUX_CONTEXT' file='libvirt-host' string='selinux-context'>
      <info><![CDATA[The application's SELinux context as VIR_TYPED_PARAM_STRING.]]></info>
    </macro>
    <macro name='VIR_CONNECT_IDENTITY_UNIX_GROUP_ID' file='libvirt-host' string='unix-group-id'>
      <info><![CDATA[The UNIX group ID as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_CONNECT_IDENTITY_UNIX_USER_ID' file='libvirt-host' string='unix-user-id'>
      <info><![CDATA[The UNIX user ID as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_CONNECT_IDENTITY_USER_NAME' file='libvirt-host' string='user-name'>
      <info><![CDATA[The operating system user name as VIR_TYPED_PARAM_STRING.]]></info>
    </macro>
    <macro name='VIR_CONNECT_IDENTITY_X509_DISTINGUISHED_NAME' file='libvirt-host' string='x509-distinguished-name'>
      <info><![CDATA[The TLS x509 certificate distinguished named as VIR_TYPED_PARAM_STRING]]></info>
    </macro>
    <macro name='VIR_COPY_CPUMAP' file='libvirt-domain' params='cpumaps,maplen,vcpu,cpumap' raw='memcpy(cpumap, VIR_GET_CPUMAP(cpumaps, maplen, vcpu), maplen)'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_COPY_CPUMAP macro extracts the cpumap of the specified vcpu from cpumaps array and copies it into cpumap to be used later by virDomainPinVcpu() API.]]></info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpumap' info='pointer to a cpumap (in 8-bit bytes) (OUT) This cpumap must be previously allocated by the caller (ie: malloc(maplen))'/>
    </macro>
    <macro name='VIR_CPU_MAPLEN' file='libvirt-domain' params='cpu' raw=''>
      <info><![CDATA[This macro is to be used in conjunction with virDomainPinVcpu() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual & all physical CPUs of a domain.]]></info>
      <arg name='cpu' info='number of physical CPUs'/>
    </macro>
    <macro name='VIR_CPU_USABLE' file='libvirt-domain' params='cpumaps,maplen,vcpu,cpu' raw='VIR_CPU_USED(VIR_GET_CPUMAP(cpumaps, maplen, vcpu), cpu)'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainGetVcpus() API. VIR_CPU_USABLE macro returns a non-zero value (true) if the cpu is usable by the vcpu, and 0 otherwise.]]></info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_CPU_USED' file='libvirt-domain' params='cpumap,cpu' raw='((cpumap)[(cpu) / 8] &amp; (1 &lt;&lt; ((cpu) % 8)))'>
      <info><![CDATA[This macro can be used in conjunction with virNodeGetCPUMap() API. It returns non-zero if the bit of the related CPU is set.]]></info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_DOMAIN_BANDWIDTH_IN_AVERAGE' file='libvirt-domain' string='inbound.average'>
      <info><![CDATA[Macro represents the inbound average of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BANDWIDTH_IN_BURST' file='libvirt-domain' string='inbound.burst'>
      <info><![CDATA[Macro represents the inbound burst of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BANDWIDTH_IN_FLOOR' file='libvirt-domain' string='inbound.floor'>
      <info><![CDATA[Macro represents the inbound floor of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BANDWIDTH_IN_PEAK' file='libvirt-domain' string='inbound.peak'>
      <info><![CDATA[Macro represents the inbound peak of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE' file='libvirt-domain' string='outbound.average'>
      <info><![CDATA[Macro represents the outbound average of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BANDWIDTH_OUT_BURST' file='libvirt-domain' string='outbound.burst'>
      <info><![CDATA[Macro represents the outbound burst of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BANDWIDTH_OUT_PEAK' file='libvirt-domain' string='outbound.peak'>
      <info><![CDATA[Macro represents the outbound peak of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLKIO_DEVICE_READ_BPS' file='libvirt-domain' string='device_read_bytes_sec'>
      <info><![CDATA[Macro for the blkio tunable throttle.read_iops_device: it represents the bytes of reading the block device per second, as a string. The string is parsed as a series of /path/to/device, read_bps elements, separated by ','.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS' file='libvirt-domain' string='device_read_iops_sec'>
      <info><![CDATA[Macro for the blkio tunable throttle.read_iops_device: it represents the number of reading the block device per second, as a string. The string is parsed as a series of /path/to/device, read_iops elements, separated by ','.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLKIO_DEVICE_WEIGHT' file='libvirt-domain' string='device_weight'>
      <info><![CDATA[Macro for the blkio tunable weight_device: it represents the per-device weight, as a string.  The string is parsed as a series of /path/to/device,weight elements, separated by ','.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS' file='libvirt-domain' string='device_write_bytes_sec'>
      <info><![CDATA[Macro for the blkio tunable throttle.read_iops_device: it represents the number of reading the block device per second, as a string. The string is parsed as a series of /path/to/device, write_bps elements, separated by ','.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS' file='libvirt-domain' string='device_write_iops_sec'>
      <info><![CDATA[Macro for the blkio tunable throttle.write_iops_device: it represents the number of writing the block device per second, as a string. The string is parsed as a series of /path/to/device, write_iops elements, separated by ','.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLKIO_FIELD_LENGTH' file='libvirt-domain' raw='VIR_TYPED_PARAM_FIELD_LENGTH'>
      <info><![CDATA[Macro providing the field length of virBlkioParameter.  Provided for backwards compatibility; VIR_TYPED_PARAM_FIELD_LENGTH is the preferred value since 0.9.2.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLKIO_WEIGHT' file='libvirt-domain' string='weight'>
      <info><![CDATA[Macro for the Blkio tunable weight: it represents the io weight the guest can use, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_COPY_BANDWIDTH' file='libvirt-domain' string='bandwidth'>
      <info><![CDATA[Macro for the virDomainBlockCopy bandwidth tunable: it represents the maximum bandwidth in bytes/s, and is used while getting the copy operation into the mirrored phase, with a type of ullong.  For compatibility with virDomainBlockJobSetSpeed(), values larger than 2^52 bytes/sec (a 32-bit MiB/s value) may be rejected on input due to overflow considerations (but do you really have an interface with that much bandwidth?), and values larger than 2^31 bytes/sec may cause overflow problems if queried in bytes/sec.  Hypervisors may further restrict the set of valid values. Specifying 0 is the same as omitting this parameter, to request no bandwidth limiting. Some hypervisors may lack support for this parameter, while still allowing a subsequent change of bandwidth via virDomainBlockJobSetSpeed().  The actual speed can be determined with virDomainGetBlockJobInfo().]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_COPY_BUF_SIZE' file='libvirt-domain' string='buf-size'>
      <info><![CDATA[Macro for the virDomainBlockCopy buffer size tunable: it represents how much data in bytes can be in flight between source and destination, as an unsigned long long. Specifying 0 is the same as omitting this parameter, to request the hypervisor default.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_COPY_GRANULARITY' file='libvirt-domain' string='granularity'>
      <info><![CDATA[Macro for the virDomainBlockCopy granularity tunable: it represents the granularity in bytes at which the copy operation recognizes dirty blocks that need copying, as an unsigned int.  Hypervisors may restrict this to be a power of two or fall within a certain range. Specifying 0 is the same as omitting this parameter, to request the hypervisor default.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME' file='libvirt-domain' string='group_name'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents a group name to allow sharing of I/O throttling quota between multiple drives, as a string.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC' file='libvirt-domain' string='read_bytes_sec'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the read bytes per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX' file='libvirt-domain' string='read_bytes_sec_max'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the maximum read bytes per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH' file='libvirt-domain' string='read_bytes_sec_max_length'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by read_bytes_sec_max, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC' file='libvirt-domain' string='read_iops_sec'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the read I/O operations per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX' file='libvirt-domain' string='read_iops_sec_max'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the maximum read I/O operations per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH' file='libvirt-domain' string='read_iops_sec_max_length'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by read_iops_sec_max, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC' file='libvirt-domain' string='size_iops_sec'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the size I/O operations per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC' file='libvirt-domain' string='total_bytes_sec'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the total bytes per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX' file='libvirt-domain' string='total_bytes_sec_max'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the maximum total bytes per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH' file='libvirt-domain' string='total_bytes_sec_max_length'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by total_bytes_sec_max, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC' file='libvirt-domain' string='total_iops_sec'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the total I/O operations per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX' file='libvirt-domain' string='total_iops_sec_max'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the maximum I/O operations per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH' file='libvirt-domain' string='total_iops_sec_max_length'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by total_iops_sec_max, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC' file='libvirt-domain' string='write_bytes_sec'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the write bytes per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX' file='libvirt-domain' string='write_bytes_sec_max'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the maximum write bytes per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH' file='libvirt-domain' string='write_bytes_sec_max_length'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by write_bytes_sec_max, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC' file='libvirt-domain' string='write_iops_sec'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the write I/O operations per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX' file='libvirt-domain' string='write_iops_sec_max'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the maximum write I/O operations per second permitted through a block device, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH' file='libvirt-domain' string='write_iops_sec_max_length'>
      <info><![CDATA[Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by write_iops_sec_max, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_ERRS' file='libvirt-domain' string='errs'>
      <info><![CDATA[In Xen this returns the mysterious 'oo_req', as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH' file='libvirt-domain' raw='VIR_TYPED_PARAM_FIELD_LENGTH'>
      <info><![CDATA[Macro providing the field length of parameter names when using virDomainBlockStatsFlags().]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ' file='libvirt-domain' string='flush_operations'>
      <info><![CDATA[Macro represents the total flush requests of the block device, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES' file='libvirt-domain' string='flush_total_times'>
      <info><![CDATA[Macro represents the total time spend on cache flushing in nano-seconds of the block device, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_READ_BYTES' file='libvirt-domain' string='rd_bytes'>
      <info><![CDATA[Macro represents the total number of read bytes of the block device, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_READ_REQ' file='libvirt-domain' string='rd_operations'>
      <info><![CDATA[Macro represents the total read requests of the block device, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES' file='libvirt-domain' string='rd_total_times'>
      <info><![CDATA[Macro represents the total time spend on cache reads in nano-seconds of the block device, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES' file='libvirt-domain' string='wr_bytes'>
      <info><![CDATA[Macro represents the total number of write bytes of the block device, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_WRITE_REQ' file='libvirt-domain' string='wr_operations'>
      <info><![CDATA[Macro represents the total write requests of the block device, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES' file='libvirt-domain' string='wr_total_times'>
      <info><![CDATA[Macro represents the total time spend on cache writes in nano-seconds of the block device, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_CPU_STATS_CPUTIME' file='libvirt-domain' string='cpu_time'>
      <info><![CDATA[cpu usage (sum of both vcpu and hypervisor usage) in nanoseconds, as a ullong]]></info>
    </macro>
    <macro name='VIR_DOMAIN_CPU_STATS_SYSTEMTIME' file='libvirt-domain' string='system_time'>
      <info><![CDATA[cpu time charged to system instructions in nanoseconds, as a ullong]]></info>
    </macro>
    <macro name='VIR_DOMAIN_CPU_STATS_USERTIME' file='libvirt-domain' string='user_time'>
      <info><![CDATA[cpu time charged to user instructions in nanoseconds, as a ullong]]></info>
    </macro>
    <macro name='VIR_DOMAIN_CPU_STATS_VCPUTIME' file='libvirt-domain' string='vcpu_time'>
      <info><![CDATA[vcpu usage in nanoseconds (cpu_time excluding hypervisor time), as a ullong]]></info>
    </macro>
    <macro name='VIR_DOMAIN_EVENT_CALLBACK' file='libvirt-domain' params='cb' raw=''>
      <info><![CDATA[Used to cast the event specific callback into the generic one for use for virConnectDomainEventRegisterAny()]]></info>
    </macro>
    <macro name='VIR_DOMAIN_IOTHREAD_POLL_GROW' file='libvirt-domain' string='poll_grow'>
      <info><![CDATA[This provides a value for the dynamic polling adjustment algorithm to use to grow its polling interval up to the poll_max_ns value. A value of 0 (zero) allows the hypervisor to choose its own value. The algorithm to use for adjustment is hypervisor specific.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_IOTHREAD_POLL_MAX_NS' file='libvirt-domain' string='poll_max_ns'>
      <info><![CDATA[The maximum polling time that can be used by polling algorithm in ns. The polling time starts at 0 (zero) and is the time spent by the guest to process IOThread data before returning the CPU to the host. The polling time will be dynamically modified over time based on the poll_grow and poll_shrink parameters provided. A value set too large will cause more CPU time to be allocated the guest. A value set too small will not provide enough cycles for the guest to process data. The polling interval is not available for statistical purposes.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_IOTHREAD_POLL_SHRINK' file='libvirt-domain' string='poll_shrink'>
      <info><![CDATA[This provides a value for the dynamic polling adjustment algorithm to use to shrink its polling interval when the polling interval exceeds the poll_max_ns value. A value of 0 (zero) allows the hypervisor to choose its own value. The algorithm to use for adjustment is hypervisor specific.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE' file='libvirt-domain' string='auto_converge_throttle'>
      <info><![CDATA[virDomainGetJobStats field: current percentage guest CPUs are throttled to when auto-convergence decided migration was not converging, as VIR_TYPED_PARAM_INT.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_COMPRESSION_BYTES' file='libvirt-domain' string='compression_bytes'>
      <info><![CDATA[virDomainGetJobStats field: number of compressed bytes transferred since the beginning of migration, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_COMPRESSION_CACHE' file='libvirt-domain' string='compression_cache'>
      <info><![CDATA[virDomainGetJobStats field: size of the cache (in bytes) used for compressing repeatedly transferred memory pages during live migration, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES' file='libvirt-domain' string='compression_cache_misses'>
      <info><![CDATA[virDomainGetJobStats field: number of repeatedly changing pages that were not found in compression cache and thus could not be compressed, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW' file='libvirt-domain' string='compression_overflow'>
      <info><![CDATA[virDomainGetJobStats field: number of repeatedly changing pages that were found in compression cache but were sent uncompressed because the result of compression was larger than the original page as a whole, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_COMPRESSION_PAGES' file='libvirt-domain' string='compression_pages'>
      <info><![CDATA[virDomainGetJobStats field: number of compressed pages transferred since the beginning of migration, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DATA_PROCESSED' file='libvirt-domain' string='data_processed'>
      <info><![CDATA[virDomainGetJobStats field: number of bytes transferred from the beginning of the job, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to dataProcessed field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DATA_REMAINING' file='libvirt-domain' string='data_remaining'>
      <info><![CDATA[virDomainGetJobStats field: number of bytes that still need to be transferred, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to dataRemaining field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DATA_TOTAL' file='libvirt-domain' string='data_total'>
      <info><![CDATA[virDomainGetJobStats field: total number of bytes supposed to be transferred, as VIR_TYPED_PARAM_ULLONG. For VIR_DOMAIN_JOB_UNBOUNDED jobs, this may be less than the sum of VIR_DOMAIN_JOB_DATA_PROCESSED and VIR_DOMAIN_JOB_DATA_REMAINING in the event that the hypervisor has to repeat some data, e.g., due to dirtied pages during migration. For VIR_DOMAIN_JOB_BOUNDED jobs, VIR_DOMAIN_JOB_DATA_TOTAL shall always equal VIR_DOMAIN_JOB_DATA_PROCESSED + VIR_DOMAIN_JOB_DATA_REMAINING.  This field corresponds to dataTotal field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DISK_BPS' file='libvirt-domain' string='disk_bps'>
      <info><![CDATA[virDomainGetJobStats field: network throughput used while migrating disks in Bytes per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DISK_PROCESSED' file='libvirt-domain' string='disk_processed'>
      <info><![CDATA[virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_PROCESSED but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to fileProcessed field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DISK_REMAINING' file='libvirt-domain' string='disk_remaining'>
      <info><![CDATA[virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_REMAINING but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to fileRemaining field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DISK_TEMP_TOTAL' file='libvirt-domain' string='disk_temp_total'>
      <info><![CDATA[virDomainGetJobStats field: possible total temporary disk space for the job in bytes as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DISK_TEMP_USED' file='libvirt-domain' string='disk_temp_used'>
      <info><![CDATA[virDomainGetJobStats field: current usage of temporary disk space for the job in bytes as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DISK_TOTAL' file='libvirt-domain' string='disk_total'>
      <info><![CDATA[virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_TOTAL but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to fileTotal field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DOWNTIME' file='libvirt-domain' string='downtime'>
      <info><![CDATA[virDomainGetJobStats field: downtime (ms) that is expected to happen during migration, as VIR_TYPED_PARAM_ULLONG. The real computed downtime between the time guest CPUs were paused and the time they were resumed is reported for completed migration.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_DOWNTIME_NET' file='libvirt-domain' string='downtime_net'>
      <info><![CDATA[virDomainGetJobStats field: real measured downtime (ms) NOT including the time required to transfer control flow from the source host to the destination host, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_ERRMSG' file='libvirt-domain' string='errmsg'>
      <info><![CDATA[virDomainGetJobStats field: Present only in statistics for a completed job. Optional error message for a failed job.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_BPS' file='libvirt-domain' string='memory_bps'>
      <info><![CDATA[virDomainGetJobStats field: network throughput used while migrating memory in Bytes per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_CONSTANT' file='libvirt-domain' string='memory_constant'>
      <info><![CDATA[virDomainGetJobStats field: number of pages filled with a constant byte (all bytes in a single page are identical) transferred since the beginning of the migration job, as VIR_TYPED_PARAM_ULLONG.  The most common example of such pages are zero pages, i.e., pages filled with zero bytes.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE' file='libvirt-domain' string='memory_dirty_rate'>
      <info><![CDATA[virDomainGetJobStats field: number of memory pages dirtied by the guest per second, as VIR_TYPED_PARAM_ULLONG. This statistics makes sense only when live migration is running.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_ITERATION' file='libvirt-domain' string='memory_iteration'>
      <info><![CDATA[virDomainGetJobStats field: current iteration over domain's memory during live migration, as VIR_TYPED_PARAM_ULLONG. This is set to zero when memory starts to be transferred and the value is increased by one every time a new iteration is started to transfer memory pages dirtied since the last iteration.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_NORMAL' file='libvirt-domain' string='memory_normal'>
      <info><![CDATA[virDomainGetJobStats field: number of pages that were transferred without any kind of compression (i.e., pages which were not filled with a constant byte and which could not be compressed) transferred since the beginning of the migration job, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES' file='libvirt-domain' string='memory_normal_bytes'>
      <info><![CDATA[virDomainGetJobStats field: number of bytes transferred as normal pages, as VIR_TYPED_PARAM_ULLONG.  See VIR_DOMAIN_JOB_MEMORY_NORMAL for more details.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE' file='libvirt-domain' string='memory_page_size'>
      <info><![CDATA[virDomainGetJobStats field: memory page size in bytes, as VIR_TYPED_PARAM_ULLONG. If present, this parameter can be used to convert other page based statistics, such as VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE or VIR_DOMAIN_JOB_COMPRESSION_PAGES to bytes.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS' file='libvirt-domain' string='memory_postcopy_requests'>
      <info><![CDATA[virDomainGetJobStats field: number page requests received from the destination host during post-copy migration, as VIR_TYPED_PARAM_ULLONG. This counter is incremented whenever the migrated domain tries to access a memory page which has not been transferred from the source host yet.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_PROCESSED' file='libvirt-domain' string='memory_processed'>
      <info><![CDATA[virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_PROCESSED but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to memProcessed field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_REMAINING' file='libvirt-domain' string='memory_remaining'>
      <info><![CDATA[virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_REMAINING but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to memRemaining field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_MEMORY_TOTAL' file='libvirt-domain' string='memory_total'>
      <info><![CDATA[virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_TOTAL but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to memTotal field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_OPERATION' file='libvirt-domain' string='operation'>
      <info><![CDATA[virDomainGetJobStats field: the operation which started the job as VIR_TYPED_PARAM_INT. The values correspond to the items in virDomainJobOperation enum.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_SETUP_TIME' file='libvirt-domain' string='setup_time'>
      <info><![CDATA[virDomainGetJobStats field: total time in milliseconds spent preparing the migration in the 'setup' phase before the iterations begin, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_SUCCESS' file='libvirt-domain' string='success'>
      <info><![CDATA[virDomainGetJobStats field: Present only in statistics for a completed job. Successful completion of the job as VIR_TYPED_PARAM_BOOLEAN.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_TIME_ELAPSED' file='libvirt-domain' string='time_elapsed'>
      <info><![CDATA[virDomainGetJobStats field: time (ms) since the beginning of the job, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to timeElapsed field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_TIME_ELAPSED_NET' file='libvirt-domain' string='time_elapsed_net'>
      <info><![CDATA[virDomainGetJobStats field: time (ms) since the beginning of the migration job NOT including the time required to transfer control flow from the source host to the destination host, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_JOB_TIME_REMAINING' file='libvirt-domain' string='time_remaining'>
      <info><![CDATA[virDomainGetJobStats field: remaining time (ms) for VIR_DOMAIN_JOB_BOUNDED jobs, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to timeRemaining field in virDomainJobInfo.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_LAUNCH_SECURITY_SEV_MEASUREMENT' file='libvirt-domain' string='sev-measurement'>
      <info><![CDATA[Macro represents the launch measurement of the SEV guest, as VIR_TYPED_PARAM_STRING.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_FIELD_LENGTH' file='libvirt-domain' raw='VIR_TYPED_PARAM_FIELD_LENGTH'>
      <info><![CDATA[Macro providing the field length of virMemoryParameter.  Provided for backwards compatibility; VIR_TYPED_PARAM_FIELD_LENGTH is the preferred value since 0.9.2.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_HARD_LIMIT' file='libvirt-domain' string='hard_limit'>
      <info><![CDATA[Macro for the memory tunable hard_limit: it represents the maximum memory the guest can use, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_MIN_GUARANTEE' file='libvirt-domain' string='min_guarantee'>
      <info><![CDATA[Macro for the memory tunable min_guarantee: it represents the minimum memory guaranteed to be reserved for the guest, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_PARAM_UNLIMITED' file='libvirt-domain' raw='9007199254740991LL /* = INT64_MAX &gt;&gt; 10 */'>
      <info><![CDATA[Macro providing the virMemoryParameter value that indicates "unlimited"]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_SOFT_LIMIT' file='libvirt-domain' string='soft_limit'>
      <info><![CDATA[Macro for the memory tunable soft_limit: it represents the memory upper limit enforced during memory contention, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT' file='libvirt-domain' string='swap_hard_limit'>
      <info><![CDATA[Macro for the swap tunable swap_hard_limit: it represents the maximum swap plus memory the guest can use, as a ullong. This limit has to be more than VIR_DOMAIN_MEMORY_HARD_LIMIT.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_NUMA_MODE' file='libvirt-domain' string='numa_mode'>
      <info><![CDATA[Macro for typed parameter name that lists the numa mode of a domain, as an int containing a virDomainNumatuneMemMode value.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_NUMA_NODESET' file='libvirt-domain' string='numa_nodeset'>
      <info><![CDATA[Macro for typed parameter name that lists the numa nodeset of a domain, as a string.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_CAP' file='libvirt-domain' string='cap'>
      <info><![CDATA[Macro represents the maximum scheduler cap, when using the credit scheduler, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_CPU_SHARES' file='libvirt-domain' string='cpu_shares'>
      <info><![CDATA[Macro represents proportional weight of the scheduler used on the host cpu, when using the posix scheduler, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD' file='libvirt-domain' string='emulator_period'>
      <info><![CDATA[Macro represents the enforcement period for a quota in microseconds, when using the posix scheduler, for all emulator activity not tied to vcpus, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA' file='libvirt-domain' string='emulator_quota'>
      <info><![CDATA[Macro represents the maximum bandwidth to be used within a period for all emulator activity not tied to vcpus, when using the posix scheduler, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD' file='libvirt-domain' string='global_period'>
      <info><![CDATA[Macro represents the enforcement period for a quota, in microseconds, for whole domain, when using the posix scheduler, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA' file='libvirt-domain' string='global_quota'>
      <info><![CDATA[Macro represents the maximum bandwidth to be used within a period for whole domain, when using the posix scheduler, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD' file='libvirt-domain' string='iothread_period'>
      <info><![CDATA[Macro represents the enforcement period for a quota, in microseconds, for IOThreads only, when using the posix scheduler, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA' file='libvirt-domain' string='iothread_quota'>
      <info><![CDATA[Macro represents the maximum bandwidth to be used within a period for IOThreads only, when using the posix scheduler, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_LIMIT' file='libvirt-domain' string='limit'>
      <info><![CDATA[Macro represents the scheduler limit value, when using the allocation scheduler, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_RESERVATION' file='libvirt-domain' string='reservation'>
      <info><![CDATA[Macro represents the scheduler reservation value, when using the allocation scheduler, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_SHARES' file='libvirt-domain' string='shares'>
      <info><![CDATA[Macro represents the scheduler shares value, when using the allocation scheduler, as an int.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_VCPU_PERIOD' file='libvirt-domain' string='vcpu_period'>
      <info><![CDATA[Macro represents the enforcement period for a quota, in microseconds, for vcpus only, when using the posix scheduler, as a ullong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_VCPU_QUOTA' file='libvirt-domain' string='vcpu_quota'>
      <info><![CDATA[Macro represents the maximum bandwidth to be used within a period for vcpus only, when using the posix scheduler, as an llong.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHEDULER_WEIGHT' file='libvirt-domain' string='weight'>
      <info><![CDATA[Macro represents the relative weight,  when using the credit scheduler, as a uint.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHED_FIELD_LENGTH' file='libvirt-domain' raw='VIR_TYPED_PARAM_FIELD_LENGTH'>
      <info><![CDATA[Macro providing the field length of virSchedParameter.  Provided for backwards compatibility; VIR_TYPED_PARAM_FIELD_LENGTH is the preferred value since 0.9.2.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SEND_KEY_MAX_KEYS' file='libvirt-domain' raw='16'>
      <info><![CDATA[Maximum number of keycodes that can be sent in one virDomainSendKey() call.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_DISK' file='libvirt-domain' string='blkdeviotune.disk'>
      <info><![CDATA[Macro represents the name of guest disk for which the values are updated, as VIR_TYPED_PARAM_STRING.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME' file='libvirt-domain' string='blkdeviotune.group_name'>
      <info><![CDATA[Macro represents the group name to be used, as VIR_TYPED_PARAM_STRING.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC' file='libvirt-domain' string='blkdeviotune.read_bytes_sec'>
      <info><![CDATA[Macro represents the read throughput limit in bytes per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX' file='libvirt-domain' string='blkdeviotune.read_bytes_sec_max'>
      <info><![CDATA[Macro represents the read throughput limit during bursts in maximum bytes per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH' file='libvirt-domain' string='blkdeviotune.read_bytes_sec_max_length'>
      <info><![CDATA[Macro represents the length in seconds allowed for a burst period for the blkdeviotune.read_bytes_sec_max as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC' file='libvirt-domain' string='blkdeviotune.read_iops_sec'>
      <info><![CDATA[Macro represents the read I/O operations per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX' file='libvirt-domain' string='blkdeviotune.read_iops_sec_max'>
      <info><![CDATA[Macro represents the read maximum I/O operations per second during bursts, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH' file='libvirt-domain' string='blkdeviotune.read_iops_sec_max_length'>
      <info><![CDATA[Macro represents the length in seconds allowed for a burst period for the blkdeviotune.read_iops_sec_max as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC' file='libvirt-domain' string='blkdeviotune.size_iops_sec'>
      <info><![CDATA[Macro represents the size maximum I/O operations per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC' file='libvirt-domain' string='blkdeviotune.total_bytes_sec'>
      <info><![CDATA[Macro represents the total throughput limit in bytes per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX' file='libvirt-domain' string='blkdeviotune.total_bytes_sec_max'>
      <info><![CDATA[Macro represents the total throughput limit during bursts in maximum bytes per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH' file='libvirt-domain' string='blkdeviotune.total_bytes_sec_max_length'>
      <info><![CDATA[Macro represents the length in seconds allowed for a burst period for the blkdeviotune.total_bytes_sec_max, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC' file='libvirt-domain' string='blkdeviotune.total_iops_sec'>
      <info><![CDATA[Macro represents the total I/O operations per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX' file='libvirt-domain' string='blkdeviotune.total_iops_sec_max'>
      <info><![CDATA[Macro represents the total maximum I/O operations per second during bursts, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH' file='libvirt-domain' string='blkdeviotune.total_iops_sec_max_length'>
      <info><![CDATA[Macro represents the length in seconds allowed for a burst period for the blkdeviotune.total_iops_sec_max as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC' file='libvirt-domain' string='blkdeviotune.write_bytes_sec'>
      <info><![CDATA[Macro represents the write throughput limit in bytes per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX' file='libvirt-domain' string='blkdeviotune.write_bytes_sec_max'>
      <info><![CDATA[Macro represents the write throughput limit during bursts in maximum bytes per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH' file='libvirt-domain' string='blkdeviotune.write_bytes_sec_max_length'>
      <info><![CDATA[Macro represents the length in seconds allowed for a burst period for the blkdeviotune.write_bytes_sec_max as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC' file='libvirt-domain' string='blkdeviotune.write_iops_sec'>
      <info><![CDATA[Macro represents the write I/O operations per second, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX' file='libvirt-domain' string='blkdeviotune.write_iops_sec_max'>
      <info><![CDATA[Macro represents the write maximum I/O operations per second during bursts, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH' file='libvirt-domain' string='blkdeviotune.write_iops_sec_max_length'>
      <info><![CDATA[Macro represents the length in seconds allowed for a burst period for the blkdeviotune.write_iops_sec_max as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES' file='libvirt-domain' string='cputune.cpu_shares'>
      <info><![CDATA[Macro represents proportional weight of the scheduler used on the host cpu, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN' file='libvirt-domain' string='cputune.emulatorpin'>
      <info><![CDATA[Macro represents formatted pinning for emulator process, as VIR_TYPED_PARAM_STRING.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD' file='libvirt-domain' string='cputune.emulator_period'>
      <info><![CDATA[Macro represents the enforcement period for a quota in microseconds, when using the posix scheduler, for all emulator activity not tied to vcpus, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA' file='libvirt-domain' string='cputune.emulator_quota'>
      <info><![CDATA[Macro represents the maximum bandwidth to be used within a period for all emulator activity not tied to vcpus, when using the posix scheduler, as an VIR_TYPED_PARAM_LLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD' file='libvirt-domain' string='cputune.global_period'>
      <info><![CDATA[Macro represents the enforcement period for a quota, in microseconds, for whole domain, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA' file='libvirt-domain' string='cputune.global_quota'>
      <info><![CDATA[Macro represents the maximum bandwidth to be used within a period for whole domain, when using the posix scheduler, as VIR_TYPED_PARAM_LLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN' file='libvirt-domain' string='cputune.iothreadpin%u'>
      <info><![CDATA[Macro represents formatted pinning for one IOThread specified by id which is appended to the parameter name, for example "cputune.iothreadpin1", as VIR_TYPED_PARAM_STRING.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD' file='libvirt-domain' string='cputune.iothread_period'>
      <info><![CDATA[Macro represents the enforcement period for a quota, in microseconds, for iothreads only, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA' file='libvirt-domain' string='cputune.iothread_quota'>
      <info><![CDATA[Macro represents the maximum bandwidth to be used within a period for iothreads only, when using the posix scheduler, as VIR_TYPED_PARAM_LLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_VCPUPIN' file='libvirt-domain' string='cputune.vcpupin%u'>
      <info><![CDATA[Macro represents formatted pinning for one vcpu specified by id which is appended to the parameter name, for example "cputune.vcpupin1", as VIR_TYPED_PARAM_STRING.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD' file='libvirt-domain' string='cputune.vcpu_period'>
      <info><![CDATA[Macro represents the enforcement period for a quota, in microseconds, for vcpus only, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA' file='libvirt-domain' string='cputune.vcpu_quota'>
      <info><![CDATA[Macro represents the maximum bandwidth to be used within a period for vcpus only, when using the posix scheduler, as VIR_TYPED_PARAM_LLONG.]]></info>
    </macro>
    <macro name='VIR_GET_CPUMAP' file='libvirt-domain' params='cpumaps,maplen,vcpu' raw='(&amp;((cpumaps)[(vcpu) * (maplen)]))'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_GET_CPUMAP macro returns a pointer to the cpumap of the specified vcpu from cpumaps array.]]></info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
    </macro>
    <macro name='VIR_KEYCODE_SET_RFB' file='libvirt-domain' raw='VIR_KEYCODE_SET_QNUM'>
      <info><![CDATA[Compatibility alias for VIR_KEYCODE_SET_QNUM, which replaced it since 4.2.0.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT' file='libvirt-domain' string='auto_converge.increment'>
      <info><![CDATA[virDomainMigrate* params field: the increment added to VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL whenever the hypervisor decides the current rate is not enough to ensure convergence of the migration. As VIR_TYPED_PARAM_INT.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL' file='libvirt-domain' string='auto_converge.initial'>
      <info><![CDATA[virDomainMigrate* params field: the initial percentage guest CPUs are throttled to when auto-convergence decides migration is not converging. As VIR_TYPED_PARAM_INT.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_BANDWIDTH' file='libvirt-domain' string='bandwidth'>
      <info><![CDATA[virDomainMigrate* params field: the maximum bandwidth (in MiB/s) that will be used for migration as VIR_TYPED_PARAM_ULLONG. If set to 0 or omitted, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if this field is used and is not 0.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY' file='libvirt-domain' string='bandwidth.postcopy'>
      <info><![CDATA[virDomainMigrate* params field: the maximum bandwidth (in MiB/s) that will be used for post-copy phase of a migration as VIR_TYPED_PARAM_ULLONG. If set to 0 or omitted, post-copy migration speed will not be limited.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_COMPRESSION' file='libvirt-domain' string='compression'>
      <info><![CDATA[virDomainMigrate* params multiple field: name of the method used to compress migration traffic. Supported compression methods: xbzrle, mt. The parameter may be specified multiple times if more than one method should be used.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS' file='libvirt-domain' string='compression.mt.dthreads'>
      <info><![CDATA[virDomainMigrate* params field: the number of decompression threads for multithread compression as VIR_TYPED_PARAM_INT.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL' file='libvirt-domain' string='compression.mt.level'>
      <info><![CDATA[virDomainMigrate* params field: the level of compression for multithread compression as VIR_TYPED_PARAM_INT. Accepted values are in range 0-9. 0 is no compression, 1 is maximum speed and 9 is maximum compression.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS' file='libvirt-domain' string='compression.mt.threads'>
      <info><![CDATA[virDomainMigrate* params field: the number of compression threads for multithread compression as VIR_TYPED_PARAM_INT.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE' file='libvirt-domain' string='compression.xbzrle.cache'>
      <info><![CDATA[virDomainMigrate* params field: the size of page cache for xbzrle compression as VIR_TYPED_PARAM_ULLONG.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_DEST_NAME' file='libvirt-domain' string='destination_name'>
      <info><![CDATA[virDomainMigrate* params field: the name to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. Omitting this parameter keeps the domain name the same. This field is only allowed to be used with hypervisors that support domain renaming during migration.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_DEST_XML' file='libvirt-domain' string='destination_xml'>
      <info><![CDATA[virDomainMigrate* params field: the new configuration to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. The configuration must include an identical set of virtual devices, to ensure a stable guest ABI across migration. Only parameters related to host side configuration can be changed in the XML. Hypervisors which support this field will forbid migration if the provided XML would cause a change in the guest ABI. This field cannot be used to rename the domain during migration (use VIR_MIGRATE_PARAM_DEST_NAME field for that purpose). Domain name in the destination XML must match the original domain name.  Omitting this parameter keeps the original domain configuration. Using this field with hypervisors that do not support changing domain configuration during migration will result in a failure.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_DISKS_PORT' file='libvirt-domain' string='disks_port'>
      <info><![CDATA[virDomainMigrate* params field: port that destination server should use for incoming disks migration. Type is VIR_TYPED_PARAM_INT. If set to 0 or omitted, libvirt will choose a suitable default. At the moment this is only supported by the QEMU driver.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_GRAPHICS_URI' file='libvirt-domain' string='graphics_uri'>
      <info><![CDATA[virDomainMigrate* params field: URI to use for migrating client's connection to domain's graphical console as VIR_TYPED_PARAM_STRING. If specified, the client will be asked to automatically reconnect using these parameters instead of the automatically computed ones. This can be useful if, e.g., the client does not have a direct access to the network virtualization hosts are connected to and needs to connect through a proxy. The URI is formed as follows:  protocol://hostname[:port]/[?parameters]  where protocol is either "spice" or "vnc" and parameters is a list of protocol specific parameters separated by '&'. Currently recognized parameters are "tlsPort" and "tlsSubject". For example,  spice://target.host.com:1234/?tlsPort=4567]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_LISTEN_ADDRESS' file='libvirt-domain' string='listen_address'>
      <info><![CDATA[virDomainMigrate* params field: The listen address that hypervisor on the destination side should bind to for incoming migration. Both IPv4 and IPv6 addresses are accepted as well as hostnames (the resolving is done on destination). Some hypervisors do not support this feature and will return an error if this field is used.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_MIGRATE_DISKS' file='libvirt-domain' string='migrate_disks'>
      <info><![CDATA[virDomainMigrate* params multiple field: The multiple values that list the block devices to be migrated. At the moment this is only supported by the QEMU driver but not for the tunnelled migration.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS' file='libvirt-domain' string='parallel.connections'>
      <info><![CDATA[virDomainMigrate* params field: number of connections used during parallel migration. As VIR_TYPED_PARAM_INT.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_PERSIST_XML' file='libvirt-domain' string='persistent_xml'>
      <info><![CDATA[virDomainMigrate* params field: the new persistent configuration to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. This field cannot be used to rename the domain during migration (use VIR_MIGRATE_PARAM_DEST_NAME field for that purpose). Domain name in the destination XML must match the original domain name.  Omitting this parameter keeps the original domain persistent configuration. Using this field with hypervisors that do not support changing domain configuration during migration will result in a failure.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_TLS_DESTINATION' file='libvirt-domain' string='tls.destination'>
      <info><![CDATA[virDomainMigrate* params field: override the destination host name used for TLS verification. As VIR_TYPED_PARAM_STRING.  Normally the TLS certificate from the destination host must match the host's name for TLS verification to succeed. When the certificate does not match the destination hostname and the expected certificate's hostname is known, this parameter can be used to pass this expected hostname when starting the migration.]]></info>
    </macro>
    <macro name='VIR_MIGRATE_PARAM_URI' file='libvirt-domain' string='migrate_uri'>
      <info><![CDATA[virDomainMigrate* params field: URI to use for initiating domain migration as VIR_TYPED_PARAM_STRING. It takes a hypervisor specific format. The uri_transports element of the hypervisor capabilities XML includes details of the supported URI schemes. When omitted libvirt will auto-generate suitable default URI. It is typically only necessary to specify this URI if the destination host has multiple interfaces and a specific interface is required to transmit migration data.  This field may not be used when VIR_MIGRATE_TUNNELLED flag is set.]]></info>
    </macro>
    <macro name='VIR_NETWORK_EVENT_CALLBACK' file='libvirt-network' params='cb' raw=''>
      <info><![CDATA[Used to cast the event specific callback into the generic one for use for virConnectNetworkEventRegisterAny()]]></info>
    </macro>
    <macro name='VIR_NETWORK_PORT_BANDWIDTH_IN_AVERAGE' file='libvirt-network' string='inbound.average'>
      <info><![CDATA[Macro represents the inbound average of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_NETWORK_PORT_BANDWIDTH_IN_BURST' file='libvirt-network' string='inbound.burst'>
      <info><![CDATA[Macro represents the inbound burst of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_NETWORK_PORT_BANDWIDTH_IN_FLOOR' file='libvirt-network' string='inbound.floor'>
      <info><![CDATA[Macro represents the inbound floor of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_NETWORK_PORT_BANDWIDTH_IN_PEAK' file='libvirt-network' string='inbound.peak'>
      <info><![CDATA[Macro represents the inbound peak of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_NETWORK_PORT_BANDWIDTH_OUT_AVERAGE' file='libvirt-network' string='outbound.average'>
      <info><![CDATA[Macro represents the outbound average of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_NETWORK_PORT_BANDWIDTH_OUT_BURST' file='libvirt-network' string='outbound.burst'>
      <info><![CDATA[Macro represents the outbound burst of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_NETWORK_PORT_BANDWIDTH_OUT_PEAK' file='libvirt-network' string='outbound.peak'>
      <info><![CDATA[Macro represents the outbound peak of NIC bandwidth, as a uint.]]></info>
    </macro>
    <macro name='VIR_NODEINFO_MAXCPUS' file='libvirt-host' params='nodeinfo' raw=''>
      <info><![CDATA[This macro is to calculate the total number of CPUs supported but not necessary active in the host.]]></info>
      <arg name='nodeinfo' info='virNodeInfo instance'/>
    </macro>
    <macro name='VIR_NODE_CPU_STATS_FIELD_LENGTH' file='libvirt-host' raw='80'>
      <info><![CDATA[Macro providing the field length of virNodeCPUStats]]></info>
    </macro>
    <macro name='VIR_NODE_CPU_STATS_IDLE' file='libvirt-host' string='idle'>
      <info><![CDATA[The cumulative idle CPU time, since the node booting up (in nanoseconds).]]></info>
    </macro>
    <macro name='VIR_NODE_CPU_STATS_INTR' file='libvirt-host' string='intr'>
      <info><![CDATA[The cumulative interrupt CPU time, since the node booting up (in nanoseconds).]]></info>
    </macro>
    <macro name='VIR_NODE_CPU_STATS_IOWAIT' file='libvirt-host' string='iowait'>
      <info><![CDATA[The cumulative I/O wait CPU time, since the node booting up (in nanoseconds).]]></info>
    </macro>
    <macro name='VIR_NODE_CPU_STATS_KERNEL' file='libvirt-host' string='kernel'>
      <info><![CDATA[Macro for the cumulative CPU time which was spent by the kernel, since the node booting up (in nanoseconds).]]></info>
    </macro>
    <macro name='VIR_NODE_CPU_STATS_USER' file='libvirt-host' string='user'>
      <info><![CDATA[The cumulative CPU time which was spent by user processes, since the node booting up (in nanoseconds).]]></info>
    </macro>
    <macro name='VIR_NODE_CPU_STATS_UTILIZATION' file='libvirt-host' string='utilization'>
      <info><![CDATA[The CPU utilization of a node. The usage value is in percent and 100% represents all CPUs of the node.]]></info>
    </macro>
    <macro name='VIR_NODE_DEVICE_EVENT_CALLBACK' file='libvirt-nodedev' params='cb' raw='((virConnectNodeDeviceEventGenericCallback)(cb))'>
      <info><![CDATA[Used to cast the event specific callback into the generic one for use for virConnectNodeDeviceEventRegisterAny()]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_SHARED_FULL_SCANS' file='libvirt-host' string='shm_full_scans'>
      <info><![CDATA[Macro for typed parameter that represents how many times all mergeable areas have been scanned.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES' file='libvirt-host' string='shm_merge_across_nodes'>
      <info><![CDATA[Macro for typed parameter that represents whether pages from different NUMA nodes can be merged. The parameter has type int, when its value is 0, only pages which physically reside in the memory area of same NUMA node are merged; When its value is 1, pages from all nodes can be merged. Other values are reserved for future use.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_SHARED_PAGES_SHARED' file='libvirt-host' string='shm_pages_shared'>
      <info><![CDATA[Macro for typed parameter that represents how many the shared memory pages are being used.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_SHARED_PAGES_SHARING' file='libvirt-host' string='shm_pages_sharing'>
      <info><![CDATA[Macro for typed parameter that represents how many sites are sharing the pages i.e. how much saved.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_SHARED_PAGES_TO_SCAN' file='libvirt-host' string='shm_pages_to_scan'>
      <info><![CDATA[Macro for typed parameter that represents how many present pages to scan before the shared memory service goes to sleep.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_SHARED_PAGES_UNSHARED' file='libvirt-host' string='shm_pages_unshared'>
      <info><![CDATA[Macro for typed parameter that represents how many pages unique but repeatedly checked for merging.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_SHARED_PAGES_VOLATILE' file='libvirt-host' string='shm_pages_volatile'>
      <info><![CDATA[Macro for typed parameter that represents how many pages changing too fast to be placed in a tree.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_SHARED_SLEEP_MILLISECS' file='libvirt-host' string='shm_sleep_millisecs'>
      <info><![CDATA[Macro for typed parameter that represents how many milliseconds the shared memory service should sleep before next scan.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_STATS_BUFFERS' file='libvirt-host' string='buffers'>
      <info><![CDATA[Macro for the buffer memory: On Linux, it is only returned in case of VIR_NODE_MEMORY_STATS_ALL_CELLS.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_STATS_CACHED' file='libvirt-host' string='cached'>
      <info><![CDATA[Macro for the cached memory: On Linux, it is only returned in case of VIR_NODE_MEMORY_STATS_ALL_CELLS.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_STATS_FIELD_LENGTH' file='libvirt-host' raw='80'>
      <info><![CDATA[Macro providing the field length of virNodeMemoryStats]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_STATS_FREE' file='libvirt-host' string='free'>
      <info><![CDATA[Macro for the free memory of specified cell: On Linux, it includes buffer and cached memory, in case of VIR_NODE_MEMORY_STATS_ALL_CELLS.]]></info>
    </macro>
    <macro name='VIR_NODE_MEMORY_STATS_TOTAL' file='libvirt-host' string='total'>
      <info><![CDATA[Macro for the total memory of specified cell: it represents the maximum memory.]]></info>
    </macro>
    <macro name='VIR_NODE_SEV_CBITPOS' file='libvirt-host' string='cbitpos'>
      <info><![CDATA[Macro represents the CBit Position used by hypervisor when SEV is enabled.]]></info>
    </macro>
    <macro name='VIR_NODE_SEV_CERT_CHAIN' file='libvirt-host' string='cert-chain'>
      <info><![CDATA[Macro represents the platform certificate chain that includes the platform endorsement key (PEK), owner certificate authority (OCD) and chip endorsement key (CEK), as VIR_TYPED_PARAMS_STRING.]]></info>
    </macro>
    <macro name='VIR_NODE_SEV_PDH' file='libvirt-host' string='pdh'>
      <info><![CDATA[Macro represents the Platform Diffie-Hellman key, as VIR_TYPED_PARAMS_STRING.]]></info>
    </macro>
    <macro name='VIR_NODE_SEV_REDUCED_PHYS_BITS' file='libvirt-host' string='reduced-phys-bits'>
      <info><![CDATA[Macro represents the number of bits we lose in physical address space when SEV is enabled in the guest.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_ALIGNMENT_FAULTS' file='libvirt-domain' string='alignment_faults'>
      <info><![CDATA[Macro for typed parameter name that represents alignment_faults perf event which can be used to measure the count of alignment faults by applications running on the platform. It corresponds to the "perf.alignment_faults" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_BRANCH_INSTRUCTIONS' file='libvirt-domain' string='branch_instructions'>
      <info><![CDATA[Macro for typed parameter name that represents branch_instructions perf event which can be used to measure the count of branch instructions by applications running on the platform. It corresponds to the "perf.branch_instructions" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_BRANCH_MISSES' file='libvirt-domain' string='branch_misses'>
      <info><![CDATA[Macro for typed parameter name that represents branch_misses perf event which can be used to measure the count of branch misses by applications running on the platform. It corresponds to the "perf.branch_misses" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_BUS_CYCLES' file='libvirt-domain' string='bus_cycles'>
      <info><![CDATA[Macro for typed parameter name that represents bus_cycles perf event which can be used to measure the count of bus cycles by applications running on the platform. It corresponds to the "perf.bus_cycles" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_CACHE_MISSES' file='libvirt-domain' string='cache_misses'>
      <info><![CDATA[Macro for typed parameter name that represents cache_misses perf event which can be used to measure the count of cache misses by applications running on the platform. It corresponds to the "perf.cache_misses" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_CACHE_REFERENCES' file='libvirt-domain' string='cache_references'>
      <info><![CDATA[Macro for typed parameter name that represents cache_references perf event which can be used to measure the count of cache hits by applications running on the platform. It corresponds to the "perf.cache_references" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_CMT' file='libvirt-domain' string='cmt'>
      <info><![CDATA[Macro for typed parameter name that represents CMT perf event which can be used to measure the usage of cache (bytes) by applications running on the platform. It corresponds to the "perf.cmt" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_CONTEXT_SWITCHES' file='libvirt-domain' string='context_switches'>
      <info><![CDATA[Macro for typed parameter name that represents context_switches perf event which can be used to measure the count of context switches by applications running on the platform. It corresponds to the "perf.context_switches" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_CPU_CLOCK' file='libvirt-domain' string='cpu_clock'>
      <info><![CDATA[Macro for typed parameter name that represents cpu_clock perf event which can be used to measure the count of cpu clock time by applications running on the platform. It corresponds to the "perf.cpu_clock" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_CPU_CYCLES' file='libvirt-domain' string='cpu_cycles'>
      <info><![CDATA[Macro for typed parameter name that represents cpu_cycles perf event describing the total/elapsed cpu cycles. This can be used to measure how many cpu cycles one instruction needs. It corresponds to the "perf.cpu_cycles" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_CPU_MIGRATIONS' file='libvirt-domain' string='cpu_migrations'>
      <info><![CDATA[Macro for typed parameter name that represents cpu_migrations perf event which can be used to measure the count of cpu migrations by applications running on the platform. It corresponds to the "perf.cpu_migrations" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_EMULATION_FAULTS' file='libvirt-domain' string='emulation_faults'>
      <info><![CDATA[Macro for typed parameter name that represents emulation_faults perf event which can be used to measure the count of emulation faults by applications running on the platform. It corresponds to the "perf.emulation_faults" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_INSTRUCTIONS' file='libvirt-domain' string='instructions'>
      <info><![CDATA[Macro for typed parameter name that represents instructions perf event which can be used to measure the count of instructions by applications running on the platform. It corresponds to the "perf.instructions" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_MBML' file='libvirt-domain' string='mbml'>
      <info><![CDATA[Macro for typed parameter name that represents MBML perf event which can be used to monitor the amount of data (bytes/s) sent through the memory controller on the socket. It corresponds to the "perf.mbml" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_MBMT' file='libvirt-domain' string='mbmt'>
      <info><![CDATA[Macro for typed parameter name that represents MBMT perf event which can be used to monitor total system bandwidth (bytes/s) from one level of cache to another. It corresponds to the "perf.mbmt" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_PAGE_FAULTS' file='libvirt-domain' string='page_faults'>
      <info><![CDATA[Macro for typed parameter name that represents page_faults perf event which can be used to measure the count of page faults by applications running on the platform. It corresponds to the "perf.page_faults" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_PAGE_FAULTS_MAJ' file='libvirt-domain' string='page_faults_maj'>
      <info><![CDATA[Macro for typed parameter name that represents page_faults_maj perf event which can be used to measure the count of major page faults by applications running on the platform. It corresponds to the "perf.page_faults_maj" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_PAGE_FAULTS_MIN' file='libvirt-domain' string='page_faults_min'>
      <info><![CDATA[Macro for typed parameter name that represents page_faults_min perf event which can be used to measure the count of minor page faults by applications running on the platform. It corresponds to the "perf.page_faults_min" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_REF_CPU_CYCLES' file='libvirt-domain' string='ref_cpu_cycles'>
      <info><![CDATA[Macro for typed parameter name that represents ref_cpu_cycles perf event which can be used to measure the count of total cpu cycles not affected by CPU frequency scaling by applications running on the platform. It corresponds to the "perf.ref_cpu_cycles" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_STALLED_CYCLES_BACKEND' file='libvirt-domain' string='stalled_cycles_backend'>
      <info><![CDATA[Macro for typed parameter name that represents stalled_cycles_backend perf event which can be used to measure the count of stalled cpu cycles in the backend of the instruction processor pipeline by application running on the platform. It corresponds to the "perf.stalled_cycles_backend" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND' file='libvirt-domain' string='stalled_cycles_frontend'>
      <info><![CDATA[Macro for typed parameter name that represents stalled_cycles_frontend perf event which can be used to measure the count of stalled cpu cycles in the frontend of the instruction processor pipeline by applications running on the platform. It corresponds to the "perf.stalled_cycles_frontend" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_PERF_PARAM_TASK_CLOCK' file='libvirt-domain' string='task_clock'>
      <info><![CDATA[Macro for typed parameter name that represents task_clock perf event which can be used to measure the count of task clock time by applications running on the platform. It corresponds to the "perf.task_clock" field in the *Stats APIs.]]></info>
    </macro>
    <macro name='VIR_SECRET_EVENT_CALLBACK' file='libvirt-secret' params='cb' raw='((virConnectSecretEventGenericCallback)(cb))'>
      <info><![CDATA[Used to cast the event specific callback into the generic one for use for virConnectSecretEventRegisterAny()]]></info>
    </macro>
    <macro name='VIR_SECURITY_DOI_BUFLEN' file='libvirt-host' raw='(256 + 1)'>
      <info><![CDATA[Macro providing the maximum length of the virSecurityModel doi string.]]></info>
    </macro>
    <macro name='VIR_SECURITY_LABEL_BUFLEN' file='libvirt-host' raw='(4096 + 1)'>
      <info><![CDATA[Macro providing the maximum length of the virSecurityLabel label string. Note that this value is based on that used by Labeled NFS.]]></info>
    </macro>
    <macro name='VIR_SECURITY_MODEL_BUFLEN' file='libvirt-host' raw='(256 + 1)'>
      <info><![CDATA[Macro providing the maximum length of the virSecurityModel model string.]]></info>
    </macro>
    <macro name='VIR_STORAGE_POOL_EVENT_CALLBACK' file='libvirt-storage' params='cb' raw='((virConnectStoragePoolEventGenericCallback)(cb))'>
      <info><![CDATA[Used to cast the event specific callback into the generic one for use for virConnectStoragePoolEventRegisterAny()]]></info>
    </macro>
    <macro name='VIR_TYPED_PARAM_FIELD_LENGTH' file='libvirt-common' raw='80'>
      <info><![CDATA[Macro providing the field length of virTypedParameter name]]></info>
    </macro>
    <macro name='VIR_UNUSE_CPU' file='libvirt-domain' params='cpumap,cpu' raw='((cpumap)[(cpu) / 8] &amp;= ~(1 &lt;&lt; ((cpu) % 8)))'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainPinVcpu() API. It resets the bit (CPU not usable) of the related cpu in cpumap.]]></info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_USE_CPU' file='libvirt-domain' params='cpumap,cpu' raw='((cpumap)[(cpu) / 8] |= (1 &lt;&lt; ((cpu) % 8)))'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainPinVcpu() API. It sets the bit (CPU usable) of the related cpu in cpumap.]]></info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_UUID_BUFLEN' file='libvirt-host' raw='(16)'>
      <info><![CDATA[This macro provides the length of the buffer required for virDomainGetUUID()]]></info>
    </macro>
    <macro name='VIR_UUID_STRING_BUFLEN' file='libvirt-host' raw='(36+1)'>
      <info><![CDATA[This macro provides the length of the buffer required for virDomainGetUUIDString()]]></info>
    </macro>
    <macro name='_virBlkioParameter' file='libvirt-domain' raw='_virTypedParameter'>
    </macro>
    <macro name='_virMemoryParameter' file='libvirt-domain' raw='_virTypedParameter'>
    </macro>
    <macro name='_virSchedParameter' file='libvirt-domain' raw='_virTypedParameter'>
    </macro>
    <enum name='VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES' file='libvirt-host' value='1' value_hex='0x1' value_bitshift='0' type='virConnectBaselineCPUFlags' info='show all features'/>
    <enum name='VIR_CONNECT_BASELINE_CPU_MIGRATABLE' file='libvirt-host' value='2' value_hex='0x2' value_bitshift='1' type='virConnectBaselineCPUFlags' info='filter out non-migratable features'/>
    <enum name='VIR_CONNECT_CLOSE_REASON_CLIENT' file='libvirt-common' value='3' value_hex='0x3' type='virConnectCloseReason' info='Client requested it'/>
    <enum name='VIR_CONNECT_CLOSE_REASON_EOF' file='libvirt-common' value='1' value_hex='0x1' type='virConnectCloseReason' info='End-of-file from server'/>
    <enum name='VIR_CONNECT_CLOSE_REASON_ERROR' file='libvirt-common' value='0' value_hex='0x0' type='virConnectCloseReason' info='Misc I/O error'/>
    <enum name='VIR_CONNECT_CLOSE_REASON_KEEPALIVE' file='libvirt-common' value='2' value_hex='0x2' type='virConnectCloseReason' info='Keepalive timer triggered'/>
    <enum name='VIR_CONNECT_CLOSE_REASON_LAST' file='libvirt-common' value='4' value_hex='0x4' type='virConnectCloseReason'/>
    <enum name='VIR_CONNECT_COMPARE_CPU_FAIL_INCOMPATIBLE' file='libvirt-host' value='1' value_hex='0x1' value_bitshift='0' type='virConnectCompareCPUFlags' info='treat incompatible
CPUs as failure'/>
    <enum name='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_CHANNEL' file='libvirt-domain' value='2' value_hex='0x2' type='virConnectDomainEventAgentLifecycleReason' info='channel state changed'/>
    <enum name='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_DOMAIN_STARTED' file='libvirt-domain' value='1' value_hex='0x1' type='virConnectDomainEventAgentLifecycleReason' info='state changed due to domain start'/>
    <enum name='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virConnectDomainEventAgentLifecycleReason'/>
    <enum name='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virConnectDomainEventAgentLifecycleReason' info='unknown state change reason'/>
    <enum name='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_CONNECTED' file='libvirt-domain' value='1' value_hex='0x1' type='virConnectDomainEventAgentLifecycleState' info='agent connected'/>
    <enum name='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_DISCONNECTED' file='libvirt-domain' value='2' value_hex='0x2' type='virConnectDomainEventAgentLifecycleState' info='agent disconnected'/>
    <enum name='VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virConnectDomainEventAgentLifecycleState'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE' file='libvirt-domain' value='VIR_CONNECT_LIST_DOMAINS_ACTIVE' type='virConnectGetAllDomainStatsFlags'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING' file='libvirt-domain' value='1073741824' value_hex='0x40000000' value_bitshift='30' type='virConnectGetAllDomainStatsFlags' info='include backing chain for block stats'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS' file='libvirt-domain' value='2147483648' value_hex='0x80000000' value_bitshift='31' type='virConnectGetAllDomainStatsFlags' info='enforce requested stats'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE' file='libvirt-domain' value='VIR_CONNECT_LIST_DOMAINS_INACTIVE' type='virConnectGetAllDomainStatsFlags'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT' file='libvirt-domain' value='536870912' value_hex='0x20000000' value_bitshift='29' type='virConnectGetAllDomainStatsFlags' info='report statistics that can be obtained
immediately without any blocking'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER' file='libvirt-domain' value='VIR_CONNECT_LIST_DOMAINS_OTHER' type='virConnectGetAllDomainStatsFlags'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED' file='libvirt-domain' value='VIR_CONNECT_LIST_DOMAINS_PAUSED' type='virConnectGetAllDomainStatsFlags'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT' file='libvirt-domain' value='VIR_CONNECT_LIST_DOMAINS_PERSISTENT' type='virConnectGetAllDomainStatsFlags'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING' file='libvirt-domain' value='VIR_CONNECT_LIST_DOMAINS_RUNNING' type='virConnectGetAllDomainStatsFlags'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF' file='libvirt-domain' value='VIR_CONNECT_LIST_DOMAINS_SHUTOFF' type='virConnectGetAllDomainStatsFlags'/>
    <enum name='VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT' file='libvirt-domain' value='VIR_CONNECT_LIST_DOMAINS_TRANSIENT' type='virConnectGetAllDomainStatsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_ACTIVE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_AUTOSTART' file='libvirt-domain' value='1024' value_hex='0x400' value_bitshift='10' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_HAS_CHECKPOINT' file='libvirt-domain' value='16384' value_hex='0x4000' value_bitshift='14' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT' file='libvirt-domain' value='4096' value_hex='0x1000' value_bitshift='12' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_INACTIVE' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE' file='libvirt-domain' value='256' value_hex='0x100' value_bitshift='8' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART' file='libvirt-domain' value='2048' value_hex='0x800' value_bitshift='11' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_NO_CHECKPOINT' file='libvirt-domain' value='32768' value_hex='0x8000' value_bitshift='15' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE' file='libvirt-domain' value='512' value_hex='0x200' value_bitshift='9' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT' file='libvirt-domain' value='8192' value_hex='0x2000' value_bitshift='13' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_OTHER' file='libvirt-domain' value='128' value_hex='0x80' value_bitshift='7' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_PAUSED' file='libvirt-domain' value='32' value_hex='0x20' value_bitshift='5' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_PERSISTENT' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_RUNNING' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_SHUTOFF' file='libvirt-domain' value='64' value_hex='0x40' value_bitshift='6' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_DOMAINS_TRANSIENT' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virConnectListAllDomainsFlags'/>
    <enum name='VIR_CONNECT_LIST_INTERFACES_ACTIVE' file='libvirt-interface' value='2' value_hex='0x2' value_bitshift='1' type='virConnectListAllInterfacesFlags'/>
    <enum name='VIR_CONNECT_LIST_INTERFACES_INACTIVE' file='libvirt-interface' value='1' value_hex='0x1' value_bitshift='0' type='virConnectListAllInterfacesFlags'/>
    <enum name='VIR_CONNECT_LIST_NETWORKS_ACTIVE' file='libvirt-network' value='2' value_hex='0x2' value_bitshift='1' type='virConnectListAllNetworksFlags'/>
    <enum name='VIR_CONNECT_LIST_NETWORKS_AUTOSTART' file='libvirt-network' value='16' value_hex='0x10' value_bitshift='4' type='virConnectListAllNetworksFlags'/>
    <enum name='VIR_CONNECT_LIST_NETWORKS_INACTIVE' file='libvirt-network' value='1' value_hex='0x1' value_bitshift='0' type='virConnectListAllNetworksFlags'/>
    <enum name='VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART' file='libvirt-network' value='32' value_hex='0x20' value_bitshift='5' type='virConnectListAllNetworksFlags'/>
    <enum name='VIR_CONNECT_LIST_NETWORKS_PERSISTENT' file='libvirt-network' value='4' value_hex='0x4' value_bitshift='2' type='virConnectListAllNetworksFlags'/>
    <enum name='VIR_CONNECT_LIST_NETWORKS_TRANSIENT' file='libvirt-network' value='8' value_hex='0x8' value_bitshift='3' type='virConnectListAllNetworksFlags'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV' file='libvirt-nodedev' value='32768' value_hex='0x8000' value_bitshift='15' type='virConnectListAllNodeDeviceFlags' info='CCW device'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_DRM' file='libvirt-nodedev' value='4096' value_hex='0x1000' value_bitshift='12' type='virConnectListAllNodeDeviceFlags' info='DRM device'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST' file='libvirt-nodedev' value='512' value_hex='0x200' value_bitshift='9' type='virConnectListAllNodeDeviceFlags' info='FC Host Bus Adapter'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV' file='libvirt-nodedev' value='16384' value_hex='0x4000' value_bitshift='14' type='virConnectListAllNodeDeviceFlags' info='Mediated device'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV_TYPES' file='libvirt-nodedev' value='8192' value_hex='0x2000' value_bitshift='13' type='virConnectListAllNodeDeviceFlags' info='Capable of mediated devices'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET' file='libvirt-nodedev' value='16' value_hex='0x10' value_bitshift='4' type='virConnectListAllNodeDeviceFlags' info='Network device'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV' file='libvirt-nodedev' value='2' value_hex='0x2' value_bitshift='1' type='virConnectListAllNodeDeviceFlags' info='PCI device'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI' file='libvirt-nodedev' value='128' value_hex='0x80' value_bitshift='7' type='virConnectListAllNodeDeviceFlags' info='SCSI device'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC' file='libvirt-nodedev' value='2048' value_hex='0x800' value_bitshift='11' type='virConnectListAllNodeDeviceFlags' info='Capable of scsi_generic'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST' file='libvirt-nodedev' value='32' value_hex='0x20' value_bitshift='5' type='virConnectListAllNodeDeviceFlags' info='SCSI Host Bus Adapter'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET' file='libvirt-nodedev' value='64' value_hex='0x40' value_bitshift='6' type='virConnectListAllNodeDeviceFlags' info='SCSI Target'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE' file='libvirt-nodedev' value='256' value_hex='0x100' value_bitshift='8' type='virConnectListAllNodeDeviceFlags' info='Storage device'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM' file='libvirt-nodedev' value='1' value_hex='0x1' value_bitshift='0' type='virConnectListAllNodeDeviceFlags' info='System capability'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV' file='libvirt-nodedev' value='4' value_hex='0x4' value_bitshift='2' type='virConnectListAllNodeDeviceFlags' info='USB device'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE' file='libvirt-nodedev' value='8' value_hex='0x8' value_bitshift='3' type='virConnectListAllNodeDeviceFlags' info='USB interface'/>
    <enum name='VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS' file='libvirt-nodedev' value='1024' value_hex='0x400' value_bitshift='10' type='virConnectListAllNodeDeviceFlags' info='Capable of vport'/>
    <enum name='VIR_CONNECT_LIST_SECRETS_EPHEMERAL' file='libvirt-secret' value='1' value_hex='0x1' value_bitshift='0' type='virConnectListAllSecretsFlags' info='kept in memory, never
stored persistently'/>
    <enum name='VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL' file='libvirt-secret' value='2' value_hex='0x2' value_bitshift='1' type='virConnectListAllSecretsFlags'/>
    <enum name='VIR_CONNECT_LIST_SECRETS_NO_PRIVATE' file='libvirt-secret' value='8' value_hex='0x8' value_bitshift='3' type='virConnectListAllSecretsFlags'/>
    <enum name='VIR_CONNECT_LIST_SECRETS_PRIVATE' file='libvirt-secret' value='4' value_hex='0x4' value_bitshift='2' type='virConnectListAllSecretsFlags' info='not revealed to any caller
of libvirt, nor to any other
node'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE' file='libvirt-storage' value='2' value_hex='0x2' value_bitshift='1' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART' file='libvirt-storage' value='16' value_hex='0x10' value_bitshift='4' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_DIR' file='libvirt-storage' value='64' value_hex='0x40' value_bitshift='6' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_DISK' file='libvirt-storage' value='1024' value_hex='0x400' value_bitshift='10' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_FS' file='libvirt-storage' value='128' value_hex='0x80' value_bitshift='7' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_GLUSTER' file='libvirt-storage' value='65536' value_hex='0x10000' value_bitshift='16' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI' file='libvirt-storage' value='2048' value_hex='0x800' value_bitshift='11' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI_DIRECT' file='libvirt-storage' value='524288' value_hex='0x80000' value_bitshift='19' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL' file='libvirt-storage' value='512' value_hex='0x200' value_bitshift='9' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_MPATH' file='libvirt-storage' value='8192' value_hex='0x2000' value_bitshift='13' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_NETFS' file='libvirt-storage' value='256' value_hex='0x100' value_bitshift='8' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART' file='libvirt-storage' value='32' value_hex='0x20' value_bitshift='5' type='virConnectListAllStoragePoolsFlags' info='List pools by type'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT' file='libvirt-storage' value='4' value_hex='0x4' value_bitshift='2' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_RBD' file='libvirt-storage' value='16384' value_hex='0x4000' value_bitshift='14' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_SCSI' file='libvirt-storage' value='4096' value_hex='0x1000' value_bitshift='12' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG' file='libvirt-storage' value='32768' value_hex='0x8000' value_bitshift='15' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT' file='libvirt-storage' value='8' value_hex='0x8' value_bitshift='3' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_VSTORAGE' file='libvirt-storage' value='262144' value_hex='0x40000' value_bitshift='18' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_LIST_STORAGE_POOLS_ZFS' file='libvirt-storage' value='131072' value_hex='0x20000' value_bitshift='17' type='virConnectListAllStoragePoolsFlags'/>
    <enum name='VIR_CONNECT_NO_ALIASES' file='libvirt-host' value='2' value_hex='0x2' value_bitshift='1' type='virConnectFlags' info='Don&apos;t try to resolve URI aliases'/>
    <enum name='VIR_CONNECT_RO' file='libvirt-host' value='1' value_hex='0x1' value_bitshift='0' type='virConnectFlags' info='A readonly connection'/>
    <enum name='VIR_CPU_COMPARE_ERROR' file='libvirt-host' value='-1' value_hex='-0x1' type='virCPUCompareResult'/>
    <enum name='VIR_CPU_COMPARE_IDENTICAL' file='libvirt-host' value='1' value_hex='0x1' type='virCPUCompareResult'/>
    <enum name='VIR_CPU_COMPARE_INCOMPATIBLE' file='libvirt-host' value='0' value_hex='0x0' type='virCPUCompareResult'/>
    <enum name='VIR_CPU_COMPARE_LAST' file='libvirt-host' value='3' value_hex='0x3' type='virCPUCompareResult'/>
    <enum name='VIR_CPU_COMPARE_SUPERSET' file='libvirt-host' value='2' value_hex='0x2' type='virCPUCompareResult'/>
    <enum name='VIR_CRED_AUTHNAME' file='libvirt-host' value='2' value_hex='0x2' type='virConnectCredentialType' info='Identify to authorize as'/>
    <enum name='VIR_CRED_CNONCE' file='libvirt-host' value='4' value_hex='0x4' type='virConnectCredentialType' info='client supplies a nonce'/>
    <enum name='VIR_CRED_ECHOPROMPT' file='libvirt-host' value='6' value_hex='0x6' type='virConnectCredentialType' info='Challenge response'/>
    <enum name='VIR_CRED_EXTERNAL' file='libvirt-host' value='9' value_hex='0x9' type='virConnectCredentialType' info='Externally managed credential'/>
    <enum name='VIR_CRED_LANGUAGE' file='libvirt-host' value='3' value_hex='0x3' type='virConnectCredentialType' info='RFC 1766 languages, comma separated'/>
    <enum name='VIR_CRED_LAST' file='libvirt-host' value='10' value_hex='0xa' type='virConnectCredentialType' info='More may be added - expect the unexpected'/>
    <enum name='VIR_CRED_NOECHOPROMPT' file='libvirt-host' value='7' value_hex='0x7' type='virConnectCredentialType' info='Challenge response'/>
    <enum name='VIR_CRED_PASSPHRASE' file='libvirt-host' value='5' value_hex='0x5' type='virConnectCredentialType' info='Passphrase secret'/>
    <enum name='VIR_CRED_REALM' file='libvirt-host' value='8' value_hex='0x8' type='virConnectCredentialType' info='Authentication realm'/>
    <enum name='VIR_CRED_USERNAME' file='libvirt-host' value='1' value_hex='0x1' type='virConnectCredentialType' info='Identity to act as'/>
    <enum name='VIR_DOMAIN_AFFECT_CONFIG' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainModificationImpact' info='Affect persistent domain state.  1 &lt;&lt; 2 is reserved for virTypedParameterFlags'/>
    <enum name='VIR_DOMAIN_AFFECT_CURRENT' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainModificationImpact' info='Affect current domain state.'/>
    <enum name='VIR_DOMAIN_AFFECT_LIVE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainModificationImpact' info='Affect running domain state.'/>
    <enum name='VIR_DOMAIN_AGENT_RESPONSE_TIMEOUT_BLOCK' file='libvirt-domain' value='-2' value_hex='-0x2' type='virDomainAgentResponseTimeoutValues'/>
    <enum name='VIR_DOMAIN_AGENT_RESPONSE_TIMEOUT_DEFAULT' file='libvirt-domain' value='-1' value_hex='-0x1' type='virDomainAgentResponseTimeoutValues'/>
    <enum name='VIR_DOMAIN_AGENT_RESPONSE_TIMEOUT_NOWAIT' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainAgentResponseTimeoutValues'/>
    <enum name='VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainBackupBeginFlags' info='reuse separately
provided images'/>
    <enum name='VIR_DOMAIN_BLKIO_PARAM_BOOLEAN' file='libvirt-domain' value='VIR_TYPED_PARAM_BOOLEAN' type='virBlkioParameterType'/>
    <enum name='VIR_DOMAIN_BLKIO_PARAM_DOUBLE' file='libvirt-domain' value='VIR_TYPED_PARAM_DOUBLE' type='virBlkioParameterType'/>
    <enum name='VIR_DOMAIN_BLKIO_PARAM_INT' file='libvirt-domain' value='VIR_TYPED_PARAM_INT' type='virBlkioParameterType'/>
    <enum name='VIR_DOMAIN_BLKIO_PARAM_LLONG' file='libvirt-domain' value='VIR_TYPED_PARAM_LLONG' type='virBlkioParameterType'/>
    <enum name='VIR_DOMAIN_BLKIO_PARAM_UINT' file='libvirt-domain' value='VIR_TYPED_PARAM_UINT' type='virBlkioParameterType'/>
    <enum name='VIR_DOMAIN_BLKIO_PARAM_ULLONG' file='libvirt-domain' value='VIR_TYPED_PARAM_ULLONG' type='virBlkioParameterType'/>
    <enum name='VIR_DOMAIN_BLOCKED' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainState' info='the domain is blocked on resource'/>
    <enum name='VIR_DOMAIN_BLOCKED_LAST' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainBlockedReason'/>
    <enum name='VIR_DOMAIN_BLOCKED_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainBlockedReason' info='the reason is unknown'/>
    <enum name='VIR_DOMAIN_BLOCK_COMMIT_ACTIVE' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainBlockCommitFlags' info='Allow a two-phase commit when
top is the active layer'/>
    <enum name='VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainBlockCommitFlags' info='bandwidth in bytes/s
instead of MiB/s'/>
    <enum name='VIR_DOMAIN_BLOCK_COMMIT_DELETE' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainBlockCommitFlags' info='Delete any files that are now
invalid after their contents
have been committed'/>
    <enum name='VIR_DOMAIN_BLOCK_COMMIT_RELATIVE' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainBlockCommitFlags' info='keep the backing chain
referenced using relative
names'/>
    <enum name='VIR_DOMAIN_BLOCK_COMMIT_SHALLOW' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainBlockCommitFlags' info='NULL base means next backing
file, not whole chain'/>
    <enum name='VIR_DOMAIN_BLOCK_COPY_REUSE_EXT' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainBlockCopyFlags' info='Reuse existing external
file for a copy'/>
    <enum name='VIR_DOMAIN_BLOCK_COPY_SHALLOW' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainBlockCopyFlags' info='Limit copy to top of source
backing chain'/>
    <enum name='VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainBlockCopyFlags' info='Don&apos;t force usage of
recoverable job for the
copy operation'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainBlockJobAbortFlags'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainBlockJobAbortFlags'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_CANCELED' file='libvirt-domain' value='2' value_hex='0x2' type='virConnectDomainEventBlockJobStatus'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_COMPLETED' file='libvirt-domain' value='0' value_hex='0x0' type='virConnectDomainEventBlockJobStatus'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_FAILED' file='libvirt-domain' value='1' value_hex='0x1' type='virConnectDomainEventBlockJobStatus'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainBlockJobInfoFlags' info='bandwidth in bytes/s
instead of MiB/s'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_LAST' file='libvirt-domain' value='4' value_hex='0x4' type='virConnectDomainEventBlockJobStatus'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_READY' file='libvirt-domain' value='3' value_hex='0x3' type='virConnectDomainEventBlockJobStatus'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainBlockJobSetSpeedFlags' info='bandwidth in bytes/s
instead of MiB/s'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainBlockJobType' info='Active Block Commit (virDomainBlockCommit with flags), job
 exists as long as sync is active'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_TYPE_BACKUP' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainBlockJobType' info='Backup (virDomainBackupBegin)'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainBlockJobType' info='Block Commit (virDomainBlockCommit without flags), job ends on
 completion'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_TYPE_COPY' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainBlockJobType' info='Block Copy (virDomainBlockCopy, or virDomainBlockRebase with
 flags), job exists as long as mirroring is active'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_TYPE_LAST' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainBlockJobType'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_TYPE_PULL' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainBlockJobType' info='Block Pull (virDomainBlockPull, or virDomainBlockRebase without
 flags), job ends on completion'/>
    <enum name='VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainBlockJobType' info='Placeholder'/>
    <enum name='VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES' file='libvirt-domain' value='64' value_hex='0x40' value_bitshift='6' type='virDomainBlockPullFlags' info='bandwidth in bytes/s
instead of MiB/s'/>
    <enum name='VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES' file='libvirt-domain' value='64' value_hex='0x40' value_bitshift='6' type='virDomainBlockRebaseFlags' info='bandwidth in bytes/s
instead of MiB/s'/>
    <enum name='VIR_DOMAIN_BLOCK_REBASE_COPY' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainBlockRebaseFlags' info='Start a copy job'/>
    <enum name='VIR_DOMAIN_BLOCK_REBASE_COPY_DEV' file='libvirt-domain' value='32' value_hex='0x20' value_bitshift='5' type='virDomainBlockRebaseFlags' info='Treat destination as block
device instead of file'/>
    <enum name='VIR_DOMAIN_BLOCK_REBASE_COPY_RAW' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainBlockRebaseFlags' info='Make destination file raw'/>
    <enum name='VIR_DOMAIN_BLOCK_REBASE_RELATIVE' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainBlockRebaseFlags' info='Keep backing chain
referenced using relative
names'/>
    <enum name='VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainBlockRebaseFlags' info='Reuse existing external
file for a copy'/>
    <enum name='VIR_DOMAIN_BLOCK_REBASE_SHALLOW' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainBlockRebaseFlags' info='Limit copy to top of source
backing chain'/>
    <enum name='VIR_DOMAIN_BLOCK_RESIZE_BYTES' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainBlockResizeFlags' info='size in bytes instead of KiB'/>
    <enum name='VIR_DOMAIN_CHANNEL_FORCE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainChannelFlags' info='abort a (possibly) active channel
connection to force a new
connection'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_CREATE_QUIESCE' file='libvirt-domain-checkpoint' value='2' value_hex='0x2' value_bitshift='1' type='virDomainCheckpointCreateFlags' info='use guest agent to
quiesce all mounted
file systems within
the domain'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_CREATE_REDEFINE' file='libvirt-domain-checkpoint' value='1' value_hex='0x1' value_bitshift='0' type='virDomainCheckpointCreateFlags' info='Restore or alter
metadata'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_DELETE_CHILDREN' file='libvirt-domain-checkpoint' value='1' value_hex='0x1' value_bitshift='0' type='virDomainCheckpointDeleteFlags' info='Also delete children'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_DELETE_CHILDREN_ONLY' file='libvirt-domain-checkpoint' value='4' value_hex='0x4' value_bitshift='2' type='virDomainCheckpointDeleteFlags' info='Delete just children'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_DELETE_METADATA_ONLY' file='libvirt-domain-checkpoint' value='2' value_hex='0x2' value_bitshift='1' type='virDomainCheckpointDeleteFlags' info='Delete just metadata'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_LIST_DESCENDANTS' file='libvirt-domain-checkpoint' value='1' value_hex='0x1' value_bitshift='0' type='virDomainCheckpointListFlags' info='List all descendants,
not just children, when
listing a checkpoint'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_LIST_LEAVES' file='libvirt-domain-checkpoint' value='4' value_hex='0x4' value_bitshift='2' type='virDomainCheckpointListFlags' info='Filter by checkpoints
with no children'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_LIST_NO_LEAVES' file='libvirt-domain-checkpoint' value='8' value_hex='0x8' value_bitshift='3' type='virDomainCheckpointListFlags' info='Filter by checkpoints
that have children'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_LIST_ROOTS' file='libvirt-domain-checkpoint' value='1' value_hex='0x1' value_bitshift='0' type='virDomainCheckpointListFlags' info='Filter by checkpoints
with no parents, when
listing a domain'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_LIST_TOPOLOGICAL' file='libvirt-domain-checkpoint' value='2' value_hex='0x2' value_bitshift='1' type='virDomainCheckpointListFlags' info='Ensure parents occur
before children in
the resulting list'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_XML_NO_DOMAIN' file='libvirt-domain-checkpoint' value='2' value_hex='0x2' value_bitshift='1' type='virDomainCheckpointXMLFlags' info='Suppress &lt;domain&gt;
subelement'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_XML_SECURE' file='libvirt-domain-checkpoint' value='1' value_hex='0x1' value_bitshift='0' type='virDomainCheckpointXMLFlags' info='Include sensitive data'/>
    <enum name='VIR_DOMAIN_CHECKPOINT_XML_SIZE' file='libvirt-domain-checkpoint' value='4' value_hex='0x4' value_bitshift='2' type='virDomainCheckpointXMLFlags' info='Include dynamic
per-&lt;disk&gt; size'/>
    <enum name='VIR_DOMAIN_CONSOLE_FORCE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainConsoleFlags' info='abort a (possibly) active console
connection to force a new
connection'/>
    <enum name='VIR_DOMAIN_CONSOLE_SAFE' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainConsoleFlags' info='check if the console driver supports
safe console operations'/>
    <enum name='VIR_DOMAIN_CONTROL_ERROR' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainControlState' info='unusable, domain cannot be fully
operated, possible reason is provided
in the details field'/>
    <enum name='VIR_DOMAIN_CONTROL_ERROR_REASON_INTERNAL' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainControlErrorReason' info='error caused due to
internal failure in libvirt'/>
    <enum name='VIR_DOMAIN_CONTROL_ERROR_REASON_LAST' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainControlErrorReason'/>
    <enum name='VIR_DOMAIN_CONTROL_ERROR_REASON_MONITOR' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainControlErrorReason' info='monitor connection is
broken'/>
    <enum name='VIR_DOMAIN_CONTROL_ERROR_REASON_NONE' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainControlErrorReason' info='server didn&apos;t provide a
reason'/>
    <enum name='VIR_DOMAIN_CONTROL_ERROR_REASON_UNKNOWN' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainControlErrorReason' info='unknown reason for the
error'/>
    <enum name='VIR_DOMAIN_CONTROL_JOB' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainControlState' info='background job is running (can be
monitored by virDomainGetJobInfo); only
limited set of commands may be allowed'/>
    <enum name='VIR_DOMAIN_CONTROL_LAST' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainControlState'/>
    <enum name='VIR_DOMAIN_CONTROL_OCCUPIED' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainControlState' info='occupied by a running command'/>
    <enum name='VIR_DOMAIN_CONTROL_OK' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainControlState' info='operational, ready to accept commands'/>
    <enum name='VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_LZO' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainCoreDumpFormat' info='kdump-compressed format, with
 lzo compression'/>
    <enum name='VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_SNAPPY' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainCoreDumpFormat' info='kdump-compressed format, with
 snappy compression'/>
    <enum name='VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_ZLIB' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainCoreDumpFormat' info='kdump-compressed format, with
 zlib compression'/>
    <enum name='VIR_DOMAIN_CORE_DUMP_FORMAT_LAST' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainCoreDumpFormat' info='NB: this enum value will increase over time as new events are
 added to the libvirt API. It reflects the last state supported
 by this version of the libvirt API.'/>
    <enum name='VIR_DOMAIN_CORE_DUMP_FORMAT_RAW' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainCoreDumpFormat' info='dump guest memory in raw format'/>
    <enum name='VIR_DOMAIN_CRASHED' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainState' info='the domain is crashed'/>
    <enum name='VIR_DOMAIN_CRASHED_LAST' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainCrashedReason'/>
    <enum name='VIR_DOMAIN_CRASHED_PANICKED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainCrashedReason' info='domain panicked'/>
    <enum name='VIR_DOMAIN_CRASHED_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainCrashedReason' info='crashed for unknown reason'/>
    <enum name='VIR_DOMAIN_DEFINE_VALIDATE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainDefineFlags' info='Validate the XML document against schema'/>
    <enum name='VIR_DOMAIN_DESTROY_DEFAULT' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainDestroyFlagsValues' info='Default behavior - could lead to data loss!!'/>
    <enum name='VIR_DOMAIN_DESTROY_GRACEFUL' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainDestroyFlagsValues' info='only SIGTERM, no SIGKILL'/>
    <enum name='VIR_DOMAIN_DEVICE_MODIFY_CONFIG' file='libvirt-domain' value='VIR_DOMAIN_AFFECT_CONFIG' type='virDomainDeviceModifyFlags'/>
    <enum name='VIR_DOMAIN_DEVICE_MODIFY_CURRENT' file='libvirt-domain' value='VIR_DOMAIN_AFFECT_CURRENT' type='virDomainDeviceModifyFlags' info='See virDomainModificationImpact for these flags.'/>
    <enum name='VIR_DOMAIN_DEVICE_MODIFY_FORCE' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainDeviceModifyFlags' info='Additionally, these flags may be bitwise-OR&apos;d in.'/>
    <enum name='VIR_DOMAIN_DEVICE_MODIFY_LIVE' file='libvirt-domain' value='VIR_DOMAIN_AFFECT_LIVE' type='virDomainDeviceModifyFlags'/>
    <enum name='VIR_DOMAIN_DISK_ERROR_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainDiskErrorCode'/>
    <enum name='VIR_DOMAIN_DISK_ERROR_NONE' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainDiskErrorCode' info='no error'/>
    <enum name='VIR_DOMAIN_DISK_ERROR_NO_SPACE' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainDiskErrorCode' info='no space left on the device'/>
    <enum name='VIR_DOMAIN_DISK_ERROR_UNSPEC' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainDiskErrorCode' info='unspecified I/O error'/>
    <enum name='VIR_DOMAIN_EVENT_CRASHED' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_CRASHED_CRASHLOADED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventCrashedDetailType' info='Guest was crashloaded'/>
    <enum name='VIR_DOMAIN_EVENT_CRASHED_LAST' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventCrashedDetailType'/>
    <enum name='VIR_DOMAIN_EVENT_CRASHED_PANICKED' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventCrashedDetailType' info='Guest was panicked'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED_ADDED' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventDefinedDetailType' info='Newly created config file'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED_FROM_SNAPSHOT' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventDefinedDetailType' info='Config was restored from a snapshot'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED_LAST' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainEventDefinedDetailType'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED_RENAMED' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventDefinedDetailType' info='Domain was renamed'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED_UPDATED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventDefinedDetailType' info='Changed config file'/>
    <enum name='VIR_DOMAIN_EVENT_DISK_CHANGE_LAST' file='libvirt-domain' value='2' value_hex='0x2' type='virConnectDomainEventDiskChangeReason'/>
    <enum name='VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START' file='libvirt-domain' value='0' value_hex='0x0' type='virConnectDomainEventDiskChangeReason' info='Removable media changed to empty according to startup policy as source
 was missing. oldSrcPath is set, newSrcPath is NULL'/>
    <enum name='VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START' file='libvirt-domain' value='1' value_hex='0x1' type='virConnectDomainEventDiskChangeReason' info='Disk was dropped from domain as source file was missing.
 oldSrcPath is set, newSrcPath is NULL'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventGraphicsAddressType' info='IPv4 address'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventGraphicsAddressType' info='IPv6 address'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventGraphicsAddressType'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventGraphicsAddressType' info='UNIX socket path'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_CONNECT' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventGraphicsPhase' info='Initial socket connection established'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventGraphicsPhase' info='Final socket disconnection'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventGraphicsPhase' info='Authentication &amp; setup completed'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventGraphicsPhase'/>
    <enum name='VIR_DOMAIN_EVENT_ID_AGENT_LIFECYCLE' file='libvirt-domain' value='18' value_hex='0x12' type='virDomainEventID' info='virConnectDomainEventAgentLifecycleCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE' file='libvirt-domain' value='13' value_hex='0xd' type='virDomainEventID' info='virConnectDomainEventBalloonChangeCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_BLOCK_JOB' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainEventID' info='virConnectDomainEventBlockJobCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2' file='libvirt-domain' value='16' value_hex='0x10' type='virDomainEventID' info='virConnectDomainEventBlockJobCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD' file='libvirt-domain' value='24' value_hex='0x18' type='virDomainEventID' info='virConnectDomainEventBlockThresholdCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_CONTROL_ERROR' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainEventID' info='virConnectDomainEventGenericCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_DEVICE_ADDED' file='libvirt-domain' value='19' value_hex='0x13' type='virDomainEventID' info='virConnectDomainEventDeviceAddedCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED' file='libvirt-domain' value='22' value_hex='0x16' type='virDomainEventID' info='virConnectDomainEventDeviceRemovalFailedCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED' file='libvirt-domain' value='15' value_hex='0xf' type='virDomainEventID' info='virConnectDomainEventDeviceRemovedCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_DISK_CHANGE' file='libvirt-domain' value='9' value_hex='0x9' type='virDomainEventID' info='virConnectDomainEventDiskChangeCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_GRAPHICS' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainEventID' info='virConnectDomainEventGraphicsCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_IO_ERROR' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainEventID' info='virConnectDomainEventIOErrorCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainEventID' info='virConnectDomainEventIOErrorReasonCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_JOB_COMPLETED' file='libvirt-domain' value='21' value_hex='0x15' type='virDomainEventID' info='virConnectDomainEventJobCompletedCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_LAST' file='libvirt-domain' value='25' value_hex='0x19' type='virDomainEventID' info='NB: this enum value will increase over time as new events are
 added to the libvirt API. It reflects the last event ID supported
 by this version of the libvirt API.'/>
    <enum name='VIR_DOMAIN_EVENT_ID_LIFECYCLE' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventID' info='virConnectDomainEventCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_METADATA_CHANGE' file='libvirt-domain' value='23' value_hex='0x17' type='virDomainEventID' info='virConnectDomainEventMetadataChangeCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_MIGRATION_ITERATION' file='libvirt-domain' value='20' value_hex='0x14' type='virDomainEventID' info='virConnectDomainEventMigrationIterationCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_PMSUSPEND' file='libvirt-domain' value='12' value_hex='0xc' type='virDomainEventID' info='virConnectDomainEventPMSuspendCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK' file='libvirt-domain' value='14' value_hex='0xe' type='virDomainEventID' info='virConnectDomainEventPMSuspendDiskCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_PMWAKEUP' file='libvirt-domain' value='11' value_hex='0xb' type='virDomainEventID' info='virConnectDomainEventPMWakeupCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_REBOOT' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventID' info='virConnectDomainEventGenericCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_RTC_CHANGE' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventID' info='virConnectDomainEventRTCChangeCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_TRAY_CHANGE' file='libvirt-domain' value='10' value_hex='0xa' type='virDomainEventID' info='virConnectDomainEventTrayChangeCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_TUNABLE' file='libvirt-domain' value='17' value_hex='0x11' type='virDomainEventID' info='virConnectDomainEventTunableCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_WATCHDOG' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventID' info='virConnectDomainEventWatchdogCallback'/>
    <enum name='VIR_DOMAIN_EVENT_IO_ERROR_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventIOErrorAction'/>
    <enum name='VIR_DOMAIN_EVENT_IO_ERROR_NONE' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventIOErrorAction' info='No action, IO error ignored'/>
    <enum name='VIR_DOMAIN_EVENT_IO_ERROR_PAUSE' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventIOErrorAction' info='Guest CPUs are paused'/>
    <enum name='VIR_DOMAIN_EVENT_IO_ERROR_REPORT' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventIOErrorAction' info='IO error reported to guest OS'/>
    <enum name='VIR_DOMAIN_EVENT_LAST' file='libvirt-domain' value='9' value_hex='0x9' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_PMSUSPENDED' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_PMSUSPENDED_DISK' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventPMSuspendedDetailType' info='Guest was PM suspended to disk'/>
    <enum name='VIR_DOMAIN_EVENT_PMSUSPENDED_LAST' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventPMSuspendedDetailType'/>
    <enum name='VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventPMSuspendedDetailType' info='Guest was PM suspended to memory'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventResumedDetailType' info='Resumed from snapshot'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED_LAST' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainEventResumedDetailType'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED_MIGRATED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventResumedDetailType' info='Resumed for completion of migration'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED_POSTCOPY' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventResumedDetailType' info='Resumed, but migration is still
running in post-copy mode'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED_UNPAUSED' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventResumedDetailType' info='Normal resume due to admin unpause'/>
    <enum name='VIR_DOMAIN_EVENT_SHUTDOWN' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventShutdownDetailType' info='Guest finished shutdown sequence'/>
    <enum name='VIR_DOMAIN_EVENT_SHUTDOWN_GUEST' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventShutdownDetailType' info='Domain finished shutting down after request from the guest itself
 (e.g. hardware-specific action)'/>
    <enum name='VIR_DOMAIN_EVENT_SHUTDOWN_HOST' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventShutdownDetailType' info='Domain finished shutting down after request from the host (e.g. killed by
 a signal)'/>
    <enum name='VIR_DOMAIN_EVENT_SHUTDOWN_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventShutdownDetailType'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_BOOTED' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventStartedDetailType' info='Normal startup from boot'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventStartedDetailType' info='Restored from snapshot'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_LAST' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainEventStartedDetailType'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_MIGRATED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventStartedDetailType' info='Incoming migration from another host'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_RESTORED' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventStartedDetailType' info='Restored from a state file'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_WAKEUP' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainEventStartedDetailType' info='Started due to wakeup event'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_CRASHED' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventStoppedDetailType' info='Guest crashed'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_DESTROYED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventStoppedDetailType' info='Forced poweroff from host'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_FAILED' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainEventStoppedDetailType' info='Host emulator/mgmt failed'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainEventStoppedDetailType' info='offline snapshot loaded'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_LAST' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainEventStoppedDetailType'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_MIGRATED' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventStoppedDetailType' info='Migrated off to another host'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_SAVED' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainEventStoppedDetailType' info='Saved to a state file'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventStoppedDetailType' info='Normal shutdown'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainEventSuspendedDetailType' info='suspended after failure during libvirt API call'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainEventSuspendedDetailType' info='Restored from paused snapshot'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_IOERROR' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventSuspendedDetailType' info='Suspended due to a disk I/O error'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_LAST' file='libvirt-domain' value='9' value_hex='0x9' type='virDomainEventSuspendedDetailType'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventSuspendedDetailType' info='Suspended for offline migration'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_PAUSED' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventSuspendedDetailType' info='Normal suspend due to admin pause'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainEventSuspendedDetailType' info='suspended for post-copy migration'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainEventSuspendedDetailType' info='suspended after failed post-copy'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_RESTORED' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainEventSuspendedDetailType' info='Restored from paused state file'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventSuspendedDetailType' info='Suspended due to a watchdog firing'/>
    <enum name='VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventTrayChangeReason'/>
    <enum name='VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventTrayChangeReason'/>
    <enum name='VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventTrayChangeReason'/>
    <enum name='VIR_DOMAIN_EVENT_UNDEFINED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_UNDEFINED_LAST' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventUndefinedDetailType'/>
    <enum name='VIR_DOMAIN_EVENT_UNDEFINED_REMOVED' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventUndefinedDetailType' info='Deleted the config file'/>
    <enum name='VIR_DOMAIN_EVENT_UNDEFINED_RENAMED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventUndefinedDetailType' info='Domain was renamed'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_DEBUG' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainEventWatchdogAction' info='No action, a debug message logged'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_INJECTNMI' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainEventWatchdogAction' info='Inject a non-maskable interrupt into guest'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_LAST' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainEventWatchdogAction'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_NONE' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainEventWatchdogAction' info='No action, watchdog ignored'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_PAUSE' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainEventWatchdogAction' info='Guest CPUs are paused'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainEventWatchdogAction' info='Guest is forcibly powered off'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_RESET' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainEventWatchdogAction' info='Guest CPUs are reset'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainEventWatchdogAction' info='Guest is requested to gracefully shutdown'/>
    <enum name='VIR_DOMAIN_GET_HOSTNAME_AGENT' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainGetHostnameFlags' info='Query qemu guest agent'/>
    <enum name='VIR_DOMAIN_GET_HOSTNAME_LEASE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainGetHostnameFlags' info='Parse DHCP lease file'/>
    <enum name='VIR_DOMAIN_GUEST_INFO_FILESYSTEM' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainGuestInfoTypes' info='return filesystem information'/>
    <enum name='VIR_DOMAIN_GUEST_INFO_HOSTNAME' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainGuestInfoTypes' info='return hostname information'/>
    <enum name='VIR_DOMAIN_GUEST_INFO_OS' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainGuestInfoTypes' info='return OS information'/>
    <enum name='VIR_DOMAIN_GUEST_INFO_TIMEZONE' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainGuestInfoTypes' info='return timezone information'/>
    <enum name='VIR_DOMAIN_GUEST_INFO_USERS' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainGuestInfoTypes' info='return active users'/>
    <enum name='VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainInterfaceAddressesSource' info='Query qemu guest agent'/>
    <enum name='VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainInterfaceAddressesSource' info='Query ARP tables'/>
    <enum name='VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainInterfaceAddressesSource'/>
    <enum name='VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainInterfaceAddressesSource' info='Parse DHCP lease file'/>
    <enum name='VIR_DOMAIN_JOB_BOUNDED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainJobType' info='Job with a finite completion time'/>
    <enum name='VIR_DOMAIN_JOB_CANCELLED' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainJobType' info='Job was aborted, but isn&apos;t cleaned up'/>
    <enum name='VIR_DOMAIN_JOB_COMPLETED' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainJobType' info='Job has finished, but isn&apos;t cleaned up'/>
    <enum name='VIR_DOMAIN_JOB_FAILED' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainJobType' info='Job hit error, but isn&apos;t cleaned up'/>
    <enum name='VIR_DOMAIN_JOB_LAST' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainJobType'/>
    <enum name='VIR_DOMAIN_JOB_NONE' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainJobType' info='No job is active'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_BACKUP' file='libvirt-domain' value='9' value_hex='0x9' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_DUMP' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_LAST' file='libvirt-domain' value='10' value_hex='0xa' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_RESTORE' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_SAVE' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_SNAPSHOT' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_SNAPSHOT_REVERT' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_START' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_OPERATION_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainJobOperation'/>
    <enum name='VIR_DOMAIN_JOB_STATS_COMPLETED' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainGetJobStatsFlags' info='return stats of a recently
 completed job'/>
    <enum name='VIR_DOMAIN_JOB_STATS_KEEP_COMPLETED' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainGetJobStatsFlags' info='don&apos;t remove completed
stats when reading them'/>
    <enum name='VIR_DOMAIN_JOB_UNBOUNDED' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainJobType' info='Job without a finite completion time'/>
    <enum name='VIR_DOMAIN_LAST' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainState' info='NB: this enum value will increase over time as new events are
 added to the libvirt API. It reflects the last state supported
 by this version of the libvirt API.'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainLifecycleAction'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainLifecycleAction'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainLifecycleAction'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_ACTION_LAST' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainLifecycleAction'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainLifecycleAction'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_ACTION_RESTART' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainLifecycleAction'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainLifecycleAction'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_CRASH' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainLifecycle'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainLifecycle'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_POWEROFF' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainLifecycle'/>
    <enum name='VIR_DOMAIN_LIFECYCLE_REBOOT' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainLifecycle'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_BOOLEAN' file='libvirt-domain' value='VIR_TYPED_PARAM_BOOLEAN' type='virMemoryParameterType'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_DOUBLE' file='libvirt-domain' value='VIR_TYPED_PARAM_DOUBLE' type='virMemoryParameterType'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_INT' file='libvirt-domain' value='VIR_TYPED_PARAM_INT' type='virMemoryParameterType'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_LLONG' file='libvirt-domain' value='VIR_TYPED_PARAM_LLONG' type='virMemoryParameterType'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_UINT' file='libvirt-domain' value='VIR_TYPED_PARAM_UINT' type='virMemoryParameterType'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_ULLONG' file='libvirt-domain' value='VIR_TYPED_PARAM_ULLONG' type='virMemoryParameterType'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainMemoryStatTags' info='Current balloon value (in KB).'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_AVAILABLE' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainMemoryStatTags' info='The total amount of usable memory as seen by the domain.  This value
 may be less than the amount of memory assigned to the domain if a
 balloon driver is in use or if the guest OS does not initialize all
 assigned pages.  This value is expressed in kB.'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_DISK_CACHES' file='libvirt-domain' value='10' value_hex='0xa' type='virDomainMemoryStatTags' info='The amount of memory, that can be quickly reclaimed without
 additional I/O (in kB). Typically these pages are used for caching files
 from disk.'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGALLOC' file='libvirt-domain' value='11' value_hex='0xb' type='virDomainMemoryStatTags' info='The number of successful huge page allocations from inside the domain via
 virtio balloon.'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGFAIL' file='libvirt-domain' value='12' value_hex='0xc' type='virDomainMemoryStatTags' info='The number of failed huge page allocations from inside the domain via
 virtio balloon.'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_LAST' file='libvirt-domain' value='VIR_DOMAIN_MEMORY_STAT_NR' type='virDomainMemoryStatTags'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE' file='libvirt-domain' value='9' value_hex='0x9' type='virDomainMemoryStatTags' info='Timestamp of the last update of statistics, in seconds.'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainMemoryStatTags' info='Page faults occur when a process makes a valid access to virtual memory
 that is not available.  When servicing the page fault, if disk IO is
 required, it is considered a major fault.  If not, it is a minor fault.
 These are expressed as the number of faults that have occurred.'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainMemoryStatTags'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_NR' file='libvirt-domain' value='13' value_hex='0xd' type='virDomainMemoryStatTags' info='The number of statistics supported by this version of the interface.
 To add new statistics, add them to the enum and increase this value.'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_RSS' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainMemoryStatTags' info='Resident Set Size of the process running the domain. This value
 is in kB'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_SWAP_IN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainMemoryStatTags' info='The total amount of data read from swap space (in kB).'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_SWAP_OUT' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainMemoryStatTags' info='The total amount of memory written out to swap space (in kB).'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_UNUSED' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainMemoryStatTags' info='The amount of memory left completely unused by the system.  Memory that
 is available but used for reclaimable caches should NOT be reported as
 free.  This value is expressed in kB.'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_USABLE' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainMemoryStatTags' info='How much the balloon can be inflated without pushing the guest system
 to swap, corresponds to &apos;Available&apos; in /proc/meminfo'/>
    <enum name='VIR_DOMAIN_MEM_CONFIG' file='libvirt-domain' value='VIR_DOMAIN_AFFECT_CONFIG' type='virDomainMemoryModFlags'/>
    <enum name='VIR_DOMAIN_MEM_CURRENT' file='libvirt-domain' value='VIR_DOMAIN_AFFECT_CURRENT' type='virDomainMemoryModFlags' info='See virDomainModificationImpact for these flags.'/>
    <enum name='VIR_DOMAIN_MEM_LIVE' file='libvirt-domain' value='VIR_DOMAIN_AFFECT_LIVE' type='virDomainMemoryModFlags'/>
    <enum name='VIR_DOMAIN_MEM_MAXIMUM' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainMemoryModFlags' info='Additionally, these flags may be bitwise-OR&apos;d in.'/>
    <enum name='VIR_DOMAIN_METADATA_DESCRIPTION' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainMetadataType' info='Operate on &lt;description&gt;'/>
    <enum name='VIR_DOMAIN_METADATA_ELEMENT' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainMetadataType' info='Operate on &lt;metadata&gt;'/>
    <enum name='VIR_DOMAIN_METADATA_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainMetadataType'/>
    <enum name='VIR_DOMAIN_METADATA_TITLE' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainMetadataType' info='Operate on &lt;title&gt;'/>
    <enum name='VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainMigrateMaxSpeedFlags' info='Set or get maximum speed of post-copy migration.'/>
    <enum name='VIR_DOMAIN_NONE' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainCreateFlags' info='Default behavior'/>
    <enum name='VIR_DOMAIN_NOSTATE' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainState' info='no state'/>
    <enum name='VIR_DOMAIN_NOSTATE_LAST' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainNostateReason'/>
    <enum name='VIR_DOMAIN_NOSTATE_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainNostateReason'/>
    <enum name='VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainNumatuneMemMode'/>
    <enum name='VIR_DOMAIN_NUMATUNE_MEM_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainNumatuneMemMode' info='This constant is subject to change'/>
    <enum name='VIR_DOMAIN_NUMATUNE_MEM_PREFERRED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainNumatuneMemMode'/>
    <enum name='VIR_DOMAIN_NUMATUNE_MEM_STRICT' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainNumatuneMemMode'/>
    <enum name='VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainOpenGraphicsFlags'/>
    <enum name='VIR_DOMAIN_PASSWORD_ENCRYPTED' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainSetUserPasswordFlags' info='the password is already encrypted'/>
    <enum name='VIR_DOMAIN_PAUSED' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainState' info='the domain is paused by user'/>
    <enum name='VIR_DOMAIN_PAUSED_CRASHED' file='libvirt-domain' value='10' value_hex='0xa' type='virDomainPausedReason' info='paused due to a guest crash'/>
    <enum name='VIR_DOMAIN_PAUSED_DUMP' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainPausedReason' info='paused for offline core dump'/>
    <enum name='VIR_DOMAIN_PAUSED_FROM_SNAPSHOT' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainPausedReason' info='paused after restoring from snapshot'/>
    <enum name='VIR_DOMAIN_PAUSED_IOERROR' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainPausedReason' info='paused due to a disk I/O error'/>
    <enum name='VIR_DOMAIN_PAUSED_LAST' file='libvirt-domain' value='14' value_hex='0xe' type='virDomainPausedReason'/>
    <enum name='VIR_DOMAIN_PAUSED_MIGRATION' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainPausedReason' info='paused for offline migration'/>
    <enum name='VIR_DOMAIN_PAUSED_POSTCOPY' file='libvirt-domain' value='12' value_hex='0xc' type='virDomainPausedReason' info='paused for post-copy migration'/>
    <enum name='VIR_DOMAIN_PAUSED_POSTCOPY_FAILED' file='libvirt-domain' value='13' value_hex='0xd' type='virDomainPausedReason' info='paused after failed post-copy'/>
    <enum name='VIR_DOMAIN_PAUSED_SAVE' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainPausedReason' info='paused for save'/>
    <enum name='VIR_DOMAIN_PAUSED_SHUTTING_DOWN' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainPausedReason' info='paused during shutdown process'/>
    <enum name='VIR_DOMAIN_PAUSED_SNAPSHOT' file='libvirt-domain' value='9' value_hex='0x9' type='virDomainPausedReason' info='paused while creating a snapshot'/>
    <enum name='VIR_DOMAIN_PAUSED_STARTING_UP' file='libvirt-domain' value='11' value_hex='0xb' type='virDomainPausedReason' info='the domain is being started'/>
    <enum name='VIR_DOMAIN_PAUSED_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainPausedReason' info='the reason is unknown'/>
    <enum name='VIR_DOMAIN_PAUSED_USER' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainPausedReason' info='paused on user request'/>
    <enum name='VIR_DOMAIN_PAUSED_WATCHDOG' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainPausedReason' info='paused due to a watchdog event'/>
    <enum name='VIR_DOMAIN_PMSUSPENDED' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainState' info='the domain is suspended by guest
power management'/>
    <enum name='VIR_DOMAIN_PMSUSPENDED_DISK_LAST' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainPMSuspendedDiskReason'/>
    <enum name='VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainPMSuspendedDiskReason'/>
    <enum name='VIR_DOMAIN_PMSUSPENDED_LAST' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainPMSuspendedReason'/>
    <enum name='VIR_DOMAIN_PMSUSPENDED_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainPMSuspendedReason'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_ABRT' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainProcessSignal' info='SIGABRT'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_ALRM' file='libvirt-domain' value='14' value_hex='0xe' type='virDomainProcessSignal' info='SIGALRM'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_BUS' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainProcessSignal' info='SIGBUS'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_CHLD' file='libvirt-domain' value='17' value_hex='0x11' type='virDomainProcessSignal' info='SIGCHLD'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_CONT' file='libvirt-domain' value='18' value_hex='0x12' type='virDomainProcessSignal' info='SIGCONT'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_FPE' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainProcessSignal' info='SIGFPE'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_HUP' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainProcessSignal' info='SIGHUP'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_ILL' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainProcessSignal' info='SIGILL'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_INT' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainProcessSignal' info='SIGINT'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_KILL' file='libvirt-domain' value='9' value_hex='0x9' type='virDomainProcessSignal' info='SIGKILL'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_LAST' file='libvirt-domain' value='65' value_hex='0x41' type='virDomainProcessSignal'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_NOP' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainProcessSignal' info='No constant in POSIX/Linux'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_PIPE' file='libvirt-domain' value='13' value_hex='0xd' type='virDomainProcessSignal' info='SIGPIPE'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_POLL' file='libvirt-domain' value='29' value_hex='0x1d' type='virDomainProcessSignal' info='SIGPOLL (also known as SIGIO on Linux)'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_PROF' file='libvirt-domain' value='27' value_hex='0x1b' type='virDomainProcessSignal' info='SIGPROF'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_PWR' file='libvirt-domain' value='30' value_hex='0x1e' type='virDomainProcessSignal' info='Not in POSIX (SIGPWR on Linux)'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_QUIT' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainProcessSignal' info='SIGQUIT'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT0' file='libvirt-domain' value='32' value_hex='0x20' type='virDomainProcessSignal' info='SIGRTMIN'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT1' file='libvirt-domain' value='33' value_hex='0x21' type='virDomainProcessSignal' info='SIGRTMIN + 1'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT10' file='libvirt-domain' value='42' value_hex='0x2a' type='virDomainProcessSignal' info='SIGRTMIN + 10'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT11' file='libvirt-domain' value='43' value_hex='0x2b' type='virDomainProcessSignal' info='SIGRTMIN + 11'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT12' file='libvirt-domain' value='44' value_hex='0x2c' type='virDomainProcessSignal' info='SIGRTMIN + 12'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT13' file='libvirt-domain' value='45' value_hex='0x2d' type='virDomainProcessSignal' info='SIGRTMIN + 13'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT14' file='libvirt-domain' value='46' value_hex='0x2e' type='virDomainProcessSignal' info='SIGRTMIN + 14'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT15' file='libvirt-domain' value='47' value_hex='0x2f' type='virDomainProcessSignal' info='SIGRTMIN + 15'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT16' file='libvirt-domain' value='48' value_hex='0x30' type='virDomainProcessSignal' info='SIGRTMIN + 16'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT17' file='libvirt-domain' value='49' value_hex='0x31' type='virDomainProcessSignal' info='SIGRTMIN + 17'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT18' file='libvirt-domain' value='50' value_hex='0x32' type='virDomainProcessSignal' info='SIGRTMIN + 18'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT19' file='libvirt-domain' value='51' value_hex='0x33' type='virDomainProcessSignal' info='SIGRTMIN + 19'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT2' file='libvirt-domain' value='34' value_hex='0x22' type='virDomainProcessSignal' info='SIGRTMIN + 2'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT20' file='libvirt-domain' value='52' value_hex='0x34' type='virDomainProcessSignal' info='SIGRTMIN + 20'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT21' file='libvirt-domain' value='53' value_hex='0x35' type='virDomainProcessSignal' info='SIGRTMIN + 21'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT22' file='libvirt-domain' value='54' value_hex='0x36' type='virDomainProcessSignal' info='SIGRTMIN + 22'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT23' file='libvirt-domain' value='55' value_hex='0x37' type='virDomainProcessSignal' info='SIGRTMIN + 23'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT24' file='libvirt-domain' value='56' value_hex='0x38' type='virDomainProcessSignal' info='SIGRTMIN + 24'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT25' file='libvirt-domain' value='57' value_hex='0x39' type='virDomainProcessSignal' info='SIGRTMIN + 25'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT26' file='libvirt-domain' value='58' value_hex='0x3a' type='virDomainProcessSignal' info='SIGRTMIN + 26'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT27' file='libvirt-domain' value='59' value_hex='0x3b' type='virDomainProcessSignal' info='SIGRTMIN + 27'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT28' file='libvirt-domain' value='60' value_hex='0x3c' type='virDomainProcessSignal' info='SIGRTMIN + 28'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT29' file='libvirt-domain' value='61' value_hex='0x3d' type='virDomainProcessSignal' info='SIGRTMIN + 29'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT3' file='libvirt-domain' value='35' value_hex='0x23' type='virDomainProcessSignal' info='SIGRTMIN + 3'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT30' file='libvirt-domain' value='62' value_hex='0x3e' type='virDomainProcessSignal' info='SIGRTMIN + 30'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT31' file='libvirt-domain' value='63' value_hex='0x3f' type='virDomainProcessSignal' info='SIGRTMIN + 31'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT32' file='libvirt-domain' value='64' value_hex='0x40' type='virDomainProcessSignal' info='SIGRTMIN + 32 / SIGRTMAX'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT4' file='libvirt-domain' value='36' value_hex='0x24' type='virDomainProcessSignal' info='SIGRTMIN + 4'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT5' file='libvirt-domain' value='37' value_hex='0x25' type='virDomainProcessSignal' info='SIGRTMIN + 5'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT6' file='libvirt-domain' value='38' value_hex='0x26' type='virDomainProcessSignal' info='SIGRTMIN + 6'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT7' file='libvirt-domain' value='39' value_hex='0x27' type='virDomainProcessSignal' info='SIGRTMIN + 7'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT8' file='libvirt-domain' value='40' value_hex='0x28' type='virDomainProcessSignal' info='SIGRTMIN + 8'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_RT9' file='libvirt-domain' value='41' value_hex='0x29' type='virDomainProcessSignal' info='SIGRTMIN + 9'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_SEGV' file='libvirt-domain' value='11' value_hex='0xb' type='virDomainProcessSignal' info='SIGSEGV'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_STKFLT' file='libvirt-domain' value='16' value_hex='0x10' type='virDomainProcessSignal' info='Not in POSIX (SIGSTKFLT on Linux'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_STOP' file='libvirt-domain' value='19' value_hex='0x13' type='virDomainProcessSignal' info='SIGSTOP'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_SYS' file='libvirt-domain' value='31' value_hex='0x1f' type='virDomainProcessSignal' info='SIGSYS (also known as SIGUNUSED on Linux)'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_TERM' file='libvirt-domain' value='15' value_hex='0xf' type='virDomainProcessSignal' info='SIGTERM'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_TRAP' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainProcessSignal' info='SIGTRAP'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_TSTP' file='libvirt-domain' value='20' value_hex='0x14' type='virDomainProcessSignal' info='SIGTSTP'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_TTIN' file='libvirt-domain' value='21' value_hex='0x15' type='virDomainProcessSignal' info='SIGTTIN'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_TTOU' file='libvirt-domain' value='22' value_hex='0x16' type='virDomainProcessSignal' info='SIGTTOU'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_URG' file='libvirt-domain' value='23' value_hex='0x17' type='virDomainProcessSignal' info='SIGURG'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_USR1' file='libvirt-domain' value='10' value_hex='0xa' type='virDomainProcessSignal' info='SIGUSR1'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_USR2' file='libvirt-domain' value='12' value_hex='0xc' type='virDomainProcessSignal' info='SIGUSR2'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_VTALRM' file='libvirt-domain' value='26' value_hex='0x1a' type='virDomainProcessSignal' info='SIGVTALRM'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_WINCH' file='libvirt-domain' value='28' value_hex='0x1c' type='virDomainProcessSignal' info='Not in POSIX (SIGWINCH on Linux)'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_XCPU' file='libvirt-domain' value='24' value_hex='0x18' type='virDomainProcessSignal' info='SIGXCPU'/>
    <enum name='VIR_DOMAIN_PROCESS_SIGNAL_XFSZ' file='libvirt-domain' value='25' value_hex='0x19' type='virDomainProcessSignal' info='SIGXFSZ'/>
    <enum name='VIR_DOMAIN_REBOOT_ACPI_POWER_BTN' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainRebootFlagValues' info='Send ACPI event'/>
    <enum name='VIR_DOMAIN_REBOOT_DEFAULT' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainRebootFlagValues' info='hypervisor choice'/>
    <enum name='VIR_DOMAIN_REBOOT_GUEST_AGENT' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainRebootFlagValues' info='Use guest agent'/>
    <enum name='VIR_DOMAIN_REBOOT_INITCTL' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainRebootFlagValues' info='Use initctl'/>
    <enum name='VIR_DOMAIN_REBOOT_PARAVIRT' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainRebootFlagValues' info='Use paravirt guest control'/>
    <enum name='VIR_DOMAIN_REBOOT_SIGNAL' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainRebootFlagValues' info='Send a signal'/>
    <enum name='VIR_DOMAIN_RUNNING' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainState' info='the domain is running'/>
    <enum name='VIR_DOMAIN_RUNNING_BOOTED' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainRunningReason' info='normal startup from boot'/>
    <enum name='VIR_DOMAIN_RUNNING_CRASHED' file='libvirt-domain' value='9' value_hex='0x9' type='virDomainRunningReason' info='resumed from crashed'/>
    <enum name='VIR_DOMAIN_RUNNING_FROM_SNAPSHOT' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainRunningReason' info='restored from snapshot'/>
    <enum name='VIR_DOMAIN_RUNNING_LAST' file='libvirt-domain' value='11' value_hex='0xb' type='virDomainRunningReason'/>
    <enum name='VIR_DOMAIN_RUNNING_MIGRATED' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainRunningReason' info='migrated from another host'/>
    <enum name='VIR_DOMAIN_RUNNING_MIGRATION_CANCELED' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainRunningReason' info='returned from migration'/>
    <enum name='VIR_DOMAIN_RUNNING_POSTCOPY' file='libvirt-domain' value='10' value_hex='0xa' type='virDomainRunningReason' info='running in post-copy migration mode'/>
    <enum name='VIR_DOMAIN_RUNNING_RESTORED' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainRunningReason' info='restored from a state file'/>
    <enum name='VIR_DOMAIN_RUNNING_SAVE_CANCELED' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainRunningReason' info='returned from failed save process'/>
    <enum name='VIR_DOMAIN_RUNNING_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainRunningReason'/>
    <enum name='VIR_DOMAIN_RUNNING_UNPAUSED' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainRunningReason' info='returned from paused state'/>
    <enum name='VIR_DOMAIN_RUNNING_WAKEUP' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainRunningReason' info='returned from pmsuspended due to
wakeup event'/>
    <enum name='VIR_DOMAIN_SAVE_BYPASS_CACHE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainSaveRestoreFlags' info='Avoid file system cache pollution'/>
    <enum name='VIR_DOMAIN_SAVE_IMAGE_XML_SECURE' file='libvirt-domain' value='VIR_DOMAIN_XML_SECURE' type='virDomainSaveImageXMLFlags' info='dump security sensitive information too'/>
    <enum name='VIR_DOMAIN_SAVE_PAUSED' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainSaveRestoreFlags' info='Favor paused over running'/>
    <enum name='VIR_DOMAIN_SAVE_RUNNING' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainSaveRestoreFlags' info='Favor running over paused'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_BOOLEAN' file='libvirt-domain' value='VIR_TYPED_PARAM_BOOLEAN' type='virSchedParameterType'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_DOUBLE' file='libvirt-domain' value='VIR_TYPED_PARAM_DOUBLE' type='virSchedParameterType'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_INT' file='libvirt-domain' value='VIR_TYPED_PARAM_INT' type='virSchedParameterType'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_LLONG' file='libvirt-domain' value='VIR_TYPED_PARAM_LLONG' type='virSchedParameterType'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_UINT' file='libvirt-domain' value='VIR_TYPED_PARAM_UINT' type='virSchedParameterType'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_ULLONG' file='libvirt-domain' value='VIR_TYPED_PARAM_ULLONG' type='virSchedParameterType'/>
    <enum name='VIR_DOMAIN_SHUTDOWN' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainState' info='the domain is being shut down'/>
    <enum name='VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainShutdownFlagValues' info='Send ACPI event'/>
    <enum name='VIR_DOMAIN_SHUTDOWN_DEFAULT' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainShutdownFlagValues' info='hypervisor choice'/>
    <enum name='VIR_DOMAIN_SHUTDOWN_GUEST_AGENT' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainShutdownFlagValues' info='Use guest agent'/>
    <enum name='VIR_DOMAIN_SHUTDOWN_INITCTL' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainShutdownFlagValues' info='Use initctl'/>
    <enum name='VIR_DOMAIN_SHUTDOWN_LAST' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainShutdownReason'/>
    <enum name='VIR_DOMAIN_SHUTDOWN_PARAVIRT' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainShutdownFlagValues' info='Use paravirt guest control'/>
    <enum name='VIR_DOMAIN_SHUTDOWN_SIGNAL' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainShutdownFlagValues' info='Send a signal'/>
    <enum name='VIR_DOMAIN_SHUTDOWN_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainShutdownReason' info='the reason is unknown'/>
    <enum name='VIR_DOMAIN_SHUTDOWN_USER' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainShutdownReason' info='shutting down on user request'/>
    <enum name='VIR_DOMAIN_SHUTOFF' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainState' info='the domain is shut off'/>
    <enum name='VIR_DOMAIN_SHUTOFF_CRASHED' file='libvirt-domain' value='3' value_hex='0x3' type='virDomainShutoffReason' info='domain crashed'/>
    <enum name='VIR_DOMAIN_SHUTOFF_DAEMON' file='libvirt-domain' value='8' value_hex='0x8' type='virDomainShutoffReason' info='daemon decides to kill domain
during reconnection processing'/>
    <enum name='VIR_DOMAIN_SHUTOFF_DESTROYED' file='libvirt-domain' value='2' value_hex='0x2' type='virDomainShutoffReason' info='forced poweroff'/>
    <enum name='VIR_DOMAIN_SHUTOFF_FAILED' file='libvirt-domain' value='6' value_hex='0x6' type='virDomainShutoffReason' info='domain failed to start'/>
    <enum name='VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT' file='libvirt-domain' value='7' value_hex='0x7' type='virDomainShutoffReason' info='restored from a snapshot which was
 taken while domain was shutoff'/>
    <enum name='VIR_DOMAIN_SHUTOFF_LAST' file='libvirt-domain' value='9' value_hex='0x9' type='virDomainShutoffReason'/>
    <enum name='VIR_DOMAIN_SHUTOFF_MIGRATED' file='libvirt-domain' value='4' value_hex='0x4' type='virDomainShutoffReason' info='migrated to another host'/>
    <enum name='VIR_DOMAIN_SHUTOFF_SAVED' file='libvirt-domain' value='5' value_hex='0x5' type='virDomainShutoffReason' info='saved to a file'/>
    <enum name='VIR_DOMAIN_SHUTOFF_SHUTDOWN' file='libvirt-domain' value='1' value_hex='0x1' type='virDomainShutoffReason' info='normal shutdown'/>
    <enum name='VIR_DOMAIN_SHUTOFF_UNKNOWN' file='libvirt-domain' value='0' value_hex='0x0' type='virDomainShutoffReason' info='the reason is unknown'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC' file='libvirt-domain-snapshot' value='128' value_hex='0x80' value_bitshift='7' type='virDomainSnapshotCreateFlags' info='atomically avoid
partial changes'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT' file='libvirt-domain-snapshot' value='2' value_hex='0x2' value_bitshift='1' type='virDomainSnapshotCreateFlags' info='With redefine, make
snapshot current'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY' file='libvirt-domain-snapshot' value='16' value_hex='0x10' value_bitshift='4' type='virDomainSnapshotCreateFlags' info='disk snapshot, not
full system'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_HALT' file='libvirt-domain-snapshot' value='8' value_hex='0x8' value_bitshift='3' type='virDomainSnapshotCreateFlags' info='Stop running guest
after snapshot'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_LIVE' file='libvirt-domain-snapshot' value='256' value_hex='0x100' value_bitshift='8' type='virDomainSnapshotCreateFlags' info='create the snapshot
while the guest is
running'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA' file='libvirt-domain-snapshot' value='4' value_hex='0x4' value_bitshift='2' type='virDomainSnapshotCreateFlags' info='Make snapshot without
remembering it'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE' file='libvirt-domain-snapshot' value='64' value_hex='0x40' value_bitshift='6' type='virDomainSnapshotCreateFlags' info='use guest agent to
quiesce all mounted
file systems within
the domain'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE' file='libvirt-domain-snapshot' value='1' value_hex='0x1' value_bitshift='0' type='virDomainSnapshotCreateFlags' info='Restore or alter
metadata'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT' file='libvirt-domain-snapshot' value='32' value_hex='0x20' value_bitshift='5' type='virDomainSnapshotCreateFlags' info='reuse any existing
external files'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE' file='libvirt-domain-snapshot' value='512' value_hex='0x200' value_bitshift='9' type='virDomainSnapshotCreateFlags' info='validate the XML
against the schema'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN' file='libvirt-domain-snapshot' value='1' value_hex='0x1' value_bitshift='0' type='virDomainSnapshotDeleteFlags' info='Also delete children'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY' file='libvirt-domain-snapshot' value='4' value_hex='0x4' value_bitshift='2' type='virDomainSnapshotDeleteFlags' info='Delete just children'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY' file='libvirt-domain-snapshot' value='2' value_hex='0x2' value_bitshift='1' type='virDomainSnapshotDeleteFlags' info='Delete just metadata'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE' file='libvirt-domain-snapshot' value='64' value_hex='0x40' value_bitshift='6' type='virDomainSnapshotListFlags' info='Filter by snapshots
taken while guest was
active, and with
memory state'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS' file='libvirt-domain-snapshot' value='1' value_hex='0x1' value_bitshift='0' type='virDomainSnapshotListFlags' info='List all descendants,
not just children, when
listing a snapshot For historical reasons, groups do not use contiguous bits.'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY' file='libvirt-domain-snapshot' value='128' value_hex='0x80' value_bitshift='7' type='virDomainSnapshotListFlags' info='Filter by snapshots
taken while guest was
active, but without
memory state'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL' file='libvirt-domain-snapshot' value='512' value_hex='0x200' value_bitshift='9' type='virDomainSnapshotListFlags' info='Filter by snapshots
that use files external
to disk images'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE' file='libvirt-domain-snapshot' value='32' value_hex='0x20' value_bitshift='5' type='virDomainSnapshotListFlags' info='Filter by snapshots
taken while guest was
shut off'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL' file='libvirt-domain-snapshot' value='256' value_hex='0x100' value_bitshift='8' type='virDomainSnapshotListFlags' info='Filter by snapshots
stored internal to
disk images'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_LEAVES' file='libvirt-domain-snapshot' value='4' value_hex='0x4' value_bitshift='2' type='virDomainSnapshotListFlags' info='Filter by snapshots
with no children'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_METADATA' file='libvirt-domain-snapshot' value='2' value_hex='0x2' value_bitshift='1' type='virDomainSnapshotListFlags' info='Filter by snapshots
which have metadata'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES' file='libvirt-domain-snapshot' value='8' value_hex='0x8' value_bitshift='3' type='virDomainSnapshotListFlags' info='Filter by snapshots
that have children'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA' file='libvirt-domain-snapshot' value='16' value_hex='0x10' value_bitshift='4' type='virDomainSnapshotListFlags' info='Filter by snapshots
with no metadata'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_ROOTS' file='libvirt-domain-snapshot' value='1' value_hex='0x1' value_bitshift='0' type='virDomainSnapshotListFlags' info='Filter by snapshots
with no parents, when
listing a domain'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_LIST_TOPOLOGICAL' file='libvirt-domain-snapshot' value='1024' value_hex='0x400' value_bitshift='10' type='virDomainSnapshotListFlags' info='Ensure parents occur
before children in
the resulting list'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_REVERT_FORCE' file='libvirt-domain-snapshot' value='4' value_hex='0x4' value_bitshift='2' type='virDomainSnapshotRevertFlags' info='Allow risky reverts'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED' file='libvirt-domain-snapshot' value='2' value_hex='0x2' value_bitshift='1' type='virDomainSnapshotRevertFlags' info='Pause after revert'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING' file='libvirt-domain-snapshot' value='1' value_hex='0x1' value_bitshift='0' type='virDomainSnapshotRevertFlags' info='Run after revert'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_XML_SECURE' file='libvirt-domain-snapshot' value='VIR_DOMAIN_XML_SECURE' type='virDomainSnapshotXMLFlags' info='dump security sensitive information too'/>
    <enum name='VIR_DOMAIN_START_AUTODESTROY' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainCreateFlags' info='Automatically kill guest when virConnectPtr is closed'/>
    <enum name='VIR_DOMAIN_START_BYPASS_CACHE' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainCreateFlags' info='Avoid file system cache pollution'/>
    <enum name='VIR_DOMAIN_START_FORCE_BOOT' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainCreateFlags' info='Boot, discarding any managed save'/>
    <enum name='VIR_DOMAIN_START_PAUSED' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainCreateFlags' info='Launch guest in paused state'/>
    <enum name='VIR_DOMAIN_START_VALIDATE' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainCreateFlags' info='Validate the XML document against schema'/>
    <enum name='VIR_DOMAIN_STATS_BALLOON' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainStatsTypes' info='return domain balloon info'/>
    <enum name='VIR_DOMAIN_STATS_BLOCK' file='libvirt-domain' value='32' value_hex='0x20' value_bitshift='5' type='virDomainStatsTypes' info='return domain block info'/>
    <enum name='VIR_DOMAIN_STATS_CPU_TOTAL' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainStatsTypes' info='return domain CPU info'/>
    <enum name='VIR_DOMAIN_STATS_INTERFACE' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainStatsTypes' info='return domain interfaces info'/>
    <enum name='VIR_DOMAIN_STATS_IOTHREAD' file='libvirt-domain' value='128' value_hex='0x80' value_bitshift='7' type='virDomainStatsTypes' info='return iothread poll info'/>
    <enum name='VIR_DOMAIN_STATS_MEMORY' file='libvirt-domain' value='256' value_hex='0x100' value_bitshift='8' type='virDomainStatsTypes' info='return domain memory info'/>
    <enum name='VIR_DOMAIN_STATS_PERF' file='libvirt-domain' value='64' value_hex='0x40' value_bitshift='6' type='virDomainStatsTypes' info='return domain perf event info'/>
    <enum name='VIR_DOMAIN_STATS_STATE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainStatsTypes' info='return domain state'/>
    <enum name='VIR_DOMAIN_STATS_VCPU' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainStatsTypes' info='return domain virtual CPU info'/>
    <enum name='VIR_DOMAIN_TIME_SYNC' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainSetTimeFlags' info='Re-sync domain time from domain&apos;s RTC'/>
    <enum name='VIR_DOMAIN_UNDEFINE_CHECKPOINTS_METADATA' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainUndefineFlagsValues' info='If last use of domain,
then also remove any
checkpoint metadata Future undefine control flags should come here.'/>
    <enum name='VIR_DOMAIN_UNDEFINE_KEEP_NVRAM' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainUndefineFlagsValues' info='Keep nvram file'/>
    <enum name='VIR_DOMAIN_UNDEFINE_MANAGED_SAVE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainUndefineFlagsValues' info='Also remove any
managed save'/>
    <enum name='VIR_DOMAIN_UNDEFINE_NVRAM' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainUndefineFlagsValues' info='Also remove any
nvram file'/>
    <enum name='VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainUndefineFlagsValues' info='If last use of domain,
then also remove any
snapshot metadata'/>
    <enum name='VIR_DOMAIN_VCPU_CONFIG' file='libvirt-domain' value='VIR_DOMAIN_AFFECT_CONFIG' type='virDomainVcpuFlags'/>
    <enum name='VIR_DOMAIN_VCPU_CURRENT' file='libvirt-domain' value='VIR_DOMAIN_AFFECT_CURRENT' type='virDomainVcpuFlags' info='See virDomainModificationImpact for these flags.'/>
    <enum name='VIR_DOMAIN_VCPU_GUEST' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainVcpuFlags' info='Max rather than current count'/>
    <enum name='VIR_DOMAIN_VCPU_HOTPLUGGABLE' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainVcpuFlags' info='Modify state of the cpu in the guest'/>
    <enum name='VIR_DOMAIN_VCPU_LIVE' file='libvirt-domain' value='VIR_DOMAIN_AFFECT_LIVE' type='virDomainVcpuFlags'/>
    <enum name='VIR_DOMAIN_VCPU_MAXIMUM' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainVcpuFlags' info='Additionally, these flags may be bitwise-OR&apos;d in.'/>
    <enum name='VIR_DOMAIN_XML_INACTIVE' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainXMLFlags' info='dump inactive domain information'/>
    <enum name='VIR_DOMAIN_XML_MIGRATABLE' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainXMLFlags' info='dump XML suitable for migration'/>
    <enum name='VIR_DOMAIN_XML_SECURE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainXMLFlags' info='dump security sensitive information too'/>
    <enum name='VIR_DOMAIN_XML_UPDATE_CPU' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainXMLFlags' info='update guest CPU requirements according to host CPU'/>
    <enum name='VIR_DUMP_BYPASS_CACHE' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainCoreDumpFlags' info='avoid file system cache pollution'/>
    <enum name='VIR_DUMP_CRASH' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainCoreDumpFlags' info='crash after dump'/>
    <enum name='VIR_DUMP_LIVE' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainCoreDumpFlags' info='live dump'/>
    <enum name='VIR_DUMP_MEMORY_ONLY' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainCoreDumpFlags' info='use dump-guest-memory'/>
    <enum name='VIR_DUMP_RESET' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainCoreDumpFlags' info='reset domain after dump finishes'/>
    <enum name='VIR_ERR_ACCESS_DENIED' file='virterror' value='88' value_hex='0x58' type='virErrorNumber' info='operation on the object/resource
was denied'/>
    <enum name='VIR_ERR_AGENT_UNRESPONSIVE' file='virterror' value='86' value_hex='0x56' type='virErrorNumber' info='guest agent is unresponsive,
not running or not usable'/>
    <enum name='VIR_ERR_AGENT_UNSYNCED' file='virterror' value='97' value_hex='0x61' type='virErrorNumber' info='guest agent replies with wrong id
to guest-sync command (DEPRECATED)'/>
    <enum name='VIR_ERR_ARGUMENT_UNSUPPORTED' file='virterror' value='74' value_hex='0x4a' type='virErrorNumber' info='valid API use but unsupported by
the given driver'/>
    <enum name='VIR_ERR_AUTH_CANCELLED' file='virterror' value='79' value_hex='0x4f' type='virErrorNumber' info='authentication cancelled'/>
    <enum name='VIR_ERR_AUTH_FAILED' file='virterror' value='45' value_hex='0x2d' type='virErrorNumber' info='authentication failed'/>
    <enum name='VIR_ERR_AUTH_UNAVAILABLE' file='virterror' value='94' value_hex='0x5e' type='virErrorNumber' info='authentication unavailable'/>
    <enum name='VIR_ERR_BLOCK_COPY_ACTIVE' file='virterror' value='83' value_hex='0x53' type='virErrorNumber' info='action prevented by block copy job'/>
    <enum name='VIR_ERR_BUILD_FIREWALL' file='virterror' value='63' value_hex='0x3f' type='virErrorNumber' info='nw filter pool not found'/>
    <enum name='VIR_ERR_CALL_FAILED' file='virterror' value='26' value_hex='0x1a' type='virErrorNumber' info='not supported by the drivers
(DEPRECATED)'/>
    <enum name='VIR_ERR_CONFIG_UNSUPPORTED' file='virterror' value='67' value_hex='0x43' type='virErrorNumber' info='unsupported configuration
construct'/>
    <enum name='VIR_ERR_CONF_SYNTAX' file='virterror' value='33' value_hex='0x21' type='virErrorNumber' info='failed to parse the syntax of a
conf file'/>
    <enum name='VIR_ERR_CPU_INCOMPATIBLE' file='virterror' value='91' value_hex='0x5b' type='virErrorNumber' info='given CPU is incompatible with host CPU'/>
    <enum name='VIR_ERR_DBUS_SERVICE' file='virterror' value='89' value_hex='0x59' type='virErrorNumber' info='error from a dbus service'/>
    <enum name='VIR_ERR_DEVICE_MISSING' file='virterror' value='99' value_hex='0x63' type='virErrorNumber' info='fail to find the desired device'/>
    <enum name='VIR_ERR_DOMAIN_LAST' file='virterror' value='72' value_hex='0x48' type='virErrorDomain'/>
    <enum name='VIR_ERR_DOM_EXIST' file='virterror' value='28' value_hex='0x1c' type='virErrorNumber' info='the domain already exist'/>
    <enum name='VIR_ERR_DRIVER_FULL' file='virterror' value='25' value_hex='0x19' type='virErrorNumber' info='too many drivers registered'/>
    <enum name='VIR_ERR_ERROR' file='virterror' value='2' value_hex='0x2' type='virErrorLevel' info='An error'/>
    <enum name='VIR_ERR_GET_FAILED' file='virterror' value='10' value_hex='0xa' type='virErrorNumber' info='a HTTP GET command to failed'/>
    <enum name='VIR_ERR_GNUTLS_ERROR' file='virterror' value='40' value_hex='0x28' type='virErrorNumber' info='error from a GNUTLS call'/>
    <enum name='VIR_ERR_HOOK_SCRIPT_FAILED' file='virterror' value='70' value_hex='0x46' type='virErrorNumber' info='a synchronous hook script failed'/>
    <enum name='VIR_ERR_HTTP_ERROR' file='virterror' value='12' value_hex='0xc' type='virErrorNumber' info='unexpected HTTP error code'/>
    <enum name='VIR_ERR_INTERNAL_ERROR' file='virterror' value='1' value_hex='0x1' type='virErrorNumber' info='internal error'/>
    <enum name='VIR_ERR_INVALID_ARG' file='virterror' value='8' value_hex='0x8' type='virErrorNumber' info='invalid function argument'/>
    <enum name='VIR_ERR_INVALID_CONN' file='virterror' value='6' value_hex='0x6' type='virErrorNumber' info='invalid connection object'/>
    <enum name='VIR_ERR_INVALID_DOMAIN' file='virterror' value='7' value_hex='0x7' type='virErrorNumber' info='invalid domain object'/>
    <enum name='VIR_ERR_INVALID_DOMAIN_CHECKPOINT' file='virterror' value='102' value_hex='0x66' type='virErrorNumber' info='invalid domain checkpoint'/>
    <enum name='VIR_ERR_INVALID_DOMAIN_SNAPSHOT' file='virterror' value='71' value_hex='0x47' type='virErrorNumber' info='invalid domain snapshot'/>
    <enum name='VIR_ERR_INVALID_INTERFACE' file='virterror' value='58' value_hex='0x3a' type='virErrorNumber' info='invalid interface object'/>
    <enum name='VIR_ERR_INVALID_MAC' file='virterror' value='44' value_hex='0x2c' type='virErrorNumber' info='invalid MAC address'/>
    <enum name='VIR_ERR_INVALID_NETWORK' file='virterror' value='36' value_hex='0x24' type='virErrorNumber' info='invalid network object'/>
    <enum name='VIR_ERR_INVALID_NETWORK_PORT' file='virterror' value='105' value_hex='0x69' type='virErrorNumber' info='invalid network port object'/>
    <enum name='VIR_ERR_INVALID_NODE_DEVICE' file='virterror' value='52' value_hex='0x34' type='virErrorNumber' info='invalid node device object'/>
    <enum name='VIR_ERR_INVALID_NWFILTER' file='virterror' value='61' value_hex='0x3d' type='virErrorNumber' info='invalid nwfilter object'/>
    <enum name='VIR_ERR_INVALID_NWFILTER_BINDING' file='virterror' value='100' value_hex='0x64' type='virErrorNumber' info='invalid nwfilter binding'/>
    <enum name='VIR_ERR_INVALID_SECRET' file='virterror' value='65' value_hex='0x41' type='virErrorNumber' info='invalid secret'/>
    <enum name='VIR_ERR_INVALID_STORAGE_POOL' file='virterror' value='46' value_hex='0x2e' type='virErrorNumber' info='invalid storage pool object'/>
    <enum name='VIR_ERR_INVALID_STORAGE_VOL' file='virterror' value='47' value_hex='0x2f' type='virErrorNumber' info='invalid storage vol object'/>
    <enum name='VIR_ERR_INVALID_STREAM' file='virterror' value='73' value_hex='0x49' type='virErrorNumber' info='stream pointer not valid'/>
    <enum name='VIR_ERR_LIBSSH' file='virterror' value='98' value_hex='0x62' type='virErrorNumber' info='error in libssh transport driver'/>
    <enum name='VIR_ERR_MIGRATE_FINISH_OK' file='virterror' value='93' value_hex='0x5d' type='virErrorNumber' info='Finish API succeeded but it is expected to return NULL'/>
    <enum name='VIR_ERR_MIGRATE_PERSIST_FAILED' file='virterror' value='69' value_hex='0x45' type='virErrorNumber' info='a migration worked, but making the
VM persist on the dest host failed'/>
    <enum name='VIR_ERR_MIGRATE_UNSAFE' file='virterror' value='81' value_hex='0x51' type='virErrorNumber' info='Migration is not safe'/>
    <enum name='VIR_ERR_MULTIPLE_INTERFACES' file='virterror' value='59' value_hex='0x3b' type='virErrorNumber' info='more than one matching interface
found'/>
    <enum name='VIR_ERR_NETWORK_EXIST' file='virterror' value='37' value_hex='0x25' type='virErrorNumber' info='the network already exist'/>
    <enum name='VIR_ERR_NETWORK_PORT_EXIST' file='virterror' value='106' value_hex='0x6a' type='virErrorNumber' info='the network port already exist'/>
    <enum name='VIR_ERR_NONE' file='virterror' value='0' value_hex='0x0' type='virErrorLevel'/>
    <enum name='VIR_ERR_NO_CLIENT' file='virterror' value='96' value_hex='0x60' type='virErrorNumber' info='Client was not found'/>
    <enum name='VIR_ERR_NO_CONNECT' file='virterror' value='5' value_hex='0x5' type='virErrorNumber' info='can&apos;t connect to hypervisor'/>
    <enum name='VIR_ERR_NO_DEVICE' file='virterror' value='23' value_hex='0x17' type='virErrorNumber' info='missing domain devices information'/>
    <enum name='VIR_ERR_NO_DOMAIN' file='virterror' value='42' value_hex='0x2a' type='virErrorNumber' info='domain not found or unexpectedly
disappeared'/>
    <enum name='VIR_ERR_NO_DOMAIN_BACKUP' file='virterror' value='104' value_hex='0x68' type='virErrorNumber' info='domain backup job id not found'/>
    <enum name='VIR_ERR_NO_DOMAIN_CHECKPOINT' file='virterror' value='103' value_hex='0x67' type='virErrorNumber' info='domain checkpoint not found'/>
    <enum name='VIR_ERR_NO_DOMAIN_METADATA' file='virterror' value='80' value_hex='0x50' type='virErrorNumber' info='The metadata is not present'/>
    <enum name='VIR_ERR_NO_DOMAIN_SNAPSHOT' file='virterror' value='72' value_hex='0x48' type='virErrorNumber' info='domain snapshot not found'/>
    <enum name='VIR_ERR_NO_HOSTNAME' file='virterror' value='108' value_hex='0x6c' type='virErrorNumber' info='no domain&apos;s hostname found'/>
    <enum name='VIR_ERR_NO_INTERFACE' file='virterror' value='57' value_hex='0x39' type='virErrorNumber' info='interface driver not running'/>
    <enum name='VIR_ERR_NO_KERNEL' file='virterror' value='17' value_hex='0x11' type='virErrorNumber' info='missing kernel information'/>
    <enum name='VIR_ERR_NO_MEMORY' file='virterror' value='2' value_hex='0x2' type='virErrorNumber' info='memory allocation failure'/>
    <enum name='VIR_ERR_NO_NAME' file='virterror' value='21' value_hex='0x15' type='virErrorNumber' info='missing domain name information'/>
    <enum name='VIR_ERR_NO_NETWORK' file='virterror' value='43' value_hex='0x2b' type='virErrorNumber' info='network not found'/>
    <enum name='VIR_ERR_NO_NETWORK_PORT' file='virterror' value='107' value_hex='0x6b' type='virErrorNumber' info='network port not found'/>
    <enum name='VIR_ERR_NO_NODE_DEVICE' file='virterror' value='53' value_hex='0x35' type='virErrorNumber' info='node device not found'/>
    <enum name='VIR_ERR_NO_NWFILTER' file='virterror' value='62' value_hex='0x3e' type='virErrorNumber' info='nw filter pool not found'/>
    <enum name='VIR_ERR_NO_NWFILTER_BINDING' file='virterror' value='101' value_hex='0x65' type='virErrorNumber' info='no nwfilter binding'/>
    <enum name='VIR_ERR_NO_OS' file='virterror' value='22' value_hex='0x16' type='virErrorNumber' info='missing domain OS information'/>
    <enum name='VIR_ERR_NO_ROOT' file='virterror' value='18' value_hex='0x12' type='virErrorNumber' info='missing root device information'/>
    <enum name='VIR_ERR_NO_SECRET' file='virterror' value='66' value_hex='0x42' type='virErrorNumber' info='secret not found'/>
    <enum name='VIR_ERR_NO_SECURITY_MODEL' file='virterror' value='54' value_hex='0x36' type='virErrorNumber' info='security model not found'/>
    <enum name='VIR_ERR_NO_SERVER' file='virterror' value='95' value_hex='0x5f' type='virErrorNumber' info='Server was not found'/>
    <enum name='VIR_ERR_NO_SOURCE' file='virterror' value='19' value_hex='0x13' type='virErrorNumber' info='missing source device information'/>
    <enum name='VIR_ERR_NO_STORAGE_POOL' file='virterror' value='49' value_hex='0x31' type='virErrorNumber' info='storage pool not found'/>
    <enum name='VIR_ERR_NO_STORAGE_VOL' file='virterror' value='50' value_hex='0x32' type='virErrorNumber' info='storage volume not found'/>
    <enum name='VIR_ERR_NO_SUPPORT' file='virterror' value='3' value_hex='0x3' type='virErrorNumber' info='no support for this function'/>
    <enum name='VIR_ERR_NO_TARGET' file='virterror' value='20' value_hex='0x14' type='virErrorNumber' info='missing target device information'/>
    <enum name='VIR_ERR_NO_XEN' file='virterror' value='14' value_hex='0xe' type='virErrorNumber' info='could not open Xen hypervisor
control'/>
    <enum name='VIR_ERR_NO_XENSTORE' file='virterror' value='24' value_hex='0x18' type='virErrorNumber' info='could not open Xen Store control'/>
    <enum name='VIR_ERR_NUMBER_LAST' file='virterror' value='109' value_hex='0x6d' type='virErrorNumber'/>
    <enum name='VIR_ERR_OK' file='virterror' value='0' value_hex='0x0' type='virErrorNumber'/>
    <enum name='VIR_ERR_OPEN_FAILED' file='virterror' value='30' value_hex='0x1e' type='virErrorNumber' info='failed to open a conf file'/>
    <enum name='VIR_ERR_OPERATION_ABORTED' file='virterror' value='78' value_hex='0x4e' type='virErrorNumber' info='operation on a domain was
canceled/aborted by user'/>
    <enum name='VIR_ERR_OPERATION_DENIED' file='virterror' value='29' value_hex='0x1d' type='virErrorNumber' info='operation forbidden on read-only
connections'/>
    <enum name='VIR_ERR_OPERATION_FAILED' file='virterror' value='9' value_hex='0x9' type='virErrorNumber' info='a command to hypervisor failed'/>
    <enum name='VIR_ERR_OPERATION_INVALID' file='virterror' value='55' value_hex='0x37' type='virErrorNumber' info='operation is not applicable at this
time'/>
    <enum name='VIR_ERR_OPERATION_TIMEOUT' file='virterror' value='68' value_hex='0x44' type='virErrorNumber' info='timeout occurred during operation'/>
    <enum name='VIR_ERR_OPERATION_UNSUPPORTED' file='virterror' value='84' value_hex='0x54' type='virErrorNumber' info='The requested operation is not
supported'/>
    <enum name='VIR_ERR_OS_TYPE' file='virterror' value='16' value_hex='0x10' type='virErrorNumber' info='unknown OS type'/>
    <enum name='VIR_ERR_OVERFLOW' file='virterror' value='82' value_hex='0x52' type='virErrorNumber' info='integer overflow'/>
    <enum name='VIR_ERR_PARSE_FAILED' file='virterror' value='32' value_hex='0x20' type='virErrorNumber' info='failed to parse a conf file'/>
    <enum name='VIR_ERR_POST_FAILED' file='virterror' value='11' value_hex='0xb' type='virErrorNumber' info='a HTTP POST command to failed'/>
    <enum name='VIR_ERR_READ_FAILED' file='virterror' value='31' value_hex='0x1f' type='virErrorNumber' info='failed to read a conf file'/>
    <enum name='VIR_ERR_RESOURCE_BUSY' file='virterror' value='87' value_hex='0x57' type='virErrorNumber' info='resource is already in use'/>
    <enum name='VIR_ERR_RPC' file='virterror' value='39' value_hex='0x27' type='virErrorNumber' info='some sort of RPC error'/>
    <enum name='VIR_ERR_SEXPR_SERIAL' file='virterror' value='13' value_hex='0xd' type='virErrorNumber' info='failure to serialize an S-Expr'/>
    <enum name='VIR_ERR_SNAPSHOT_REVERT_RISKY' file='virterror' value='77' value_hex='0x4d' type='virErrorNumber' info='force was not requested for a
risky domain snapshot revert'/>
    <enum name='VIR_ERR_SSH' file='virterror' value='85' value_hex='0x55' type='virErrorNumber' info='error in ssh transport driver'/>
    <enum name='VIR_ERR_STORAGE_POOL_BUILT' file='virterror' value='76' value_hex='0x4c' type='virErrorNumber' info='storage pool already built'/>
    <enum name='VIR_ERR_STORAGE_PROBE_FAILED' file='virterror' value='75' value_hex='0x4b' type='virErrorNumber' info='storage pool probe failed'/>
    <enum name='VIR_ERR_STORAGE_VOL_EXIST' file='virterror' value='90' value_hex='0x5a' type='virErrorNumber' info='the storage vol already exists'/>
    <enum name='VIR_ERR_SYSTEM_ERROR' file='virterror' value='38' value_hex='0x26' type='virErrorNumber' info='general system call failure'/>
    <enum name='VIR_ERR_UNKNOWN_HOST' file='virterror' value='4' value_hex='0x4' type='virErrorNumber' info='could not resolve hostname'/>
    <enum name='VIR_ERR_WARNING' file='virterror' value='1' value_hex='0x1' type='virErrorLevel' info='A simple warning'/>
    <enum name='VIR_ERR_WRITE_FAILED' file='virterror' value='34' value_hex='0x22' type='virErrorNumber' info='failed to write a conf file'/>
    <enum name='VIR_ERR_XEN_CALL' file='virterror' value='15' value_hex='0xf' type='virErrorNumber' info='failure doing an hypervisor call'/>
    <enum name='VIR_ERR_XML_DETAIL' file='virterror' value='35' value_hex='0x23' type='virErrorNumber' info='detail of an XML error'/>
    <enum name='VIR_ERR_XML_ERROR' file='virterror' value='27' value_hex='0x1b' type='virErrorNumber' info='an XML description is not well
formed or broken'/>
    <enum name='VIR_ERR_XML_INVALID_SCHEMA' file='virterror' value='92' value_hex='0x5c' type='virErrorNumber' info='XML document doesn&apos;t validate against schema'/>
    <enum name='VIR_EVENT_HANDLE_ERROR' file='libvirt-event' value='4' value_hex='0x4' value_bitshift='2' type='virEventHandleType'/>
    <enum name='VIR_EVENT_HANDLE_HANGUP' file='libvirt-event' value='8' value_hex='0x8' value_bitshift='3' type='virEventHandleType'/>
    <enum name='VIR_EVENT_HANDLE_READABLE' file='libvirt-event' value='1' value_hex='0x1' value_bitshift='0' type='virEventHandleType'/>
    <enum name='VIR_EVENT_HANDLE_WRITABLE' file='libvirt-event' value='2' value_hex='0x2' value_bitshift='1' type='virEventHandleType'/>
    <enum name='VIR_FROM_ACCESS' file='virterror' value='55' value_hex='0x37' type='virErrorDomain' info='Error from access control manager'/>
    <enum name='VIR_FROM_ADMIN' file='virterror' value='62' value_hex='0x3e' type='virErrorDomain' info='Error from admin backend'/>
    <enum name='VIR_FROM_AUDIT' file='virterror' value='36' value_hex='0x24' type='virErrorDomain' info='Error from auditing subsystem'/>
    <enum name='VIR_FROM_AUTH' file='virterror' value='46' value_hex='0x2e' type='virErrorDomain' info='Error from auth handling'/>
    <enum name='VIR_FROM_BHYVE' file='virterror' value='57' value_hex='0x39' type='virErrorDomain' info='Error from bhyve driver'/>
    <enum name='VIR_FROM_BPF' file='virterror' value='71' value_hex='0x47' type='virErrorDomain' info='Error from BPF code'/>
    <enum name='VIR_FROM_CAPABILITIES' file='virterror' value='44' value_hex='0x2c' type='virErrorDomain' info='Error from capabilities'/>
    <enum name='VIR_FROM_CGROUP' file='virterror' value='54' value_hex='0x36' type='virErrorDomain' info='Error from cgroups'/>
    <enum name='VIR_FROM_CONF' file='virterror' value='9' value_hex='0x9' type='virErrorDomain' info='Error in the configuration file handling'/>
    <enum name='VIR_FROM_CPU' file='virterror' value='31' value_hex='0x1f' type='virErrorDomain' info='Error from CPU driver'/>
    <enum name='VIR_FROM_CRYPTO' file='virterror' value='58' value_hex='0x3a' type='virErrorDomain' info='Error from crypto code'/>
    <enum name='VIR_FROM_DBUS' file='virterror' value='47' value_hex='0x2f' type='virErrorDomain' info='Error from DBus'/>
    <enum name='VIR_FROM_DEVICE' file='virterror' value='49' value_hex='0x31' type='virErrorDomain' info='Error from Device'/>
    <enum name='VIR_FROM_DOM' file='virterror' value='6' value_hex='0x6' type='virErrorDomain' info='Error when operating on a domain'/>
    <enum name='VIR_FROM_DOMAIN' file='virterror' value='20' value_hex='0x14' type='virErrorDomain' info='Error from domain config'/>
    <enum name='VIR_FROM_DOMAIN_CHECKPOINT' file='virterror' value='69' value_hex='0x45' type='virErrorDomain' info='Error from domain checkpoint'/>
    <enum name='VIR_FROM_DOMAIN_SNAPSHOT' file='virterror' value='35' value_hex='0x23' type='virErrorDomain' info='Error from domain snapshot'/>
    <enum name='VIR_FROM_ESX' file='virterror' value='28' value_hex='0x1c' type='virErrorDomain' info='Error from ESX driver'/>
    <enum name='VIR_FROM_EVENT' file='virterror' value='40' value_hex='0x28' type='virErrorDomain' info='Error from event loop impl'/>
    <enum name='VIR_FROM_FIREWALL' file='virterror' value='59' value_hex='0x3b' type='virErrorDomain' info='Error from firewall'/>
    <enum name='VIR_FROM_FIREWALLD' file='virterror' value='68' value_hex='0x44' type='virErrorDomain' info='Error from firewalld'/>
    <enum name='VIR_FROM_HOOK' file='virterror' value='34' value_hex='0x22' type='virErrorDomain' info='Error from Synchronous hooks'/>
    <enum name='VIR_FROM_HYPERV' file='virterror' value='43' value_hex='0x2b' type='virErrorDomain' info='Error from Hyper-V driver'/>
    <enum name='VIR_FROM_IDENTITY' file='virterror' value='53' value_hex='0x35' type='virErrorDomain' info='Error from identity code'/>
    <enum name='VIR_FROM_INITCTL' file='virterror' value='52' value_hex='0x34' type='virErrorDomain' info='Error from initctl device communication'/>
    <enum name='VIR_FROM_INTERFACE' file='virterror' value='26' value_hex='0x1a' type='virErrorDomain' info='Error when operating on an interface'/>
    <enum name='VIR_FROM_LIBSSH' file='virterror' value='66' value_hex='0x42' type='virErrorDomain' info='Error from libssh connection transport'/>
    <enum name='VIR_FROM_LIBXL' file='virterror' value='41' value_hex='0x29' type='virErrorDomain' info='Error from libxenlight driver'/>
    <enum name='VIR_FROM_LOCKING' file='virterror' value='42' value_hex='0x2a' type='virErrorDomain' info='Error from lock manager'/>
    <enum name='VIR_FROM_LOCKSPACE' file='virterror' value='51' value_hex='0x33' type='virErrorDomain' info='Error from lockspace'/>
    <enum name='VIR_FROM_LOGGING' file='virterror' value='63' value_hex='0x3f' type='virErrorDomain' info='Error from log manager'/>
    <enum name='VIR_FROM_LXC' file='virterror' value='17' value_hex='0x11' type='virErrorDomain' info='Error from Linux Container driver'/>
    <enum name='VIR_FROM_NET' file='virterror' value='11' value_hex='0xb' type='virErrorDomain' info='Error when operating on a network'/>
    <enum name='VIR_FROM_NETWORK' file='virterror' value='19' value_hex='0x13' type='virErrorDomain' info='Error from network config'/>
    <enum name='VIR_FROM_NODEDEV' file='virterror' value='22' value_hex='0x16' type='virErrorDomain' info='Error from node device monitor'/>
    <enum name='VIR_FROM_NONE' file='virterror' value='0' value_hex='0x0' type='virErrorDomain'/>
    <enum name='VIR_FROM_NWFILTER' file='virterror' value='33' value_hex='0x21' type='virErrorDomain' info='Error from network filter driver'/>
    <enum name='VIR_FROM_ONE' file='virterror' value='27' value_hex='0x1b' type='virErrorDomain' info='The OpenNebula driver no longer exists.
Retained for ABI/API compat only'/>
    <enum name='VIR_FROM_OPENVZ' file='virterror' value='14' value_hex='0xe' type='virErrorDomain' info='Error from OpenVZ driver'/>
    <enum name='VIR_FROM_PARALLELS' file='virterror' value='48' value_hex='0x30' type='virErrorDomain' info='Error from Parallels'/>
    <enum name='VIR_FROM_PERF' file='virterror' value='65' value_hex='0x41' type='virErrorDomain' info='Error from perf'/>
    <enum name='VIR_FROM_PHYP' file='virterror' value='29' value_hex='0x1d' type='virErrorDomain' info='Error from the phyp driver, unused since 6.0.0'/>
    <enum name='VIR_FROM_POLKIT' file='virterror' value='60' value_hex='0x3c' type='virErrorDomain' info='Error from polkit code'/>
    <enum name='VIR_FROM_PROXY' file='virterror' value='8' value_hex='0x8' type='virErrorDomain' info='Error in the proxy code; unused since
0.8.6'/>
    <enum name='VIR_FROM_QEMU' file='virterror' value='10' value_hex='0xa' type='virErrorDomain' info='Error at the QEMU daemon'/>
    <enum name='VIR_FROM_REMOTE' file='virterror' value='13' value_hex='0xd' type='virErrorDomain' info='Error from remote driver'/>
    <enum name='VIR_FROM_RESCTRL' file='virterror' value='67' value_hex='0x43' type='virErrorDomain' info='Error from resource control'/>
    <enum name='VIR_FROM_RPC' file='virterror' value='7' value_hex='0x7' type='virErrorDomain' info='Error in the XML-RPC code'/>
    <enum name='VIR_FROM_SECRET' file='virterror' value='30' value_hex='0x1e' type='virErrorDomain' info='Error from secret storage'/>
    <enum name='VIR_FROM_SECURITY' file='virterror' value='24' value_hex='0x18' type='virErrorDomain' info='Error from security framework'/>
    <enum name='VIR_FROM_SEXPR' file='virterror' value='4' value_hex='0x4' type='virErrorDomain' info='Error in the S-Expression code'/>
    <enum name='VIR_FROM_SSH' file='virterror' value='50' value_hex='0x32' type='virErrorDomain' info='Error from libssh2 connection transport'/>
    <enum name='VIR_FROM_STATS_LINUX' file='virterror' value='16' value_hex='0x10' type='virErrorDomain' info='Error in the Linux Stats code'/>
    <enum name='VIR_FROM_STORAGE' file='virterror' value='18' value_hex='0x12' type='virErrorDomain' info='Error from storage driver'/>
    <enum name='VIR_FROM_STREAMS' file='virterror' value='38' value_hex='0x26' type='virErrorDomain' info='Error from I/O streams'/>
    <enum name='VIR_FROM_SYSINFO' file='virterror' value='37' value_hex='0x25' type='virErrorDomain' info='Error from sysinfo/SMBIOS'/>
    <enum name='VIR_FROM_SYSTEMD' file='virterror' value='56' value_hex='0x38' type='virErrorDomain' info='Error from systemd code'/>
    <enum name='VIR_FROM_TEST' file='virterror' value='12' value_hex='0xc' type='virErrorDomain' info='Error from test driver'/>
    <enum name='VIR_FROM_THREAD' file='virterror' value='61' value_hex='0x3d' type='virErrorDomain' info='Error from thread utils'/>
    <enum name='VIR_FROM_TPM' file='virterror' value='70' value_hex='0x46' type='virErrorDomain' info='Error from TPM'/>
    <enum name='VIR_FROM_UML' file='virterror' value='21' value_hex='0x15' type='virErrorDomain' info='Error at the UML driver; unused since 5.0.0'/>
    <enum name='VIR_FROM_URI' file='virterror' value='45' value_hex='0x2d' type='virErrorDomain' info='Error from URI handling'/>
    <enum name='VIR_FROM_VBOX' file='virterror' value='25' value_hex='0x19' type='virErrorDomain' info='Error from VirtualBox driver'/>
    <enum name='VIR_FROM_VMWARE' file='virterror' value='39' value_hex='0x27' type='virErrorDomain' info='Error from VMware driver'/>
    <enum name='VIR_FROM_XEN' file='virterror' value='1' value_hex='0x1' type='virErrorDomain' info='Error at Xen hypervisor layer'/>
    <enum name='VIR_FROM_XENAPI' file='virterror' value='32' value_hex='0x20' type='virErrorDomain' info='Error from XenAPI'/>
    <enum name='VIR_FROM_XEND' file='virterror' value='2' value_hex='0x2' type='virErrorDomain' info='Error at connection with xend daemon'/>
    <enum name='VIR_FROM_XENSTORE' file='virterror' value='3' value_hex='0x3' type='virErrorDomain' info='Error at connection with xen store'/>
    <enum name='VIR_FROM_XENXL' file='virterror' value='64' value_hex='0x40' type='virErrorDomain' info='Error from Xen xl config code'/>
    <enum name='VIR_FROM_XENXM' file='virterror' value='15' value_hex='0xf' type='virErrorDomain' info='Error at Xen XM layer'/>
    <enum name='VIR_FROM_XEN_INOTIFY' file='virterror' value='23' value_hex='0x17' type='virErrorDomain' info='Error from xen inotify layer'/>
    <enum name='VIR_FROM_XML' file='virterror' value='5' value_hex='0x5' type='virErrorDomain' info='Error in the XML code'/>
    <enum name='VIR_INTERFACE_XML_INACTIVE' file='libvirt-interface' value='1' value_hex='0x1' value_bitshift='0' type='virInterfaceXMLFlags' info='dump inactive interface information'/>
    <enum name='VIR_IP_ADDR_TYPE_IPV4' file='libvirt-network' value='0' value_hex='0x0' type='virIPAddrType'/>
    <enum name='VIR_IP_ADDR_TYPE_IPV6' file='libvirt-network' value='1' value_hex='0x1' type='virIPAddrType'/>
    <enum name='VIR_IP_ADDR_TYPE_LAST' file='libvirt-network' value='2' value_hex='0x2' type='virIPAddrType'/>
    <enum name='VIR_KEYCODE_SET_ATSET1' file='libvirt-domain' value='2' value_hex='0x2' type='virKeycodeSet'/>
    <enum name='VIR_KEYCODE_SET_ATSET2' file='libvirt-domain' value='3' value_hex='0x3' type='virKeycodeSet'/>
    <enum name='VIR_KEYCODE_SET_ATSET3' file='libvirt-domain' value='4' value_hex='0x4' type='virKeycodeSet'/>
    <enum name='VIR_KEYCODE_SET_LAST' file='libvirt-domain' value='10' value_hex='0xa' type='virKeycodeSet' info='NB: this enum value will increase over time as new events are
 added to the libvirt API. It reflects the last keycode set supported
 by this version of the libvirt API.'/>
    <enum name='VIR_KEYCODE_SET_LINUX' file='libvirt-domain' value='0' value_hex='0x0' type='virKeycodeSet'/>
    <enum name='VIR_KEYCODE_SET_OSX' file='libvirt-domain' value='5' value_hex='0x5' type='virKeycodeSet'/>
    <enum name='VIR_KEYCODE_SET_QNUM' file='libvirt-domain' value='9' value_hex='0x9' type='virKeycodeSet'/>
    <enum name='VIR_KEYCODE_SET_USB' file='libvirt-domain' value='7' value_hex='0x7' type='virKeycodeSet'/>
    <enum name='VIR_KEYCODE_SET_WIN32' file='libvirt-domain' value='8' value_hex='0x8' type='virKeycodeSet'/>
    <enum name='VIR_KEYCODE_SET_XT' file='libvirt-domain' value='1' value_hex='0x1' type='virKeycodeSet'/>
    <enum name='VIR_KEYCODE_SET_XT_KBD' file='libvirt-domain' value='6' value_hex='0x6' type='virKeycodeSet'/>
    <enum name='VIR_MEMORY_PHYSICAL' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainMemoryFlags' info='addresses are physical addresses'/>
    <enum name='VIR_MEMORY_VIRTUAL' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainMemoryFlags' info='addresses are virtual addresses'/>
    <enum name='VIR_MIGRATE_ABORT_ON_ERROR' file='libvirt-domain' value='4096' value_hex='0x1000' value_bitshift='12' type='virDomainMigrateFlags' info='Cancel migration if a soft error (such as I/O error) happens during
 migration.'/>
    <enum name='VIR_MIGRATE_AUTO_CONVERGE' file='libvirt-domain' value='8192' value_hex='0x2000' value_bitshift='13' type='virDomainMigrateFlags' info='Enable algorithms that ensure a live migration will eventually converge.
 This usually means the domain will be slowed down to make sure it does
 not change its memory faster than a hypervisor can transfer the changed
 memory to the destination host. VIR_MIGRATE_PARAM_AUTO_CONVERGE_*
 parameters can be used to tune the algorithm.'/>
    <enum name='VIR_MIGRATE_CHANGE_PROTECTION' file='libvirt-domain' value='256' value_hex='0x100' value_bitshift='8' type='virDomainMigrateFlags' info='Protect against domain configuration changes during the migration
 process. This flag is used automatically when both sides support it.
 Explicitly setting this flag will cause migration to fail if either the
 source or the destination does not support it.'/>
    <enum name='VIR_MIGRATE_COMPRESSED' file='libvirt-domain' value='2048' value_hex='0x800' value_bitshift='11' type='virDomainMigrateFlags' info='Compress migration data. The compression methods can be specified using
 VIR_MIGRATE_PARAM_COMPRESSION. A hypervisor default method will be used
 if this parameter is omitted. Individual compression methods can be
 tuned via their specific VIR_MIGRATE_PARAM_COMPRESSION_* parameters.'/>
    <enum name='VIR_MIGRATE_LIVE' file='libvirt-domain' value='1' value_hex='0x1' value_bitshift='0' type='virDomainMigrateFlags' info='Do not pause the domain during migration. The domain&apos;s memory will
 be transferred to the destination host while the domain is running.
 The migration may never converge if the domain is changing its memory
 faster then it can be transferred. The domain can be manually paused
 anytime during migration using virDomainSuspend.'/>
    <enum name='VIR_MIGRATE_NON_SHARED_DISK' file='libvirt-domain' value='64' value_hex='0x40' value_bitshift='6' type='virDomainMigrateFlags' info='Migrate full disk images in addition to domain&apos;s memory. By default
 only non-shared non-readonly disk images are transferred. The
 VIR_MIGRATE_PARAM_MIGRATE_DISKS parameter can be used to specify which
 disks should be migrated.

 This flag and VIR_MIGRATE_NON_SHARED_INC are mutually exclusive.'/>
    <enum name='VIR_MIGRATE_NON_SHARED_INC' file='libvirt-domain' value='128' value_hex='0x80' value_bitshift='7' type='virDomainMigrateFlags' info='Migrate disk images in addition to domain&apos;s memory. This is similar to
 VIR_MIGRATE_NON_SHARED_DISK, but only the top level of each disk&apos;s
 backing chain is copied. That is, the rest of the backing chain is
 expected to be present on the destination and to be exactly the same as
 on the source host.

 This flag and VIR_MIGRATE_NON_SHARED_DISK are mutually exclusive.'/>
    <enum name='VIR_MIGRATE_OFFLINE' file='libvirt-domain' value='1024' value_hex='0x400' value_bitshift='10' type='virDomainMigrateFlags' info='Migrate a domain definition without starting the domain on the
 destination and without stopping it on the source host. Offline
 migration requires VIR_MIGRATE_PERSIST_DEST to be set.

 Offline migration may not copy disk storage or any other file based
 storage (such as UEFI variables).'/>
    <enum name='VIR_MIGRATE_PARALLEL' file='libvirt-domain' value='131072' value_hex='0x20000' value_bitshift='17' type='virDomainMigrateFlags' info='Send memory pages to the destination host through several network
 connections. See VIR_MIGRATE_PARAM_PARALLEL_* parameters for
 configuring the parallel migration.'/>
    <enum name='VIR_MIGRATE_PAUSED' file='libvirt-domain' value='32' value_hex='0x20' value_bitshift='5' type='virDomainMigrateFlags' info='Leave the domain suspended on the destination host. virDomainResume (on
 the virDomainPtr returned by the migration API) has to be called
 explicitly to resume domain&apos;s virtual CPUs.'/>
    <enum name='VIR_MIGRATE_PEER2PEER' file='libvirt-domain' value='2' value_hex='0x2' value_bitshift='1' type='virDomainMigrateFlags' info='Tell the source libvirtd to connect directly to the destination host.
 Without this flag the client (e.g., virsh) connects to both hosts and
 controls the migration process. In peer-to-peer mode, the source
 libvirtd controls the migration by calling the destination daemon
 directly.'/>
    <enum name='VIR_MIGRATE_PERSIST_DEST' file='libvirt-domain' value='8' value_hex='0x8' value_bitshift='3' type='virDomainMigrateFlags' info='Define the domain as persistent on the destination host after successful
 migration. If the domain was persistent on the source host and
 VIR_MIGRATE_UNDEFINE_SOURCE is not used, it will end up persistent on
 both hosts.'/>
    <enum name='VIR_MIGRATE_POSTCOPY' file='libvirt-domain' value='32768' value_hex='0x8000' value_bitshift='15' type='virDomainMigrateFlags' info='Setting the VIR_MIGRATE_POSTCOPY flag tells libvirt to enable post-copy
 migration. However, the migration will start normally and
 virDomainMigrateStartPostCopy needs to be called to switch it into the
 post-copy mode. See virDomainMigrateStartPostCopy for more details.'/>
    <enum name='VIR_MIGRATE_RDMA_PIN_ALL' file='libvirt-domain' value='16384' value_hex='0x4000' value_bitshift='14' type='virDomainMigrateFlags' info='This flag can be used with RDMA migration (i.e., when
 VIR_MIGRATE_PARAM_URI starts with &quot;rdma://&quot;) to tell the hypervisor
 to pin all domain&apos;s memory at once before migration starts rather then
 letting it pin memory pages as needed. This means that all memory pages
 belonging to the domain will be locked in host&apos;s memory and the host
 will not be allowed to swap them out.

 For QEMU/KVM this requires hard_limit memory tuning element (in the
 domain XML) to be used and set to the maximum memory configured for the
 domain plus any memory consumed by the QEMU process itself. Beware of
 setting the memory limit too high (and thus allowing the domain to lock
 most of the host&apos;s memory). Doing so may be dangerous to both the
 domain and the host itself since the host&apos;s kernel may run out of
 memory.'/>
    <enum name='VIR_MIGRATE_TLS' file='libvirt-domain' value='65536' value_hex='0x10000' value_bitshift='16' type='virDomainMigrateFlags' info='Setting the VIR_MIGRATE_TLS flag will cause the migration to attempt
 to use the TLS environment configured by the hypervisor in order to
 perform the migration. If incorrectly configured on either source or
 destination, the migration will fail.'/>
    <enum name='VIR_MIGRATE_TUNNELLED' file='libvirt-domain' value='4' value_hex='0x4' value_bitshift='2' type='virDomainMigrateFlags' info='Tunnel migration data over libvirtd connection. Without this flag the
 source hypervisor sends migration data directly to the destination
 hypervisor. This flag can only be used when VIR_MIGRATE_PEER2PEER is
 set as well.

 Note the less-common spelling that we&apos;re stuck with:
 VIR_MIGRATE_TUNNELLED should be VIR_MIGRATE_TUNNELED.'/>
    <enum name='VIR_MIGRATE_UNDEFINE_SOURCE' file='libvirt-domain' value='16' value_hex='0x10' value_bitshift='4' type='virDomainMigrateFlags' info='Undefine the domain on the source host once migration successfully
 finishes.'/>
    <enum name='VIR_MIGRATE_UNSAFE' file='libvirt-domain' value='512' value_hex='0x200' value_bitshift='9' type='virDomainMigrateFlags' info='Force migration even if it is considered unsafe. In some cases libvirt
 may refuse to migrate the domain because doing so may lead to potential
 problems such as data corruption, and thus the migration is considered
 unsafe. For a QEMU domain this may happen if the domain uses disks
 without explicitly setting cache mode to &quot;none&quot;. Migrating such domains
 is unsafe unless the disk images are stored on coherent clustered
 filesystem, such as GFS2 or GPFS.'/>
    <enum name='VIR_NETWORK_EVENT_DEFINED' file='libvirt-network' value='0' value_hex='0x0' type='virNetworkEventLifecycleType'/>
    <enum name='VIR_NETWORK_EVENT_ID_LAST' file='libvirt-network' value='1' value_hex='0x1' type='virNetworkEventID' info='NB: this enum value will increase over time as new events are
 added to the libvirt API. It reflects the last event ID supported
 by this version of the libvirt API.'/>
    <enum name='VIR_NETWORK_EVENT_ID_LIFECYCLE' file='libvirt-network' value='0' value_hex='0x0' type='virNetworkEventID' info='virConnectNetworkEventLifecycleCallback'/>
    <enum name='VIR_NETWORK_EVENT_LAST' file='libvirt-network' value='4' value_hex='0x4' type='virNetworkEventLifecycleType'/>
    <enum name='VIR_NETWORK_EVENT_STARTED' file='libvirt-network' value='2' value_hex='0x2' type='virNetworkEventLifecycleType'/>
    <enum name='VIR_NETWORK_EVENT_STOPPED' file='libvirt-network' value='3' value_hex='0x3' type='virNetworkEventLifecycleType'/>
    <enum name='VIR_NETWORK_EVENT_UNDEFINED' file='libvirt-network' value='1' value_hex='0x1' type='virNetworkEventLifecycleType'/>
    <enum name='VIR_NETWORK_PORT_CREATE_RECLAIM' file='libvirt-network' value='1' value_hex='0x1' value_bitshift='0' type='virNetworkPortCreateFlags' info='reclaim existing used resources'/>
    <enum name='VIR_NETWORK_SECTION_BRIDGE' file='libvirt-network' value='1' value_hex='0x1' type='virNetworkUpdateSection' info='&lt;bridge&gt;'/>
    <enum name='VIR_NETWORK_SECTION_DNS_HOST' file='libvirt-network' value='10' value_hex='0xa' type='virNetworkUpdateSection' info='&lt;dns&gt;/&lt;host&gt;'/>
    <enum name='VIR_NETWORK_SECTION_DNS_SRV' file='libvirt-network' value='12' value_hex='0xc' type='virNetworkUpdateSection' info='&lt;dns&gt;/&lt;srv&gt;'/>
    <enum name='VIR_NETWORK_SECTION_DNS_TXT' file='libvirt-network' value='11' value_hex='0xb' type='virNetworkUpdateSection' info='&lt;dns&gt;/&lt;txt&gt;'/>
    <enum name='VIR_NETWORK_SECTION_DOMAIN' file='libvirt-network' value='2' value_hex='0x2' type='virNetworkUpdateSection' info='&lt;domain&gt;'/>
    <enum name='VIR_NETWORK_SECTION_FORWARD' file='libvirt-network' value='6' value_hex='0x6' type='virNetworkUpdateSection' info='&lt;forward&gt;'/>
    <enum name='VIR_NETWORK_SECTION_FORWARD_INTERFACE' file='libvirt-network' value='7' value_hex='0x7' type='virNetworkUpdateSection' info='&lt;forward&gt;/&lt;interface&gt;'/>
    <enum name='VIR_NETWORK_SECTION_FORWARD_PF' file='libvirt-network' value='8' value_hex='0x8' type='virNetworkUpdateSection' info='&lt;forward&gt;/&lt;pf&gt;'/>
    <enum name='VIR_NETWORK_SECTION_IP' file='libvirt-network' value='3' value_hex='0x3' type='virNetworkUpdateSection' info='&lt;ip&gt;'/>
    <enum name='VIR_NETWORK_SECTION_IP_DHCP_HOST' file='libvirt-network' value='4' value_hex='0x4' type='virNetworkUpdateSection' info='&lt;ip&gt;/&lt;dhcp&gt;/&lt;host&gt;'/>
    <enum name='VIR_NETWORK_SECTION_IP_DHCP_RANGE' file='libvirt-network' value='5' value_hex='0x5' type='virNetworkUpdateSection' info='&lt;ip&gt;/&lt;dhcp&gt;/&lt;range&gt;'/>
    <enum name='VIR_NETWORK_SECTION_LAST' file='libvirt-network' value='13' value_hex='0xd' type='virNetworkUpdateSection'/>
    <enum name='VIR_NETWORK_SECTION_NONE' file='libvirt-network' value='0' value_hex='0x0' type='virNetworkUpdateSection' info='(invalid)'/>
    <enum name='VIR_NETWORK_SECTION_PORTGROUP' file='libvirt-network' value='9' value_hex='0x9' type='virNetworkUpdateSection' info='&lt;portgroup&gt;'/>
    <enum name='VIR_NETWORK_UPDATE_AFFECT_CONFIG' file='libvirt-network' value='2' value_hex='0x2' value_bitshift='1' type='virNetworkUpdateFlags' info='affect persistent config only'/>
    <enum name='VIR_NETWORK_UPDATE_AFFECT_CURRENT' file='libvirt-network' value='0' value_hex='0x0' type='virNetworkUpdateFlags' info='affect live if network is active,
config if it&apos;s not active'/>
    <enum name='VIR_NETWORK_UPDATE_AFFECT_LIVE' file='libvirt-network' value='1' value_hex='0x1' value_bitshift='0' type='virNetworkUpdateFlags' info='affect live state of network only'/>
    <enum name='VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST' file='libvirt-network' value='4' value_hex='0x4' type='virNetworkUpdateCommand' info='add an element at start of list'/>
    <enum name='VIR_NETWORK_UPDATE_COMMAND_ADD_LAST' file='libvirt-network' value='3' value_hex='0x3' type='virNetworkUpdateCommand' info='add an element at end of list'/>
    <enum name='VIR_NETWORK_UPDATE_COMMAND_DELETE' file='libvirt-network' value='2' value_hex='0x2' type='virNetworkUpdateCommand' info='delete an existing element'/>
    <enum name='VIR_NETWORK_UPDATE_COMMAND_LAST' file='libvirt-network' value='5' value_hex='0x5' type='virNetworkUpdateCommand'/>
    <enum name='VIR_NETWORK_UPDATE_COMMAND_MODIFY' file='libvirt-network' value='1' value_hex='0x1' type='virNetworkUpdateCommand' info='modify an existing element'/>
    <enum name='VIR_NETWORK_UPDATE_COMMAND_NONE' file='libvirt-network' value='0' value_hex='0x0' type='virNetworkUpdateCommand' info='(invalid)'/>
    <enum name='VIR_NETWORK_XML_INACTIVE' file='libvirt-network' value='1' value_hex='0x1' value_bitshift='0' type='virNetworkXMLFlags' info='dump inactive network information'/>
    <enum name='VIR_NODE_ALLOC_PAGES_ADD' file='libvirt-host' value='0' value_hex='0x0' type='virNodeAllocPagesFlags' info='Add @pageCounts to the pages pool. This
can be used only to size up the pool.'/>
    <enum name='VIR_NODE_ALLOC_PAGES_SET' file='libvirt-host' value='1' value_hex='0x1' value_bitshift='0' type='virNodeAllocPagesFlags' info='Don&apos;t add @pageCounts, instead set
passed number of pages. This can be
used to free allocated pages.'/>
    <enum name='VIR_NODE_CPU_STATS_ALL_CPUS' file='libvirt-host' value='-1' value_hex='-0x1' type='virNodeGetCPUStatsAllCPUs'/>
    <enum name='VIR_NODE_DEVICE_EVENT_CREATED' file='libvirt-nodedev' value='0' value_hex='0x0' type='virNodeDeviceEventLifecycleType'/>
    <enum name='VIR_NODE_DEVICE_EVENT_DELETED' file='libvirt-nodedev' value='1' value_hex='0x1' type='virNodeDeviceEventLifecycleType'/>
    <enum name='VIR_NODE_DEVICE_EVENT_ID_LAST' file='libvirt-nodedev' value='2' value_hex='0x2' type='virNodeDeviceEventID' info='NB: this enum value will increase over time as new events are
 added to the libvirt API. It reflects the last event ID supported
 by this version of the libvirt API.'/>
    <enum name='VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE' file='libvirt-nodedev' value='0' value_hex='0x0' type='virNodeDeviceEventID' info='virConnectNodeDeviceEventLifecycleCallback'/>
    <enum name='VIR_NODE_DEVICE_EVENT_ID_UPDATE' file='libvirt-nodedev' value='1' value_hex='0x1' type='virNodeDeviceEventID' info='virConnectNodeDeviceEventGenericCallback'/>
    <enum name='VIR_NODE_DEVICE_EVENT_LAST' file='libvirt-nodedev' value='2' value_hex='0x2' type='virNodeDeviceEventLifecycleType'/>
    <enum name='VIR_NODE_MEMORY_STATS_ALL_CELLS' file='libvirt-host' value='-1' value_hex='-0x1' type='virNodeGetMemoryStatsAllCells'/>
    <enum name='VIR_NODE_SUSPEND_TARGET_DISK' file='libvirt-host' value='1' value_hex='0x1' type='virNodeSuspendTarget'/>
    <enum name='VIR_NODE_SUSPEND_TARGET_HYBRID' file='libvirt-host' value='2' value_hex='0x2' type='virNodeSuspendTarget'/>
    <enum name='VIR_NODE_SUSPEND_TARGET_LAST' file='libvirt-host' value='3' value_hex='0x3' type='virNodeSuspendTarget' info='This constant is subject to change'/>
    <enum name='VIR_NODE_SUSPEND_TARGET_MEM' file='libvirt-host' value='0' value_hex='0x0' type='virNodeSuspendTarget'/>
    <enum name='VIR_SECRET_EVENT_DEFINED' file='libvirt-secret' value='0' value_hex='0x0' type='virSecretEventLifecycleType'/>
    <enum name='VIR_SECRET_EVENT_ID_LAST' file='libvirt-secret' value='2' value_hex='0x2' type='virSecretEventID' info='NB: this enum value will increase over time as new events are
 added to the libvirt API. It reflects the last event ID supported
 by this version of the libvirt API.'/>
    <enum name='VIR_SECRET_EVENT_ID_LIFECYCLE' file='libvirt-secret' value='0' value_hex='0x0' type='virSecretEventID' info='virConnectSecretEventLifecycleCallback'/>
    <enum name='VIR_SECRET_EVENT_ID_VALUE_CHANGED' file='libvirt-secret' value='1' value_hex='0x1' type='virSecretEventID' info='virConnectSecretEventGenericCallback'/>
    <enum name='VIR_SECRET_EVENT_LAST' file='libvirt-secret' value='2' value_hex='0x2' type='virSecretEventLifecycleType'/>
    <enum name='VIR_SECRET_EVENT_UNDEFINED' file='libvirt-secret' value='1' value_hex='0x1' type='virSecretEventLifecycleType'/>
    <enum name='VIR_SECRET_USAGE_TYPE_CEPH' file='libvirt-secret' value='2' value_hex='0x2' type='virSecretUsageType'/>
    <enum name='VIR_SECRET_USAGE_TYPE_ISCSI' file='libvirt-secret' value='3' value_hex='0x3' type='virSecretUsageType'/>
    <enum name='VIR_SECRET_USAGE_TYPE_LAST' file='libvirt-secret' value='6' value_hex='0x6' type='virSecretUsageType' info='NB: this enum value will increase over time as new events are
 added to the libvirt API. It reflects the last secret owner ID
 supported by this version of the libvirt API.'/>
    <enum name='VIR_SECRET_USAGE_TYPE_NONE' file='libvirt-secret' value='0' value_hex='0x0' type='virSecretUsageType'/>
    <enum name='VIR_SECRET_USAGE_TYPE_TLS' file='libvirt-secret' value='4' value_hex='0x4' type='virSecretUsageType'/>
    <enum name='VIR_SECRET_USAGE_TYPE_VOLUME' file='libvirt-secret' value='1' value_hex='0x1' type='virSecretUsageType'/>
    <enum name='VIR_SECRET_USAGE_TYPE_VTPM' file='libvirt-secret' value='5' value_hex='0x5' type='virSecretUsageType'/>
    <enum name='VIR_STORAGE_POOL_BUILDING' file='libvirt-storage' value='1' value_hex='0x1' type='virStoragePoolState' info='Initializing pool, not available'/>
    <enum name='VIR_STORAGE_POOL_BUILD_NEW' file='libvirt-storage' value='0' value_hex='0x0' type='virStoragePoolBuildFlags' info='Regular build from scratch'/>
    <enum name='VIR_STORAGE_POOL_BUILD_NO_OVERWRITE' file='libvirt-storage' value='4' value_hex='0x4' value_bitshift='2' type='virStoragePoolBuildFlags' info='Do not overwrite existing pool'/>
    <enum name='VIR_STORAGE_POOL_BUILD_OVERWRITE' file='libvirt-storage' value='8' value_hex='0x8' value_bitshift='3' type='virStoragePoolBuildFlags' info='Overwrite data'/>
    <enum name='VIR_STORAGE_POOL_BUILD_REPAIR' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStoragePoolBuildFlags' info='Repair / reinitialize'/>
    <enum name='VIR_STORAGE_POOL_BUILD_RESIZE' file='libvirt-storage' value='2' value_hex='0x2' value_bitshift='1' type='virStoragePoolBuildFlags' info='Extend existing pool'/>
    <enum name='VIR_STORAGE_POOL_CREATE_NORMAL' file='libvirt-storage' value='0' value_hex='0x0' type='virStoragePoolCreateFlags' info='Create the pool and perform pool build without any flags'/>
    <enum name='VIR_STORAGE_POOL_CREATE_WITH_BUILD' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStoragePoolCreateFlags' info='Create the pool and perform pool build using the
 VIR_STORAGE_POOL_BUILD_OVERWRITE flag. This is mutually
 exclusive to VIR_STORAGE_POOL_CREATE_WITH_BUILD_NO_OVERWRITE'/>
    <enum name='VIR_STORAGE_POOL_CREATE_WITH_BUILD_NO_OVERWRITE' file='libvirt-storage' value='4' value_hex='0x4' value_bitshift='2' type='virStoragePoolCreateFlags'/>
    <enum name='VIR_STORAGE_POOL_CREATE_WITH_BUILD_OVERWRITE' file='libvirt-storage' value='2' value_hex='0x2' value_bitshift='1' type='virStoragePoolCreateFlags' info='Create the pool and perform pool build using the
 VIR_STORAGE_POOL_BUILD_NO_OVERWRITE flag. This is mutually
 exclusive to VIR_STORAGE_POOL_CREATE_WITH_BUILD_OVERWRITE'/>
    <enum name='VIR_STORAGE_POOL_DEGRADED' file='libvirt-storage' value='3' value_hex='0x3' type='virStoragePoolState' info='Running degraded'/>
    <enum name='VIR_STORAGE_POOL_DELETE_NORMAL' file='libvirt-storage' value='0' value_hex='0x0' type='virStoragePoolDeleteFlags' info='Delete metadata only    (fast)'/>
    <enum name='VIR_STORAGE_POOL_DELETE_ZEROED' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStoragePoolDeleteFlags' info='Clear all data to zeros (slow)'/>
    <enum name='VIR_STORAGE_POOL_EVENT_CREATED' file='libvirt-storage' value='4' value_hex='0x4' type='virStoragePoolEventLifecycleType'/>
    <enum name='VIR_STORAGE_POOL_EVENT_DEFINED' file='libvirt-storage' value='0' value_hex='0x0' type='virStoragePoolEventLifecycleType'/>
    <enum name='VIR_STORAGE_POOL_EVENT_DELETED' file='libvirt-storage' value='5' value_hex='0x5' type='virStoragePoolEventLifecycleType'/>
    <enum name='VIR_STORAGE_POOL_EVENT_ID_LAST' file='libvirt-storage' value='2' value_hex='0x2' type='virStoragePoolEventID' info='NB: this enum value will increase over time as new events are
 added to the libvirt API. It reflects the last event ID supported
 by this version of the libvirt API.'/>
    <enum name='VIR_STORAGE_POOL_EVENT_ID_LIFECYCLE' file='libvirt-storage' value='0' value_hex='0x0' type='virStoragePoolEventID' info='virConnectStoragePoolEventLifecycleCallback'/>
    <enum name='VIR_STORAGE_POOL_EVENT_ID_REFRESH' file='libvirt-storage' value='1' value_hex='0x1' type='virStoragePoolEventID' info='virConnectStoragePoolEventGenericCallback'/>
    <enum name='VIR_STORAGE_POOL_EVENT_LAST' file='libvirt-storage' value='6' value_hex='0x6' type='virStoragePoolEventLifecycleType'/>
    <enum name='VIR_STORAGE_POOL_EVENT_STARTED' file='libvirt-storage' value='2' value_hex='0x2' type='virStoragePoolEventLifecycleType'/>
    <enum name='VIR_STORAGE_POOL_EVENT_STOPPED' file='libvirt-storage' value='3' value_hex='0x3' type='virStoragePoolEventLifecycleType'/>
    <enum name='VIR_STORAGE_POOL_EVENT_UNDEFINED' file='libvirt-storage' value='1' value_hex='0x1' type='virStoragePoolEventLifecycleType'/>
    <enum name='VIR_STORAGE_POOL_INACCESSIBLE' file='libvirt-storage' value='4' value_hex='0x4' type='virStoragePoolState' info='Running, but not accessible'/>
    <enum name='VIR_STORAGE_POOL_INACTIVE' file='libvirt-storage' value='0' value_hex='0x0' type='virStoragePoolState' info='Not running'/>
    <enum name='VIR_STORAGE_POOL_RUNNING' file='libvirt-storage' value='2' value_hex='0x2' type='virStoragePoolState' info='Running normally'/>
    <enum name='VIR_STORAGE_POOL_STATE_LAST' file='libvirt-storage' value='5' value_hex='0x5' type='virStoragePoolState'/>
    <enum name='VIR_STORAGE_VOL_BLOCK' file='libvirt-storage' value='1' value_hex='0x1' type='virStorageVolType' info='Block based volumes'/>
    <enum name='VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStorageVolCreateFlags'/>
    <enum name='VIR_STORAGE_VOL_CREATE_REFLINK' file='libvirt-storage' value='2' value_hex='0x2' value_bitshift='1' type='virStorageVolCreateFlags' info='perform a btrfs lightweight copy'/>
    <enum name='VIR_STORAGE_VOL_DELETE_NORMAL' file='libvirt-storage' value='0' value_hex='0x0' type='virStorageVolDeleteFlags' info='Delete metadata only    (fast)'/>
    <enum name='VIR_STORAGE_VOL_DELETE_WITH_SNAPSHOTS' file='libvirt-storage' value='2' value_hex='0x2' value_bitshift='1' type='virStorageVolDeleteFlags' info='Force removal of volume, even if in use'/>
    <enum name='VIR_STORAGE_VOL_DELETE_ZEROED' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStorageVolDeleteFlags' info='Clear all data to zeros (slow)'/>
    <enum name='VIR_STORAGE_VOL_DIR' file='libvirt-storage' value='2' value_hex='0x2' type='virStorageVolType' info='Directory-passthrough based volume'/>
    <enum name='VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStorageVolDownloadFlags' info='Use sparse stream'/>
    <enum name='VIR_STORAGE_VOL_FILE' file='libvirt-storage' value='0' value_hex='0x0' type='virStorageVolType' info='Regular file based volumes'/>
    <enum name='VIR_STORAGE_VOL_GET_PHYSICAL' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStorageVolInfoFlags'/>
    <enum name='VIR_STORAGE_VOL_LAST' file='libvirt-storage' value='6' value_hex='0x6' type='virStorageVolType'/>
    <enum name='VIR_STORAGE_VOL_NETDIR' file='libvirt-storage' value='4' value_hex='0x4' type='virStorageVolType' info='Network accessible directory that can
 contain other network volumes'/>
    <enum name='VIR_STORAGE_VOL_NETWORK' file='libvirt-storage' value='3' value_hex='0x3' type='virStorageVolType' info='Network volumes like RBD (RADOS Block Device)'/>
    <enum name='VIR_STORAGE_VOL_PLOOP' file='libvirt-storage' value='5' value_hex='0x5' type='virStorageVolType' info='Ploop based volumes'/>
    <enum name='VIR_STORAGE_VOL_RESIZE_ALLOCATE' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStorageVolResizeFlags' info='force allocation of new size'/>
    <enum name='VIR_STORAGE_VOL_RESIZE_DELTA' file='libvirt-storage' value='2' value_hex='0x2' value_bitshift='1' type='virStorageVolResizeFlags' info='size is relative to current'/>
    <enum name='VIR_STORAGE_VOL_RESIZE_SHRINK' file='libvirt-storage' value='4' value_hex='0x4' value_bitshift='2' type='virStorageVolResizeFlags' info='allow decrease in capacity'/>
    <enum name='VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStorageVolUploadFlags' info='Use sparse stream'/>
    <enum name='VIR_STORAGE_VOL_USE_ALLOCATION' file='libvirt-storage' value='0' value_hex='0x0' type='virStorageVolInfoFlags' info='Return the physical size in allocation'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_BSI' file='libvirt-storage' value='3' value_hex='0x3' type='virStorageVolWipeAlgorithm' info='9-pass method recommended by the
German Center of Security in
Information Technologies'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_DOD' file='libvirt-storage' value='2' value_hex='0x2' type='virStorageVolWipeAlgorithm' info='4-pass DoD 5220.22-M section
8-306 procedure'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_GUTMANN' file='libvirt-storage' value='4' value_hex='0x4' type='virStorageVolWipeAlgorithm' info='The canonical 35-pass sequence'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_LAST' file='libvirt-storage' value='10' value_hex='0xa' type='virStorageVolWipeAlgorithm' info='NB: this enum value will increase over time as new algorithms are
 added to the libvirt API. It reflects the last algorithm supported
 by this version of the libvirt API.'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_NNSA' file='libvirt-storage' value='1' value_hex='0x1' type='virStorageVolWipeAlgorithm' info='4-pass  NNSA Policy Letter
NAP-14.1-C (XVI-8)'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33' file='libvirt-storage' value='7' value_hex='0x7' type='virStorageVolWipeAlgorithm' info='33-pass random'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7' file='libvirt-storage' value='6' value_hex='0x6' type='virStorageVolWipeAlgorithm' info='7-pass random'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_RANDOM' file='libvirt-storage' value='8' value_hex='0x8' type='virStorageVolWipeAlgorithm' info='1-pass random'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER' file='libvirt-storage' value='5' value_hex='0x5' type='virStorageVolWipeAlgorithm' info='7-pass method described by
Bruce Schneier in &quot;Applied
Cryptography&quot; (1996)'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_TRIM' file='libvirt-storage' value='9' value_hex='0x9' type='virStorageVolWipeAlgorithm' info='1-pass, trim all data on the
volume by using TRIM or DISCARD'/>
    <enum name='VIR_STORAGE_VOL_WIPE_ALG_ZERO' file='libvirt-storage' value='0' value_hex='0x0' type='virStorageVolWipeAlgorithm' info='1-pass, all zeroes'/>
    <enum name='VIR_STORAGE_XML_INACTIVE' file='libvirt-storage' value='1' value_hex='0x1' value_bitshift='0' type='virStorageXMLFlags' info='dump inactive pool/volume information'/>
    <enum name='VIR_STREAM_EVENT_ERROR' file='libvirt-stream' value='4' value_hex='0x4' value_bitshift='2' type='virStreamEventType'/>
    <enum name='VIR_STREAM_EVENT_HANGUP' file='libvirt-stream' value='8' value_hex='0x8' value_bitshift='3' type='virStreamEventType'/>
    <enum name='VIR_STREAM_EVENT_READABLE' file='libvirt-stream' value='1' value_hex='0x1' value_bitshift='0' type='virStreamEventType'/>
    <enum name='VIR_STREAM_EVENT_WRITABLE' file='libvirt-stream' value='2' value_hex='0x2' value_bitshift='1' type='virStreamEventType'/>
    <enum name='VIR_STREAM_NONBLOCK' file='libvirt-stream' value='1' value_hex='0x1' value_bitshift='0' type='virStreamFlags'/>
    <enum name='VIR_STREAM_RECV_STOP_AT_HOLE' file='libvirt-stream' value='1' value_hex='0x1' value_bitshift='0' type='virStreamRecvFlagsValues'/>
    <enum name='VIR_TYPED_PARAM_BOOLEAN' file='libvirt-common' value='6' value_hex='0x6' type='virTypedParameterType' info='boolean(character) case'/>
    <enum name='VIR_TYPED_PARAM_DOUBLE' file='libvirt-common' value='5' value_hex='0x5' type='virTypedParameterType' info='double case'/>
    <enum name='VIR_TYPED_PARAM_INT' file='libvirt-common' value='1' value_hex='0x1' type='virTypedParameterType' info='integer case'/>
    <enum name='VIR_TYPED_PARAM_LAST' file='libvirt-common' value='8' value_hex='0x8' type='virTypedParameterType'/>
    <enum name='VIR_TYPED_PARAM_LLONG' file='libvirt-common' value='3' value_hex='0x3' type='virTypedParameterType' info='long long case'/>
    <enum name='VIR_TYPED_PARAM_STRING' file='libvirt-common' value='7' value_hex='0x7' type='virTypedParameterType' info='string case'/>
    <enum name='VIR_TYPED_PARAM_STRING_OKAY' file='libvirt-common' value='4' value_hex='0x4' value_bitshift='2' type='virTypedParameterFlags' info='1 &lt;&lt; 0 is reserved for virDomainModificationImpact 1 &lt;&lt; 1 is reserved for virDomainModificationImpact Older servers lacked the ability to handle string typed
 parameters.  Attempts to set a string parameter with an older
 server will fail at the client, but attempts to retrieve
 parameters must not return strings from a new server to an
 older client, so this flag exists to identify newer clients to
 newer servers.  This flag is automatically set when needed, so
 the user does not have to worry about it; however, manually
 setting the flag can be used to reject servers that cannot
 return typed strings, even if no strings would be returned.'/>
    <enum name='VIR_TYPED_PARAM_UINT' file='libvirt-common' value='2' value_hex='0x2' type='virTypedParameterType' info='unsigned integer case'/>
    <enum name='VIR_TYPED_PARAM_ULLONG' file='libvirt-common' value='4' value_hex='0x4' type='virTypedParameterType' info='unsigned long long case'/>
    <enum name='VIR_VCPU_BLOCKED' file='libvirt-domain' value='2' value_hex='0x2' type='virVcpuState' info='the virtual CPU is blocked on resource'/>
    <enum name='VIR_VCPU_LAST' file='libvirt-domain' value='3' value_hex='0x3' type='virVcpuState'/>
    <enum name='VIR_VCPU_OFFLINE' file='libvirt-domain' value='0' value_hex='0x0' type='virVcpuState' info='the virtual CPU is offline'/>
    <enum name='VIR_VCPU_RUNNING' file='libvirt-domain' value='1' value_hex='0x1' type='virVcpuState' info='the virtual CPU is running'/>
    <enum name='VIR_WAR_NO_INTERFACE' file='virterror' value='56' value_hex='0x38' type='virErrorNumber' info='failed to start interface driver'/>
    <enum name='VIR_WAR_NO_NETWORK' file='virterror' value='41' value_hex='0x29' type='virErrorNumber' info='failed to start network'/>
    <enum name='VIR_WAR_NO_NODE' file='virterror' value='51' value_hex='0x33' type='virErrorNumber' info='failed to start node driver'/>
    <enum name='VIR_WAR_NO_NWFILTER' file='virterror' value='60' value_hex='0x3c' type='virErrorNumber' info='failed to start nwfilter driver'/>
    <enum name='VIR_WAR_NO_SECRET' file='virterror' value='64' value_hex='0x40' type='virErrorNumber' info='failed to start secret storage'/>
    <enum name='VIR_WAR_NO_STORAGE' file='virterror' value='48' value_hex='0x30' type='virErrorNumber' info='failed to start storage'/>
    <struct name='virBlkioParameter' file='libvirt-domain' type='struct _virTypedParameter'>
      <field name='field' type='char field[VIR_TYPED_PARAM_FIELD_LENGTH]' info='parameter name'/>
      <field name='type' type='int' info='parameter type, virTypedParameterType'/>
      <field name='value' type='union' info='parameter value'>
        <union>
          <field name='i' type='int' info='type is INT'/>
          <field name='ui' type='unsigned int' info='type is UINT'/>
          <field name='l' type='long long int' info='type is LLONG'/>
          <field name='ul' type='unsigned long long int' info='type is ULLONG'/>
          <field name='d' type='double' info='type is DOUBLE'/>
          <field name='b' type='char' info='type is BOOLEAN'/>
          <field name='s' type='char *' info='type is STRING, may not be NULL'/>
        </union>
      </field>
    </struct>
    <typedef name='virBlkioParameterPtr' file='libvirt-domain' type='virBlkioParameter *'>
      <info><![CDATA[a virBlkioParameterPtr is a pointer to a virBlkioParameter structure. Provided for backwards compatibility; virTypedParameterPtr is the preferred alias since 0.9.2.]]></info>
    </typedef>
    <typedef name='virBlkioParameterType' file='libvirt-domain' type='enum'/>
    <typedef name='virCPUCompareResult' file='libvirt-host' type='enum'/>
    <struct name='virConnect' file='libvirt-host' type='struct _virConnect'/>
    <struct name='virConnectAuth' file='libvirt-host' type='struct _virConnectAuth'>
      <field name='credtype' type='int *' info='List of supported virConnectCredentialType values'/>
      <field name='ncredtype' type='unsigned int' info=''/>
      <field name='cb' type='virConnectAuthCallbackPtr' info='Callback used to collect credentials'/>
      <field name='cbdata' type='void *' info=''/>
    </struct>
    <typedef name='virConnectAuthPtr' file='libvirt-host' type='virConnectAuth *'/>
    <typedef name='virConnectBaselineCPUFlags' file='libvirt-host' type='enum'/>
    <typedef name='virConnectCloseReason' file='libvirt-common' type='enum'/>
    <typedef name='virConnectCompareCPUFlags' file='libvirt-host' type='enum'/>
    <struct name='virConnectCredential' file='libvirt-host' type='struct _virConnectCredential'>
      <field name='type' type='int' info='One of virConnectCredentialType constants'/>
      <field name='prompt' type='const char *' info='Prompt to show to user'/>
      <field name='challenge' type='const char *' info='Additional challenge to show'/>
      <field name='defresult' type='const char *' info='Optional default result'/>
      <field name='result' type='char *' info='Result to be filled with user response (or defresult)'/>
      <field name='resultlen' type='unsigned int' info='Length of the result'/>
    </struct>
    <typedef name='virConnectCredentialPtr' file='libvirt-host' type='virConnectCredential *'/>
    <typedef name='virConnectCredentialType' file='libvirt-host' type='enum'/>
    <typedef name='virConnectDomainEventAgentLifecycleReason' file='libvirt-domain' type='enum'/>
    <typedef name='virConnectDomainEventAgentLifecycleState' file='libvirt-domain' type='enum'/>
    <typedef name='virConnectDomainEventBlockJobStatus' file='libvirt-domain' type='enum'/>
    <typedef name='virConnectDomainEventDiskChangeReason' file='libvirt-domain' type='enum'/>
    <typedef name='virConnectFlags' file='libvirt-host' type='enum'/>
    <typedef name='virConnectGetAllDomainStatsFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virConnectListAllDomainsFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virConnectListAllInterfacesFlags' file='libvirt-interface' type='enum'/>
    <typedef name='virConnectListAllNetworksFlags' file='libvirt-network' type='enum'/>
    <typedef name='virConnectListAllNodeDeviceFlags' file='libvirt-nodedev' type='enum'/>
    <typedef name='virConnectListAllSecretsFlags' file='libvirt-secret' type='enum'/>
    <typedef name='virConnectListAllStoragePoolsFlags' file='libvirt-storage' type='enum'/>
    <typedef name='virConnectPtr' file='libvirt-host' type='virConnect *'>
      <info><![CDATA[a virConnectPtr is pointer to a virConnect private structure, this is the type used to reference a connection to the Hypervisor in the API.]]></info>
    </typedef>
    <struct name='virDomain' file='libvirt-domain' type='struct _virDomain'/>
    <typedef name='virDomainAgentResponseTimeoutValues' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBackupBeginFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBlockCommitFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBlockCopyFlags' file='libvirt-domain' type='enum'/>
    <struct name='virDomainBlockInfo' file='libvirt-domain' type='struct _virDomainBlockInfo'>
      <field name='capacity' type='unsigned long long' info='logical size in bytes of the
 image (how much storage the
 guest will see)'/>
      <field name='allocation' type='unsigned long long' info='host storage in bytes occupied
 by the image (such as highest
 allocated extent if there are no
 holes, similar to &apos;du&apos;)'/>
      <field name='physical' type='unsigned long long' info='host physical size in bytes of
 the image container (last
 offset, similar to &apos;ls&apos;)'/>
    </struct>
    <typedef name='virDomainBlockInfoPtr' file='libvirt-domain' type='virDomainBlockInfo *'/>
    <typedef name='virDomainBlockJobAbortFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBlockJobCursor' file='libvirt-domain' type='unsigned long long'/>
    <struct name='virDomainBlockJobInfo' file='libvirt-domain' type='struct _virDomainBlockJobInfo'>
      <field name='type' type='int' info='virDomainBlockJobType'/>
      <field name='bandwidth' type='unsigned long' info='The following fields provide an indication of block job progress.  @cur
 indicates the current position and will be between 0 and @end.  @end is
 the final cursor position for this operation and represents completion.
 To approximate progress, divide @cur by @end.'/>
      <field name='cur' type='virDomainBlockJobCursor' info=''/>
      <field name='end' type='virDomainBlockJobCursor' info=''/>
    </struct>
    <typedef name='virDomainBlockJobInfoFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBlockJobInfoPtr' file='libvirt-domain' type='virDomainBlockJobInfo *'/>
    <typedef name='virDomainBlockJobSetSpeedFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBlockJobType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBlockPullFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBlockRebaseFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBlockResizeFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainBlockStatsPtr' file='libvirt-domain' type='virDomainBlockStatsStruct *'>
      <info><![CDATA[A pointer to a virDomainBlockStats structure]]></info>
    </typedef>
    <struct name='virDomainBlockStatsStruct' file='libvirt-domain' type='struct _virDomainBlockStats'>
      <field name='rd_req' type='long long' info='number of read requests'/>
      <field name='rd_bytes' type='long long' info='number of read bytes'/>
      <field name='wr_req' type='long long' info='number of write requests'/>
      <field name='wr_bytes' type='long long' info='number of written bytes'/>
      <field name='errs' type='long long' info='In Xen this returns the mysterious &apos;oo_req&apos;.'/>
    </struct>
    <typedef name='virDomainBlockedReason' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainChannelFlags' file='libvirt-domain' type='enum'/>
    <struct name='virDomainCheckpoint' file='libvirt-domain-checkpoint' type='struct _virDomainCheckpoint'/>
    <typedef name='virDomainCheckpointCreateFlags' file='libvirt-domain-checkpoint' type='enum'/>
    <typedef name='virDomainCheckpointDeleteFlags' file='libvirt-domain-checkpoint' type='enum'/>
    <typedef name='virDomainCheckpointListFlags' file='libvirt-domain-checkpoint' type='enum'/>
    <typedef name='virDomainCheckpointPtr' file='libvirt-domain-checkpoint' type='virDomainCheckpoint *'>
      <info><![CDATA[A virDomainCheckpointPtr is pointer to a virDomainCheckpoint private structure, and is the type used to reference a domain checkpoint in the API.]]></info>
    </typedef>
    <typedef name='virDomainCheckpointXMLFlags' file='libvirt-domain-checkpoint' type='enum'/>
    <typedef name='virDomainConsoleFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainControlErrorReason' file='libvirt-domain' type='enum'/>
    <struct name='virDomainControlInfo' file='libvirt-domain' type='struct _virDomainControlInfo'>
      <field name='state' type='unsigned int' info='control state, one of virDomainControlState'/>
      <field name='details' type='unsigned int' info='state details, currently 0 except for ERROR
state (one of virDomainControlErrorReason)'/>
      <field name='stateTime' type='unsigned long long' info='for how long (in msec) control interface
has been in current state (except for OK
and ERROR states)'/>
    </struct>
    <typedef name='virDomainControlInfoPtr' file='libvirt-domain' type='virDomainControlInfo *'>
      <info><![CDATA[Pointer to virDomainControlInfo structure.]]></info>
    </typedef>
    <typedef name='virDomainControlState' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainCoreDumpFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainCoreDumpFormat' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainCrashedReason' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainCreateFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainDefineFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainDestroyFlagsValues' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainDeviceModifyFlags' file='libvirt-domain' type='enum'/>
    <struct name='virDomainDiskError' file='libvirt-domain' type='struct _virDomainDiskError'>
      <field name='disk' type='char *' info='disk target'/>
      <field name='error' type='int' info='virDomainDiskErrorCode'/>
    </struct>
    <typedef name='virDomainDiskErrorCode' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainDiskErrorPtr' file='libvirt-domain' type='virDomainDiskError *'/>
    <typedef name='virDomainEventCrashedDetailType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventDefinedDetailType' file='libvirt-domain' type='enum'/>
    <struct name='virDomainEventGraphicsAddress' file='libvirt-domain' type='struct _virDomainEventGraphicsAddress'>
      <field name='family' type='int' info='Address family, virDomainEventGraphicsAddressType'/>
      <field name='node' type='char *' info='Address of node (eg IP address, or UNIX path)'/>
      <field name='service' type='char *' info='Service name/number (eg TCP port, or NULL)'/>
    </struct>
    <typedef name='virDomainEventGraphicsAddressPtr' file='libvirt-domain' type='virDomainEventGraphicsAddress *'/>
    <typedef name='virDomainEventGraphicsAddressType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventGraphicsPhase' file='libvirt-domain' type='enum'/>
    <struct name='virDomainEventGraphicsSubject' file='libvirt-domain' type='struct _virDomainEventGraphicsSubject'>
      <field name='nidentity' type='int' info='Number of identities in arra'/>
      <field name='identities' type='virDomainEventGraphicsSubjectIdentityPtr' info='Array of identities for subject'/>
    </struct>
    <struct name='virDomainEventGraphicsSubjectIdentity' file='libvirt-domain' type='struct _virDomainEventGraphicsSubjectIdentity'>
      <field name='type' type='char *' info='Type of identity'/>
      <field name='name' type='char *' info='Identity value'/>
    </struct>
    <typedef name='virDomainEventGraphicsSubjectIdentityPtr' file='libvirt-domain' type='virDomainEventGraphicsSubjectIdentity *'/>
    <typedef name='virDomainEventGraphicsSubjectPtr' file='libvirt-domain' type='virDomainEventGraphicsSubject *'/>
    <typedef name='virDomainEventID' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventIOErrorAction' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventPMSuspendedDetailType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventResumedDetailType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventShutdownDetailType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventStartedDetailType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventStoppedDetailType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventSuspendedDetailType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventTrayChangeReason' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventUndefinedDetailType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainEventWatchdogAction' file='libvirt-domain' type='enum'/>
    <struct name='virDomainFSInfo' file='libvirt-domain' type='struct _virDomainFSInfo'>
      <field name='mountpoint' type='char *' info='path to mount point'/>
      <field name='name' type='char *' info='device name in the guest (e.g. &quot;sda1&quot;)'/>
      <field name='fstype' type='char *' info='filesystem type'/>
      <field name='ndevAlias' type='size_t' info='number of elements in devAlias'/>
      <field name='devAlias' type='char **' info='array of disk device aliases'/>
    </struct>
    <typedef name='virDomainFSInfoPtr' file='libvirt-domain' type='virDomainFSInfo *'/>
    <typedef name='virDomainGetHostnameFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainGetJobStatsFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainGuestInfoTypes' file='libvirt-domain' type='enum'/>
    <struct name='virDomainIOThreadInfo' file='libvirt-domain' type='struct _virDomainIOThreadInfo'>
      <field name='iothread_id' type='unsigned int' info='IOThread ID'/>
      <field name='cpumap' type='unsigned char *' info='CPU map for thread. A pointer to an array of real CPUs (in 8-bit bytes)'/>
      <field name='cpumaplen' type='int' info='cpumap size'/>
    </struct>
    <typedef name='virDomainIOThreadInfoPtr' file='libvirt-domain' type='virDomainIOThreadInfo *'/>
    <struct name='virDomainIPAddress' file='libvirt-domain' type='struct _virDomainInterfaceIPAddress'>
      <field name='type' type='int' info='virIPAddrType'/>
      <field name='addr' type='char *' info='IP address'/>
      <field name='prefix' type='unsigned int' info='IP address prefix'/>
    </struct>
    <typedef name='virDomainIPAddressPtr' file='libvirt-domain' type='virDomainIPAddress *'/>
    <struct name='virDomainInfo' file='libvirt-domain' type='struct _virDomainInfo'>
      <field name='state' type='unsigned char' info='the running state, one of virDomainState'/>
      <field name='maxMem' type='unsigned long' info='the maximum memory in KBytes allowed'/>
      <field name='memory' type='unsigned long' info='the memory in KBytes used by the domain'/>
      <field name='nrVirtCpu' type='unsigned short' info='the number of virtual CPUs for the domain'/>
      <field name='cpuTime' type='unsigned long long' info='the CPU time used in nanoseconds'/>
    </struct>
    <typedef name='virDomainInfoPtr' file='libvirt-domain' type='virDomainInfo *'>
      <info><![CDATA[a virDomainInfoPtr is a pointer to a virDomainInfo structure.]]></info>
    </typedef>
    <struct name='virDomainInterface' file='libvirt-domain' type='struct _virDomainInterface'>
      <field name='name' type='char *' info='interface name'/>
      <field name='hwaddr' type='char *' info='hardware address, may be NULL'/>
      <field name='naddrs' type='unsigned int' info='number of items in @addrs'/>
      <field name='addrs' type='virDomainIPAddressPtr' info='array of IP addresses'/>
    </struct>
    <typedef name='virDomainInterfaceAddressesSource' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainInterfacePtr' file='libvirt-domain' type='virDomainInterface *'/>
    <typedef name='virDomainInterfaceStatsPtr' file='libvirt-domain' type='virDomainInterfaceStatsStruct *'>
      <info><![CDATA[A pointer to a virDomainInterfaceStats structure]]></info>
    </typedef>
    <struct name='virDomainInterfaceStatsStruct' file='libvirt-domain' type='struct _virDomainInterfaceStats'>
      <field name='rx_bytes' type='long long' info=''/>
      <field name='rx_packets' type='long long' info=''/>
      <field name='rx_errs' type='long long' info=''/>
      <field name='rx_drop' type='long long' info=''/>
      <field name='tx_bytes' type='long long' info=''/>
      <field name='tx_packets' type='long long' info=''/>
      <field name='tx_errs' type='long long' info=''/>
      <field name='tx_drop' type='long long' info=''/>
    </struct>
    <struct name='virDomainJobInfo' file='libvirt-domain' type='struct _virDomainJobInfo'>
      <field name='type' type='int' info='Time is measured in milliseconds'/>
      <field name='timeElapsed' type='unsigned long long' info='Always set'/>
      <field name='timeRemaining' type='unsigned long long' info='Only for VIR_DOMAIN_JOB_BOUNDED Data is measured in bytes unless otherwise specified
 and is measuring the job as a whole.

 For VIR_DOMAIN_JOB_UNBOUNDED, dataTotal may be less
 than the final sum of dataProcessed + dataRemaining
 in the event that the hypervisor has to repeat some
 data, such as due to dirtied pages during migration.

 For VIR_DOMAIN_JOB_BOUNDED, dataTotal shall always
 equal the sum of dataProcessed + dataRemaining.'/>
      <field name='dataTotal' type='unsigned long long' info=''/>
      <field name='dataProcessed' type='unsigned long long' info=''/>
      <field name='dataRemaining' type='unsigned long long' info='As above, but only tracking guest memory progress'/>
      <field name='memTotal' type='unsigned long long' info=''/>
      <field name='memProcessed' type='unsigned long long' info=''/>
      <field name='memRemaining' type='unsigned long long' info='As above, but only tracking guest disk file progress'/>
      <field name='fileTotal' type='unsigned long long' info=''/>
      <field name='fileProcessed' type='unsigned long long' info=''/>
      <field name='fileRemaining' type='unsigned long long' info=''/>
    </struct>
    <typedef name='virDomainJobInfoPtr' file='libvirt-domain' type='virDomainJobInfo *'/>
    <typedef name='virDomainJobOperation' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainJobType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainLifecycle' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainLifecycleAction' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainMemoryFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainMemoryModFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainMemoryStatPtr' file='libvirt-domain' type='virDomainMemoryStatStruct *'/>
    <struct name='virDomainMemoryStatStruct' file='libvirt-domain' type='struct _virDomainMemoryStat'>
      <field name='tag' type='int' info=''/>
      <field name='val' type='unsigned long long' info=''/>
    </struct>
    <typedef name='virDomainMemoryStatTags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainMetadataType' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainMigrateFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainMigrateMaxSpeedFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainModificationImpact' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainNostateReason' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainNumatuneMemMode' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainOpenGraphicsFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainPMSuspendedDiskReason' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainPMSuspendedReason' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainPausedReason' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainProcessSignal' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainPtr' file='libvirt-domain' type='virDomain *'>
      <info><![CDATA[a virDomainPtr is pointer to a virDomain private structure, this is the type used to reference a domain in the API.]]></info>
    </typedef>
    <typedef name='virDomainRebootFlagValues' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainRunningReason' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainSaveImageXMLFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainSaveRestoreFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainSetTimeFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainSetUserPasswordFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainShutdownFlagValues' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainShutdownReason' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainShutoffReason' file='libvirt-domain' type='enum'/>
    <struct name='virDomainSnapshot' file='libvirt-domain-snapshot' type='struct _virDomainSnapshot'/>
    <typedef name='virDomainSnapshotCreateFlags' file='libvirt-domain-snapshot' type='enum'/>
    <typedef name='virDomainSnapshotDeleteFlags' file='libvirt-domain-snapshot' type='enum'/>
    <typedef name='virDomainSnapshotListFlags' file='libvirt-domain-snapshot' type='enum'/>
    <typedef name='virDomainSnapshotPtr' file='libvirt-domain-snapshot' type='virDomainSnapshot *'>
      <info><![CDATA[A virDomainSnapshotPtr is pointer to a virDomainSnapshot private structure, and is the type used to reference a domain snapshot in the API.]]></info>
    </typedef>
    <typedef name='virDomainSnapshotRevertFlags' file='libvirt-domain-snapshot' type='enum'/>
    <typedef name='virDomainSnapshotXMLFlags' file='libvirt-domain-snapshot' type='enum'/>
    <typedef name='virDomainState' file='libvirt-domain' type='enum'/>
    <struct name='virDomainStatsRecord' file='libvirt-domain' type='struct _virDomainStatsRecord'>
      <field name='dom' type='virDomainPtr' info=''/>
      <field name='params' type='virTypedParameterPtr' info=''/>
      <field name='nparams' type='int' info=''/>
    </struct>
    <typedef name='virDomainStatsRecordPtr' file='libvirt-domain' type='virDomainStatsRecord *'/>
    <typedef name='virDomainStatsTypes' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainUndefineFlagsValues' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainVcpuFlags' file='libvirt-domain' type='enum'/>
    <typedef name='virDomainXMLFlags' file='libvirt-domain' type='enum'/>
    <struct name='virError' file='virterror' type='struct _virError'>
      <field name='code' type='int' info='The error code, a virErrorNumber'/>
      <field name='domain' type='int' info='What part of the library raised this error'/>
      <field name='message' type='char *' info='human-readable informative error message'/>
      <field name='level' type='virErrorLevel' info='how consequent is the error'/>
      <field name='conn' type='virConnectPtr' info='connection if available, deprecated
see note above'/>
      <field name='dom' type='virDomainPtr' info='domain if available, deprecated
see note above'/>
      <field name='str1' type='char *' info='extra string information'/>
      <field name='str2' type='char *' info='extra string information'/>
      <field name='str3' type='char *' info='extra string information'/>
      <field name='int1' type='int' info='extra number information'/>
      <field name='int2' type='int' info='extra number information'/>
      <field name='net' type='virNetworkPtr' info='network if available, deprecated
see note above'/>
    </struct>
    <typedef name='virErrorDomain' file='virterror' type='enum'/>
    <typedef name='virErrorLevel' file='virterror' type='enum'/>
    <typedef name='virErrorNumber' file='virterror' type='enum'/>
    <typedef name='virErrorPtr' file='virterror' type='virError *'/>
    <typedef name='virEventHandleType' file='libvirt-event' type='enum'/>
    <typedef name='virIPAddrType' file='libvirt-network' type='enum'/>
    <struct name='virInterface' file='libvirt-interface' type='struct _virInterface'/>
    <typedef name='virInterfacePtr' file='libvirt-interface' type='virInterface *'>
      <info><![CDATA[a virInterfacePtr is pointer to a virInterface private structure, this is the type used to reference a virtual interface in the API.]]></info>
    </typedef>
    <typedef name='virInterfaceXMLFlags' file='libvirt-interface' type='enum'/>
    <typedef name='virKeycodeSet' file='libvirt-domain' type='enum'/>
    <struct name='virMemoryParameter' file='libvirt-domain' type='struct _virTypedParameter'>
      <field name='field' type='char field[VIR_TYPED_PARAM_FIELD_LENGTH]' info='parameter name'/>
      <field name='type' type='int' info='parameter type, virTypedParameterType'/>
      <field name='value' type='union' info='parameter value'>
        <union>
          <field name='i' type='int' info='type is INT'/>
          <field name='ui' type='unsigned int' info='type is UINT'/>
          <field name='l' type='long long int' info='type is LLONG'/>
          <field name='ul' type='unsigned long long int' info='type is ULLONG'/>
          <field name='d' type='double' info='type is DOUBLE'/>
          <field name='b' type='char' info='type is BOOLEAN'/>
          <field name='s' type='char *' info='type is STRING, may not be NULL'/>
        </union>
      </field>
    </struct>
    <typedef name='virMemoryParameterPtr' file='libvirt-domain' type='virMemoryParameter *'>
      <info><![CDATA[a virMemoryParameterPtr is a pointer to a virMemoryParameter structure. Provided for backwards compatibility; virTypedParameterPtr is the preferred alias since 0.9.2.]]></info>
    </typedef>
    <typedef name='virMemoryParameterType' file='libvirt-domain' type='enum'/>
    <struct name='virNWFilter' file='libvirt-nwfilter' type='struct _virNWFilter'/>
    <struct name='virNWFilterBinding' file='libvirt-nwfilter' type='struct _virNWFilterBinding'/>
    <typedef name='virNWFilterBindingPtr' file='libvirt-nwfilter' type='virNWFilterBinding *'>
      <info><![CDATA[a virNWFilterBindingPtr is pointer to a virNWFilterBinding private structure, this is the type used to reference a network filter port binding in the API.]]></info>
    </typedef>
    <typedef name='virNWFilterPtr' file='libvirt-nwfilter' type='virNWFilter *'>
      <info><![CDATA[a virNWFilterPtr is pointer to a virNWFilter private structure, this is the type used to reference a network filter in the API.]]></info>
    </typedef>
    <struct name='virNetwork' file='libvirt-network' type='struct _virNetwork'/>
    <struct name='virNetworkDHCPLease' file='libvirt-network' type='struct _virNetworkDHCPLease'>
      <field name='iface' type='char *' info='Network interface name'/>
      <field name='expirytime' type='long long' info='Seconds since epoch'/>
      <field name='type' type='int' info='virIPAddrType'/>
      <field name='mac' type='char *' info='MAC address'/>
      <field name='iaid' type='char *' info='IAID'/>
      <field name='ipaddr' type='char *' info='IP address'/>
      <field name='prefix' type='unsigned int' info='IP address prefix'/>
      <field name='hostname' type='char *' info='Hostname'/>
      <field name='clientid' type='char *' info='Client ID or DUID'/>
    </struct>
    <typedef name='virNetworkDHCPLeasePtr' file='libvirt-network' type='virNetworkDHCPLease *'/>
    <typedef name='virNetworkEventID' file='libvirt-network' type='enum'/>
    <typedef name='virNetworkEventLifecycleType' file='libvirt-network' type='enum'/>
    <struct name='virNetworkPort' file='libvirt-network' type='struct _virNetworkPort'/>
    <typedef name='virNetworkPortCreateFlags' file='libvirt-network' type='enum'/>
    <typedef name='virNetworkPortPtr' file='libvirt-network' type='virNetworkPort *'>
      <info><![CDATA[a virNetworkPortPtr is pointer to a virNetworkPort private structure, this is the type used to reference a virtual network port in the API.]]></info>
    </typedef>
    <typedef name='virNetworkPtr' file='libvirt-network' type='virNetwork *'>
      <info><![CDATA[a virNetworkPtr is pointer to a virNetwork private structure, this is the type used to reference a virtual network in the API.]]></info>
    </typedef>
    <typedef name='virNetworkUpdateCommand' file='libvirt-network' type='enum'/>
    <typedef name='virNetworkUpdateFlags' file='libvirt-network' type='enum'/>
    <typedef name='virNetworkUpdateSection' file='libvirt-network' type='enum'/>
    <typedef name='virNetworkXMLFlags' file='libvirt-network' type='enum'/>
    <typedef name='virNodeAllocPagesFlags' file='libvirt-host' type='enum'/>
    <struct name='virNodeCPUStats' file='libvirt-host' type='struct _virNodeCPUStats'>
      <field name='field' type='char field[VIR_NODE_CPU_STATS_FIELD_LENGTH]' info=''/>
      <field name='value' type='unsigned long long' info=''/>
    </struct>
    <typedef name='virNodeCPUStatsPtr' file='libvirt-host' type='virNodeCPUStats *'>
      <info><![CDATA[a virNodeCPUStatsPtr is a pointer to a virNodeCPUStats structure.]]></info>
    </typedef>
    <struct name='virNodeDevice' file='libvirt-nodedev' type='struct _virNodeDevice'/>
    <typedef name='virNodeDeviceEventID' file='libvirt-nodedev' type='enum'/>
    <typedef name='virNodeDeviceEventLifecycleType' file='libvirt-nodedev' type='enum'/>
    <typedef name='virNodeDevicePtr' file='libvirt-nodedev' type='virNodeDevice *'>
      <info><![CDATA[A virNodeDevicePtr is a pointer to a virNodeDevice structure.  Get one via virNodeDeviceLookupByName, or virNodeDeviceCreate.  Be sure to call virNodeDeviceFree when done using a virNodeDevicePtr obtained from any of the above functions to avoid leaking memory.]]></info>
    </typedef>
    <typedef name='virNodeGetCPUStatsAllCPUs' file='libvirt-host' type='enum'/>
    <typedef name='virNodeGetMemoryStatsAllCells' file='libvirt-host' type='enum'/>
    <struct name='virNodeInfo' file='libvirt-host' type='struct _virNodeInfo'>
      <field name='model' type='char model[32]' info='string indicating the CPU model'/>
      <field name='memory' type='unsigned long' info='memory size in kilobytes'/>
      <field name='cpus' type='unsigned int' info='the number of active CPUs'/>
      <field name='mhz' type='unsigned int' info='expected CPU frequency, 0 if not known or
on unusual architectures'/>
      <field name='nodes' type='unsigned int' info='the number of NUMA cell, 1 for unusual NUMA
topologies or uniform memory access; check
capabilities XML for the actual NUMA topology'/>
      <field name='sockets' type='unsigned int' info='number of CPU sockets per node if nodes &gt; 1,
1 in case of unusual NUMA topology'/>
      <field name='cores' type='unsigned int' info='number of cores per socket, total number of
processors in case of unusual NUMA topology'/>
      <field name='threads' type='unsigned int' info='number of threads per core, 1 in case of
unusual numa topology'/>
    </struct>
    <typedef name='virNodeInfoPtr' file='libvirt-host' type='virNodeInfo *'>
      <info><![CDATA[a virNodeInfoPtr is a pointer to a virNodeInfo structure.]]></info>
    </typedef>
    <struct name='virNodeMemoryStats' file='libvirt-host' type='struct _virNodeMemoryStats'>
      <field name='field' type='char field[VIR_NODE_MEMORY_STATS_FIELD_LENGTH]' info=''/>
      <field name='value' type='unsigned long long' info=''/>
    </struct>
    <typedef name='virNodeMemoryStatsPtr' file='libvirt-host' type='virNodeMemoryStats *'>
      <info><![CDATA[a virNodeMemoryStatsPtr is a pointer to a virNodeMemoryStats structure.]]></info>
    </typedef>
    <typedef name='virNodeSuspendTarget' file='libvirt-host' type='enum'/>
    <struct name='virSchedParameter' file='libvirt-domain' type='struct _virTypedParameter'>
      <field name='field' type='char field[VIR_TYPED_PARAM_FIELD_LENGTH]' info='parameter name'/>
      <field name='type' type='int' info='parameter type, virTypedParameterType'/>
      <field name='value' type='union' info='parameter value'>
        <union>
          <field name='i' type='int' info='type is INT'/>
          <field name='ui' type='unsigned int' info='type is UINT'/>
          <field name='l' type='long long int' info='type is LLONG'/>
          <field name='ul' type='unsigned long long int' info='type is ULLONG'/>
          <field name='d' type='double' info='type is DOUBLE'/>
          <field name='b' type='char' info='type is BOOLEAN'/>
          <field name='s' type='char *' info='type is STRING, may not be NULL'/>
        </union>
      </field>
    </struct>
    <typedef name='virSchedParameterPtr' file='libvirt-domain' type='virSchedParameter *'>
      <info><![CDATA[a virSchedParameterPtr is a pointer to a virSchedParameter structure. Provided for backwards compatibility; virTypedParameterPtr is the preferred alias since 0.9.2.]]></info>
    </typedef>
    <typedef name='virSchedParameterType' file='libvirt-domain' type='enum'/>
    <struct name='virSecret' file='libvirt-secret' type='struct _virSecret'/>
    <typedef name='virSecretEventID' file='libvirt-secret' type='enum'/>
    <typedef name='virSecretEventLifecycleType' file='libvirt-secret' type='enum'/>
    <typedef name='virSecretPtr' file='libvirt-secret' type='virSecret *'/>
    <typedef name='virSecretUsageType' file='libvirt-secret' type='enum'/>
    <struct name='virSecurityLabel' file='libvirt-host' type='struct _virSecurityLabel'>
      <field name='label' type='char label[VIR_SECURITY_LABEL_BUFLEN]' info='security label string'/>
      <field name='enforcing' type='int' info='1 if security policy is being enforced for domain'/>
    </struct>
    <typedef name='virSecurityLabelPtr' file='libvirt-host' type='virSecurityLabel *'>
      <info><![CDATA[a virSecurityLabelPtr is a pointer to a virSecurityLabel.]]></info>
    </typedef>
    <struct name='virSecurityModel' file='libvirt-host' type='struct _virSecurityModel'>
      <field name='model' type='char model[VIR_SECURITY_MODEL_BUFLEN]' info='security model string'/>
      <field name='doi' type='char doi[VIR_SECURITY_DOI_BUFLEN]' info='domain of interpretation'/>
    </struct>
    <typedef name='virSecurityModelPtr' file='libvirt-host' type='virSecurityModel *'>
      <info><![CDATA[a virSecurityModelPtr is a pointer to a virSecurityModel.]]></info>
    </typedef>
    <struct name='virStoragePool' file='libvirt-storage' type='struct _virStoragePool'/>
    <typedef name='virStoragePoolBuildFlags' file='libvirt-storage' type='enum'/>
    <typedef name='virStoragePoolCreateFlags' file='libvirt-storage' type='enum'/>
    <typedef name='virStoragePoolDeleteFlags' file='libvirt-storage' type='enum'/>
    <typedef name='virStoragePoolEventID' file='libvirt-storage' type='enum'/>
    <typedef name='virStoragePoolEventLifecycleType' file='libvirt-storage' type='enum'/>
    <struct name='virStoragePoolInfo' file='libvirt-storage' type='struct _virStoragePoolInfo'>
      <field name='state' type='int' info='virStoragePoolState flags'/>
      <field name='capacity' type='unsigned long long' info='Logical size bytes'/>
      <field name='allocation' type='unsigned long long' info='Current allocation bytes'/>
      <field name='available' type='unsigned long long' info='Remaining free space bytes'/>
    </struct>
    <typedef name='virStoragePoolInfoPtr' file='libvirt-storage' type='virStoragePoolInfo *'/>
    <typedef name='virStoragePoolPtr' file='libvirt-storage' type='virStoragePool *'>
      <info><![CDATA[a virStoragePoolPtr is pointer to a virStoragePool private structure, this is the type used to reference a storage pool in the API.]]></info>
    </typedef>
    <typedef name='virStoragePoolState' file='libvirt-storage' type='enum'/>
    <struct name='virStorageVol' file='libvirt-storage' type='struct _virStorageVol'/>
    <typedef name='virStorageVolCreateFlags' file='libvirt-storage' type='enum'/>
    <typedef name='virStorageVolDeleteFlags' file='libvirt-storage' type='enum'/>
    <typedef name='virStorageVolDownloadFlags' file='libvirt-storage' type='enum'/>
    <struct name='virStorageVolInfo' file='libvirt-storage' type='struct _virStorageVolInfo'>
      <field name='type' type='int' info='virStorageVolType flags'/>
      <field name='capacity' type='unsigned long long' info='Logical size bytes'/>
      <field name='allocation' type='unsigned long long' info='Current allocation bytes'/>
    </struct>
    <typedef name='virStorageVolInfoFlags' file='libvirt-storage' type='enum'/>
    <typedef name='virStorageVolInfoPtr' file='libvirt-storage' type='virStorageVolInfo *'/>
    <typedef name='virStorageVolPtr' file='libvirt-storage' type='virStorageVol *'>
      <info><![CDATA[a virStorageVolPtr is pointer to a virStorageVol private structure, this is the type used to reference a storage volume in the API.]]></info>
    </typedef>
    <typedef name='virStorageVolResizeFlags' file='libvirt-storage' type='enum'/>
    <typedef name='virStorageVolType' file='libvirt-storage' type='enum'/>
    <typedef name='virStorageVolUploadFlags' file='libvirt-storage' type='enum'/>
    <typedef name='virStorageVolWipeAlgorithm' file='libvirt-storage' type='enum'/>
    <typedef name='virStorageXMLFlags' file='libvirt-storage' type='enum'/>
    <struct name='virStream' file='libvirt-host' type='struct _virStream'/>
    <typedef name='virStreamEventType' file='libvirt-stream' type='enum'/>
    <typedef name='virStreamFlags' file='libvirt-stream' type='enum'/>
    <typedef name='virStreamPtr' file='libvirt-host' type='virStream *'>
      <info><![CDATA[a virStreamPtr is pointer to a virStream private structure, this is the type used to reference a data stream in the API.]]></info>
    </typedef>
    <typedef name='virStreamRecvFlagsValues' file='libvirt-stream' type='enum'/>
    <struct name='virTypedParameter' file='libvirt-common' type='struct _virTypedParameter'>
      <field name='field' type='char field[VIR_TYPED_PARAM_FIELD_LENGTH]' info='parameter name'/>
      <field name='type' type='int' info='parameter type, virTypedParameterType'/>
      <field name='value' type='union' info='parameter value'>
        <union>
          <field name='i' type='int' info='type is INT'/>
          <field name='ui' type='unsigned int' info='type is UINT'/>
          <field name='l' type='long long int' info='type is LLONG'/>
          <field name='ul' type='unsigned long long int' info='type is ULLONG'/>
          <field name='d' type='double' info='type is DOUBLE'/>
          <field name='b' type='char' info='type is BOOLEAN'/>
          <field name='s' type='char *' info='type is STRING, may not be NULL'/>
        </union>
      </field>
    </struct>
    <typedef name='virTypedParameterFlags' file='libvirt-common' type='enum'/>
    <typedef name='virTypedParameterPtr' file='libvirt-common' type='virTypedParameter *'>
      <info><![CDATA[a pointer to a virTypedParameter structure.]]></info>
    </typedef>
    <typedef name='virTypedParameterType' file='libvirt-common' type='enum'/>
    <struct name='virVcpuInfo' file='libvirt-domain' type='struct _virVcpuInfo'>
      <field name='number' type='unsigned int' info='virtual CPU number'/>
      <field name='state' type='int' info='value from virVcpuState'/>
      <field name='cpuTime' type='unsigned long long' info='CPU time used, in nanoseconds'/>
      <field name='cpu' type='int' info='real CPU number, or -1 if offline'/>
    </struct>
    <typedef name='virVcpuInfoPtr' file='libvirt-domain' type='virVcpuInfo *'/>
    <typedef name='virVcpuState' file='libvirt-domain' type='enum'/>
    <variable name='virConnectAuthPtrDefault' file='libvirt-host' type='virConnectAuthPtr'/>
    <function name='virConnCopyLastError' file='virterror' module='virerror'>
      <info><![CDATA[Copy the content of the last error caught on that connection

This method is not protected against access from multiple
threads. In a multi-threaded application, always use the
global virGetLastError() API which is backed by thread
local storage.

If the connection object was discovered to be invalid by
an API call, then the error will be reported against the
global error object.

Since 0.6.0, all errors reported in the per-connection object
are also duplicated in the global error object. As such an
application can always use virGetLastError(). This method
remains for backwards compatibility.

One will need to free the result with virResetError()]]></info>
      <return type='int' info='0 if no error was found and the error code otherwise and -1 in case of parameter error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virConnGetLastError' file='virterror' module='virerror'>
      <info><![CDATA[Provide a pointer to the last error caught on that connection

This method is not protected against access from multiple
threads. In a multi-threaded application, always use the
global virGetLastError() API which is backed by thread
local storage.

If the connection object was discovered to be invalid by
an API call, then the error will be reported against the
global error object.

Since 0.6.0, all errors reported in the per-connection object
are also duplicated in the global error object. As such an
application can always use virGetLastError(). This method
remains for backwards compatibility.]]></info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occurred.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnResetLastError' file='virterror' module='virerror'>
      <info><![CDATA[The error object is kept in thread local storage, so separate
threads can safely access this concurrently.

Reset the last error caught on that connection]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnSetErrorFunc' file='virterror' module='virerror'>
      <info><![CDATA[Set a connection error handling function, if @handler is NULL
it will reset to default which is to pass error back to the global
library handler.]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
    <functype name='virConnectAuthCallbackPtr' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[When authentication requires one or more interactions, this callback
is invoked. For each interaction supplied, data must be gathered
from the user and filled in to the 'result' and 'resultlen' fields.
If an interaction cannot be filled, fill in NULL and 0.]]></info>
      <return type='int' info='0 if all interactions were filled, or -1 upon error'/>
      <arg name='cred' type='virConnectCredentialPtr' info='list of virConnectCredential object to fetch from user'/>
      <arg name='ncred' type='unsigned int' info='size of cred list'/>
      <arg name='cbdata' type='void *' info='opaque data passed to virConnectOpenAuth'/>
    </functype>
    <function name='virConnectBaselineCPU' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Computes the most feature-rich CPU which is compatible with all given
host CPUs.

See virConnectBaselineHypervisorCPU() to get a CPU which can be provided
by the hypervisor.

If @flags includes VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES then libvirt
will explicitly list all CPU features that are part of the host CPU,
without this flag features that are part of the CPU model will not be
listed.

If @flags includes VIR_CONNECT_BASELINE_CPU_MIGRATABLE, the resulting
CPU will not include features that block migration.]]></info>
      <return type='char *' info='XML description of the computed CPU (caller frees) or NULL on error.'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='xmlCPUs' type='const char **' info='array of XML descriptions of host CPUs'/>
      <arg name='ncpus' type='unsigned int' info='number of CPUs in xmlCPUs'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectBaselineCPUFlags'/>
    </function>
    <function name='virConnectBaselineHypervisorCPU' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Computes the most feature-rich CPU which is compatible with all given CPUs
and can be provided by the specified hypervisor. For best results the
host-model CPUs as advertised by virConnectGetDomainCapabilities() should be
passed in @xmlCPUs. Any of @emulator, @arch, @machine, and @virttype
parameters may be NULL; libvirt will choose sensible defaults tailored to
the host and its current configuration.

This is different from virConnectBaselineCPU() which doesn't consider any
hypervisor abilities when computing the best CPU.

If @flags includes VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES then libvirt
will explicitly list all CPU features that are part of the computed CPU,
without this flag features that are part of the CPU model will not be
listed.

If @flags includes VIR_CONNECT_BASELINE_CPU_MIGRATABLE, the resulting
CPU will not include features that block migration.]]></info>
      <return type='char *' info='XML description of the computed CPU (caller frees) or NULL on error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='emulator' type='const char *' info='path to the emulator binary'/>
      <arg name='arch' type='const char *' info='CPU architecture'/>
      <arg name='machine' type='const char *' info='machine type'/>
      <arg name='virttype' type='const char *' info='virtualization type'/>
      <arg name='xmlCPUs' type='const char **' info='array of XML descriptions of CPUs'/>
      <arg name='ncpus' type='unsigned int' info='number of CPUs in xmlCPUs'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectBaselineCPUFlags'/>
    </function>
    <function name='virConnectClose' file='libvirt-host' module='libvirt'>
      <info><![CDATA[This function closes the connection to the Hypervisor. This should
not be called if further interaction with the Hypervisor are needed
especially if there is running domain which need further monitoring by
the application.

Connections are reference counted; the count is explicitly
increased by the initial open (virConnectOpen, virConnectOpenAuth,
and the like) as well as virConnectRef; it is also temporarily
increased by other API that depend on the connection remaining
alive.  The open and every virConnectRef call should have a
matching virConnectClose, and all other references will be released
after the corresponding operation completes.]]></info>
      <return type='int' info='a positive number if at least 1 reference remains on success. The returned value should not be assumed to be the total reference count. A return of 0 implies no references remain and the connection is closed and memory has been freed. A return of -1 implies a failure.  It is possible for the last virConnectClose to return a positive value if some other object still has a temporary reference to the connection, but the application should not try to further use a connection after the virConnectClose that matches the initial open.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <functype name='virConnectCloseFunc' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[A callback function to be registered, and called when the connection
is closed.]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='reason' type='int' info='reason why the connection was closed (one of virConnectCloseReason)'/>
      <arg name='opaque' type='void *' info='opaque user data'/>
    </functype>
    <function name='virConnectCompareCPU' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Compares the given CPU description with the host CPU.

See virConnectCompareHypervisorCPU() if you want to consider hypervisor
abilities and compare the CPU to the CPU which a hypervisor is able to
provide on the host.]]></info>
      <return type='int' info='comparison result according to enum virCPUCompareResult. If VIR_CONNECT_COMPARE_CPU_FAIL_INCOMPATIBLE is used and @xmlDesc CPU is incompatible with host CPU, this function will return VIR_CPU_COMPARE_ERROR (instead of VIR_CPU_COMPARE_INCOMPATIBLE) and the error will use the VIR_ERR_CPU_INCOMPATIBLE code with a message providing more details about the incompatibility.'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='xmlDesc' type='const char *' info='XML describing the CPU to compare with host CPU'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectCompareCPUFlags'/>
    </function>
    <function name='virConnectCompareHypervisorCPU' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Compares the given CPU description with the CPU the specified hypervisor is
able to provide on the host. Any of @emulator, @arch, @machine, and
@virttype parameters may be NULL; libvirt will choose sensible defaults
tailored to the host and its current configuration.

This is different from virConnectCompareCPU() which compares the CPU
definition with the host CPU without considering any specific hypervisor and
its abilities.]]></info>
      <return type='int' info='comparison result according to enum virCPUCompareResult. If VIR_CONNECT_COMPARE_CPU_FAIL_INCOMPATIBLE is used and @xmlCPU is incompatible with the CPU the specified hypervisor is able to provide on the host, this function will return VIR_CPU_COMPARE_ERROR (instead of VIR_CPU_COMPARE_INCOMPATIBLE) and the error will use the VIR_ERR_CPU_INCOMPATIBLE code with a message providing more details about the incompatibility.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='emulator' type='const char *' info='path to the emulator binary'/>
      <arg name='arch' type='const char *' info='CPU architecture'/>
      <arg name='machine' type='const char *' info='machine type'/>
      <arg name='virttype' type='const char *' info='virtualization type'/>
      <arg name='xmlCPU' type='const char *' info='XML describing the CPU to be compared'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectCompareCPUFlags'/>
    </function>
    <functype name='virConnectDomainEventAgentLifecycleCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when libvirt detects a change in the state of a guest
agent.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_AGENT_LIFECYCLE with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='state' type='int' info='new state of the guest agent, one of virConnectDomainEventAgentLifecycleState'/>
      <arg name='reason' type='int' info='reason for state change; one of virConnectDomainEventAgentLifecycleReason'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventBalloonChangeCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='actual' type='unsigned long long' info='the new balloon level measured in kibibytes(blocks of 1024 bytes)'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventBlockJobCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The string returned for @disk can be used in any of the libvirt API
that operate on a particular disk of the domain, and depends on what
event type was registered with virConnectDomainEventRegisterAny().
If the callback was registered using the older type of
VIR_DOMAIN_EVENT_ID_BLOCK_JOB, then @disk contains the absolute file
name of the host resource for the active layer of the disk; however,
this name is unstable (pivoting via block copy or active block commit
will change which file is active, giving a different name for the two
events associated with the same job) and cannot be relied on if the
active layer is associated with a network resource.  If the callback
was registered using the newer type of VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2,
then @disk will contain the device target shorthand (the <target
dev='...'/> sub-element, such as "vda").]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='disk' type='const char *' info='name associated with the affected disk (filename or target device, depending on how the callback was registered)'/>
      <arg name='type' type='int' info='type of block job (virDomainBlockJobType)'/>
      <arg name='status' type='int' info='status of the operation (virConnectDomainEventBlockJobStatus)'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventBlockThresholdCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The callback occurs when the hypervisor detects that the given storage
element was written beyond the point specified by @threshold. The excess
data size written beyond @threshold is reported by @excess (if supported
by the hypervisor, 0 otherwise). The event is useful for thin-provisioned
storage.

The threshold size can be set via the virDomainSetBlockThreshold API.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='dev' type='const char *' info='name associated with the affected disk or storage backing chain element'/>
      <arg name='path' type='const char *' info='for local storage, the path of the backing chain element'/>
      <arg name='threshold' type='unsigned long long' info='threshold offset in bytes'/>
      <arg name='excess' type='unsigned long long' info='number of bytes written beyond the threshold'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[A callback function to be registered, and called when a domain event occurs]]></info>
      <return type='int' info='0 (the return value is currently ignored)'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='dom' type='virDomainPtr' info='The domain on which the event occurred'/>
      <arg name='event' type='int' info='The specific virDomainEventType which occurred'/>
      <arg name='detail' type='int' info='event specific detail information'/>
      <arg name='opaque' type='void *' info='opaque user data'/>
    </functype>
    <function name='virConnectDomainEventDeregister' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Removes a callback previously registered with the
virConnectDomainEventRegister() function.

Use of this method is no longer recommended. Instead applications
should try virConnectDomainEventDeregisterAny() which has a more flexible
API contract]]></info>
      <return type='int' info='0 on success, -1 on failure.  Older versions of some hypervisors sometimes returned a positive number on success, but without any reliable semantics on what that number represents.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='cb' type='virConnectDomainEventCallback' info='callback to the function handling domain events'/>
    </function>
    <function name='virConnectDomainEventDeregisterAny' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Removes an event callback. The callbackID parameter should be the
value obtained from a previous virConnectDomainEventRegisterAny() method.]]></info>
      <return type='int' info='0 on success, -1 on failure.  Older versions of some hypervisors sometimes returned a positive number on success, but without any reliable semantics on what that number represents.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='callbackID' type='int' info='the callback identifier'/>
    </function>
    <functype name='virConnectDomainEventDeviceAddedCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when a device is added to the domain.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DEVICE_ADDED with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='devAlias' type='const char *' info='device alias'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventDeviceRemovalFailedCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when it's certain that removal of a device failed.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED with
virConnectDomainEventRegisterAny().]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='devAlias' type='const char *' info='device alias'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventDeviceRemovedCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when a device is removed from the domain.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='devAlias' type='const char *' info='device alias'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventDiskChangeCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when disk gets changed. However,
not all @reason will cause both @oldSrcPath and @newSrcPath
to be non-NULL. Please see virConnectDomainEventDiskChangeReason
for more details.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DISK_CHANGE with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='oldSrcPath' type='const char *' info='old source path'/>
      <arg name='newSrcPath' type='const char *' info='new source path'/>
      <arg name='devAlias' type='const char *' info='device alias name'/>
      <arg name='reason' type='int' info='reason why this callback was called; any of virConnectDomainEventDiskChangeReason'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventGenericCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[A generic domain event callback handler, for use with
virConnectDomainEventRegisterAny(). Specific events usually
have a customization with extra parameters, often with @opaque being
passed in a different parameter position; use VIR_DOMAIN_EVENT_CALLBACK()
when registering an appropriate handler.]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='the connection pointer'/>
      <arg name='dom' type='virDomainPtr' info='the domain pointer'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventGraphicsCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_GRAPHICS with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='phase' type='int' info='the phase of the connection'/>
      <arg name='local' type='const virDomainEventGraphicsAddress *' info='the local server address'/>
      <arg name='remote' type='const virDomainEventGraphicsAddress *' info='the remote client address'/>
      <arg name='authScheme' type='const char *' info='the authentication scheme activated'/>
      <arg name='subject' type='const virDomainEventGraphicsSubject *' info='the authenticated subject (user)'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventIOErrorCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='srcPath' type='const char *' info='The host file on which the IO error occurred'/>
      <arg name='devAlias' type='const char *' info='The guest device alias associated with the path'/>
      <arg name='action' type='int' info='action that is to be taken due to the IO error'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventIOErrorReasonCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON with virConnectDomainEventRegisterAny()

If the I/O error is known to be caused by an ENOSPC condition in
the host (where resizing the disk to be larger will allow the guest
to be resumed as if nothing happened), @reason will be "enospc".
Otherwise, @reason will be "", although future strings may be added
if determination of other error types becomes possible.]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='srcPath' type='const char *' info='The host file on which the IO error occurred'/>
      <arg name='devAlias' type='const char *' info='The guest device alias associated with the path'/>
      <arg name='action' type='int' info='action that is to be taken due to the IO error'/>
      <arg name='reason' type='const char *' info='the cause of the IO error'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventJobCompletedCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when a job (such as migration or backup) running on
the domain is completed.

The params array will contain statistics of the just completed
job as virDomainGetJobStats would return. The callback must not free @params
(the array will be freed once the callback finishes).

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_JOB_COMPLETED with
virConnectDomainEventRegisterAny().]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='params' type='virTypedParameterPtr' info='job statistics stored as an array of virTypedParameter'/>
      <arg name='nparams' type='int' info='size of the params array'/>
      <arg name='opaque' type='void *' info='application specific data'/>
    </functype>
    <functype name='virConnectDomainEventMetadataChangeCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback is triggered when the domain XML metadata is changed

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_METADATA_CHANGE with virConnectDomainEventRegisterAny().]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='type' type='int' info='a value from virDomainMetadataTypea'/>
      <arg name='nsuri' type='const char *' info='XML namespace URI'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventMigrationIterationCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs during live migration when a new iteration over
domain's memory starts. The @iteration value is increased by one every
time a new iteration is started to transfer memory pages dirtied since
the last iteration.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_MIGRATION_ITERATION with
virConnectDomainEventRegisterAny().]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='iteration' type='int' info='current iteration over domain&apos;s memory'/>
      <arg name='opaque' type='void *' info='application specific data'/>
    </functype>
    <functype name='virConnectDomainEventPMSuspendCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when the guest is suspended.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_PMSUSPEND with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='reason' type='int' info='reason why the callback was called, unused currently, always passes 0'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventPMSuspendDiskCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when the guest is suspended to disk.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='reason' type='int' info='reason why the callback was called, unused currently, always passes 0'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventPMWakeupCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when the guest is woken up.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_PMWAKEUP with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='reason' type='int' info='reason why the callback was called, unused currently, always passes 0'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventRTCChangeCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_RTC_CHANGE with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='utcoffset' type='long long' info='the new RTC offset from UTC, measured in seconds'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <function name='virConnectDomainEventRegister' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Adds a callback to receive notifications of domain lifecycle events
occurring on a connection.  This function requires that an event loop
has been previously registered with virEventRegisterImpl() or
virEventRegisterDefaultImpl().

Use of this method is no longer recommended. Instead applications
should try virConnectDomainEventRegisterAny() which has a more flexible
API contract.

The virDomainPtr object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback returns,
it shall take a reference to it, by calling virDomainRef.
The reference can be released once the object is no longer required
by calling virDomainFree.]]></info>
      <return type='int' info='0 on success, -1 on failure.  Older versions of some hypervisors sometimes returned a positive number on success, but without any reliable semantics on what that number represents.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='cb' type='virConnectDomainEventCallback' info='callback to the function handling domain events'/>
      <arg name='opaque' type='void *' info='opaque data to pass on to the callback'/>
      <arg name='freecb' type='virFreeCallback' info='optional function to deallocate opaque when not used anymore'/>
    </function>
    <function name='virConnectDomainEventRegisterAny' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Adds a callback to receive notifications of arbitrary domain events
occurring on a domain.  This function requires that an event loop
has been previously registered with virEventRegisterImpl() or
virEventRegisterDefaultImpl().

If @dom is NULL, then events will be monitored for any domain. If @dom
is non-NULL, then only the specific domain will be monitored.

Most types of event have a callback providing a custom set of parameters
for the event. When registering an event, it is thus necessary to use
the VIR_DOMAIN_EVENT_CALLBACK() macro to cast the supplied function pointer
to match the signature of this method.

The virDomainPtr object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback returns,
it shall take a reference to it, by calling virDomainRef().
The reference can be released once the object is no longer required
by calling virDomainFree().

The return value from this method is a positive integer identifier
for the callback. To unregister a callback, this callback ID should
be passed to the virConnectDomainEventDeregisterAny() method.]]></info>
      <return type='int' info='a callback identifier on success, -1 on failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain'/>
      <arg name='eventID' type='int' info='the event type to receive'/>
      <arg name='cb' type='virConnectDomainEventGenericCallback' info='callback to the function handling domain events'/>
      <arg name='opaque' type='void *' info='opaque data to pass on to the callback'/>
      <arg name='freecb' type='virFreeCallback' info='optional function to deallocate opaque when not used anymore'/>
    </function>
    <functype name='virConnectDomainEventTrayChangeCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when the tray of a removable device is moved.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_TRAY_CHANGE with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='devAlias' type='const char *' info='device alias'/>
      <arg name='reason' type='int' info='why the tray status was changed?'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventTunableCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This callback occurs when tunable values are updated. The params must not
be freed in the callback handler as it's done internally after the callback
handler is executed.

Currently supported name spaces:
 "cputune.*"
 "blkdeviotune.*"

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_TUNABLE with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='params' type='virTypedParameterPtr' info='changed tunable values stored as array of virTypedParameter'/>
      <arg name='nparams' type='int' info='size of the array'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventWatchdogCallback' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_WATCHDOG with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='action' type='int' info='action that is to be taken due to watchdog firing'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <function name='virConnectDomainXMLFromNative' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Reads native configuration data  describing a domain, and
generates libvirt domain XML. The format of the native
data is hypervisor dependent.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='conn' type='virConnectPtr' info='a connection object'/>
      <arg name='nativeFormat' type='const char *' info='configuration format importing from'/>
      <arg name='nativeConfig' type='const char *' info='the configuration data to import'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virConnectDomainXMLToNative' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Reads a domain XML configuration document, and generates
a native configuration file describing the domain.
The format of the native data is hypervisor dependent.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded native config datafile, or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='conn' type='virConnectPtr' info='a connection object'/>
      <arg name='nativeFormat' type='const char *' info='configuration format exporting to'/>
      <arg name='domainXml' type='const char *' info='the domain configuration to export'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virConnectFindStoragePoolSources' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Talks to a storage backend and attempts to auto-discover the set of
available storage pool sources. e.g. For iSCSI this would be a set of
iSCSI targets. For NFS this would be a list of exported paths.  The
srcSpec (optional for some storage pool types, e.g. local ones) is
an instance of the storage pool's source element specifying where
to look for the pools.

srcSpec is not required for some types (e.g., those querying
local storage resources only)]]></info>
      <return type='char *' info='an xml document consisting of a SourceList element containing a source document appropriate to the given pool type for each discovered source.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='type' type='const char *' info='type of storage pool sources to discover'/>
      <arg name='srcSpec' type='const char *' info='XML document specifying discovery source'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virConnectGetAllDomainStats' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Query statistics for all domains on a given connection.

Report statistics of various parameters for a running VM according to @stats
field. The statistics are returned as an array of structures for each queried
domain. The structure contains an array of typed parameters containing the
individual statistics. The typed parameter name for each statistic field
consists of a dot-separated string containing name of the requested group
followed by a group specific description of the statistic value.

The statistic groups are enabled using the @stats parameter which is a
binary-OR of enum virDomainStatsTypes. The following groups are available
(although not necessarily implemented for each hypervisor):

VIR_DOMAIN_STATS_STATE:
    Return domain state and reason for entering that state. The typed
    parameter keys are in this format:

    "state.state" - state of the VM, returned as int from virDomainState enum
    "state.reason" - reason for entering given state, returned as int from
                     virDomain*Reason enum corresponding to given state.

VIR_DOMAIN_STATS_CPU_TOTAL:
    Return CPU statistics and usage information. The typed parameter keys
    are in this format:

    "cpu.time" - total cpu time spent for this domain in nanoseconds
                 as unsigned long long.
    "cpu.user" - user cpu time spent in nanoseconds as unsigned long long.
    "cpu.system" - system cpu time spent in nanoseconds as unsigned long
                   long.
    "cpu.cache.monitor.count" - the number of cache monitors for this domain
    "cpu.cache.monitor.<num>.name" - the name of cache monitor <num>
    "cpu.cache.monitor.<num>.vcpus" - vcpu list of cache monitor <num>
    "cpu.cache.monitor.<num>.bank.count" - the number of cache banks in
                                           cache monitor <num>
    "cpu.cache.monitor.<num>.bank.<index>.id" - host allocated cache id for
                                                bank <index> in cache
                                                monitor <num>
    "cpu.cache.monitor.<num>.bank.<index>.bytes" - the number of bytes of
                                                   last level cache that the
                                                   domain is using on cache
                                                   bank <index>

VIR_DOMAIN_STATS_BALLOON:
    Return memory balloon device information.
    The typed parameter keys are in this format:

    "balloon.current" - the memory in kiB currently used
                        as unsigned long long.
    "balloon.maximum" - the maximum memory in kiB allowed
                        as unsigned long long.
    "balloon.swap_in" - the amount of data read from swap space (in KiB)
                        as unsigned long long
    "balloon.swap_out" - the amount of memory written out to swap space
                         (in KiB) as unsigned long long
    "balloon.major_fault" - the number of page faults when disk IO was
                            required as unsigned long long
    "balloon.minor_fault" - the number of other page faults
                            as unsigned long long
    "balloon.unused" - the amount of memory left unused by the system
                       (in KiB) as unsigned long long
    "balloon.available" - the amount of usable memory as seen by the domain
                          (in KiB) as unsigned long long
    "balloon.rss" - Resident Set Size of running domain's process
                    (in KiB) as unsigned long long
    "balloon.usable" - the amount of memory which can be reclaimed by balloon
                       without causing host swapping (in KiB)
                       as unsigned long long
    "balloon.last-update" - timestamp of the last update of statistics
                            (in seconds) as unsigned long long
    "balloon.disk_caches" - the amount of memory that can be reclaimed
                            without additional I/O, typically disk (in KiB)
                            as unsigned long long
    "balloon.hugetlb_pgalloc" - the number of successful huge page allocations
                                from inside the domain via virtio balloon
                                as unsigned long long
    "balloon.hugetlb_pgfail" - the number of failed huge page allocations
                               from inside the domain via virtio balloon
                               as unsigned long long

VIR_DOMAIN_STATS_VCPU:
    Return virtual CPU statistics.
    Due to VCPU hotplug, the vcpu.<num>.* array could be sparse.
    The actual size of the array corresponds to "vcpu.current".
    The array size will never exceed "vcpu.maximum".
    The typed parameter keys are in this format:

    "vcpu.current" - current number of online virtual CPUs as unsigned int.
    "vcpu.maximum" - maximum number of online virtual CPUs as unsigned int.
    "vcpu.<num>.state" - state of the virtual CPU <num>, as int
                         from virVcpuState enum.
    "vcpu.<num>.time" - virtual cpu time spent by virtual CPU <num>
                        as unsigned long long.
    "vcpu.<num>.wait" - time the vCPU <num> wants to run, but the host
                        scheduler has something else running ahead of it.
    "vcpu.<num>.halted" - virtual CPU <num> is halted, may indicate the
                          processor is idle or even disabled, depending
                          on the architecture)

VIR_DOMAIN_STATS_INTERFACE:
    Return network interface statistics (from domain point of view).
    The typed parameter keys are in this format:

    "net.count" - number of network interfaces on this domain
                  as unsigned int.
    "net.<num>.name" - name of the interface <num> as string.
    "net.<num>.rx.bytes" - bytes received as unsigned long long.
    "net.<num>.rx.pkts" - packets received as unsigned long long.
    "net.<num>.rx.errs" - receive errors as unsigned long long.
    "net.<num>.rx.drop" - receive packets dropped as unsigned long long.
    "net.<num>.tx.bytes" - bytes transmitted as unsigned long long.
    "net.<num>.tx.pkts" - packets transmitted as unsigned long long.
    "net.<num>.tx.errs" - transmission errors as unsigned long long.
    "net.<num>.tx.drop" - transmit packets dropped as unsigned long long.

VIR_DOMAIN_STATS_BLOCK:
    Return block devices statistics.  By default,
    this information is limited to the active layer of each <disk> of the
    domain (where block.count is equal to the number of disks), but adding
    VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING to @flags will expand the
    array to cover backing chains (block.count corresponds to the number
    of host resources used together to provide the guest disks).
    The typed parameter keys are in this format:

    "block.count" - number of block devices in the subsequent list,
                    as unsigned int.
    "block.<num>.name" - name of the block device <num> as string.
                         matches the target name (vda/sda/hda) of the
                         block device.  If the backing chain is listed,
                         this name is the same for all host resources tied
                         to the same guest device.
    "block.<num>.backingIndex" - unsigned int giving the <backingStore>
                                  index, only used when backing images
                                  are listed.
    "block.<num>.path" - string describing the source of block device <num>,
                         if it is a file or block device (omitted for network
                         sources and drives with no media inserted).
    "block.<num>.rd.reqs" - number of read requests as unsigned long long.
    "block.<num>.rd.bytes" - number of read bytes as unsigned long long.
    "block.<num>.rd.times" - total time (ns) spent on reads as
                             unsigned long long.
    "block.<num>.wr.reqs" - number of write requests as unsigned long long.
    "block.<num>.wr.bytes" - number of written bytes as unsigned long long.
    "block.<num>.wr.times" - total time (ns) spent on writes as
                             unsigned long long.
    "block.<num>.fl.reqs" - total flush requests as unsigned long long.
    "block.<num>.fl.times" - total time (ns) spent on cache flushing as
                             unsigned long long.
    "block.<num>.errors" - Xen only: the 'oo_req' value as
                           unsigned long long.
    "block.<num>.allocation" - offset of the highest written sector
                               as unsigned long long.
    "block.<num>.capacity" - logical size in bytes of the block device
                             backing image as unsigned long long.
    "block.<num>.physical" - physical size in bytes of the container of the
                             backing image as unsigned long long.
    "block.<num>.threshold" - current threshold for delivering the
                              VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD
                              event in bytes. See virDomainSetBlockThreshold.

VIR_DOMAIN_STATS_PERF:
    Return perf event statistics.
    The typed parameter keys are in this format:

    "perf.cmt" - the usage of l3 cache (bytes) by applications running on
                 the platform as unsigned long long. It is produced by cmt
                 perf event.
    "perf.mbmt" - the total system bandwidth (bytes/s) from one level of
                  cache to another as unsigned long long. It is produced
                  by mbmt perf event.
    "perf.mbml" - the amount of data (bytes/s) sent through the memory
                  controller on the socket as unsigned long long. It is
                  produced by mbml perf event.
    "perf.cache_misses" - the count of cache misses as unsigned long long.
                          It is produced by cache_misses perf event.
    "perf.cache_references" - the count of cache hits as unsigned long long.
                              It is produced by cache_references perf event.
    "perf.instructions" - The count of instructions as unsigned long long.
                          It is produced by instructions perf event.
    "perf.cpu_cycles" - The count of cpu cycles (total/elapsed) as an
                        unsigned long long. It is produced by cpu_cycles
                        perf event.
    "perf.branch_instructions" - The count of branch instructions as
                                 unsigned long long. It is produced by
                                 branch_instructions perf event.
    "perf.branch_misses" - The count of branch misses as unsigned long
                           long. It is produced by branch_misses perf event.
    "perf.bus_cycles" - The count of bus cycles as unsigned long
                        long. It is produced by bus_cycles perf event.
    "perf.stalled_cycles_frontend" - The count of stalled cpu cycles in the
                                     frontend of the instruction processor
                                     pipeline as unsigned long long. It is
                                     produced by stalled_cycles_frontend
                                     perf event.
    "perf.stalled_cycles_backend"  - The count of stalled cpu cycles in the
                                     backend of the instruction processor
                                     pipeline as unsigned long long. It is
                                     produced by stalled_cycles_backend
                                     perf event.
    "perf.ref_cpu_cycles" - The count of total cpu cycles not affected by
                            CPU frequency scaling by applications running
                            as unsigned long long. It is produced by the
                            ref_cpu_cycles perf event.
    "perf.cpu_clock" - The count of cpu clock time as unsigned long long.
                       It is produced by the cpu_clock perf event.
    "perf.task_clock" - The count of task clock time as unsigned long long.
                        It is produced by the task_clock perf event.
    "perf.page_faults" - The count of page faults as unsigned long long.
                         It is produced by the page_faults perf event
    "perf.context_switches" - The count of context switches as unsigned long
                              long. It is produced by the context_switches
                              perf event.
    "perf.cpu_migrations" - The count of cpu migrations, from one logical
                            processor to another, as unsigned long
                            long. It is produced by the cpu_migrations
                            perf event.
    "perf.page_faults_min" - The count of minor page faults as unsigned
                             long long. It is produced by the
                             page_faults_min perf event.
    "perf.page_faults_maj" - The count of major page faults as unsigned
                             long long. It is produced by the
                             page_faults_maj perf event.
    "perf.alignment_faults" - The count of alignment faults as unsigned
                              long long. It is produced by the
                              alignment_faults perf event
    "perf.emulation_faults" - The count of emulation faults as unsigned
                              long long. It is produced by the
                              emulation_faults perf event

VIR_DOMAIN_STATS_IOTHREAD:
    Return IOThread statistics if available. IOThread polling is a
    timing mechanism that allows the hypervisor to generate a longer
    period of time in which the guest will perform operations on the
    CPU being used by the IOThread. The higher the value for poll-max-ns
    the longer the guest will keep the CPU. This may affect other host
    threads using the CPU. The poll-grow and poll-shrink values allow
    the hypervisor to generate a mechanism to add or remove polling time
    within the confines of 0 and poll-max-ns. For QEMU, the poll-grow is
    multiplied by the polling interval, while poll-shrink is used as a
    divisor. When not provided, QEMU may double the polling time until
    poll-max-ns is reached. When poll-shrink is 0 (zero) QEMU may reset
    the polling interval to 0 until it finds its "sweet spot". Setting
    poll-grow too large may cause frequent fluctuation of the time; however,
    this can be tempered by a high poll-shrink to reduce the polling
    interval. For example, a poll-grow of 3 will triple the polling time
    which could quickly exceed poll-max-ns; however, a poll-shrink of
    10 would cut that polling time more gradually.

    The typed parameter keys are in this format:

    "iothread.count" - maximum number of IOThreads in the subsequent list
                       as unsigned int. Each IOThread in the list will
                       will use it's iothread_id value as the <id>. There
                       may be fewer <id> entries than the iothread.count
                       value if the polling values are not supported.
    "iothread.<id>.poll-max-ns" - maximum polling time in ns as an unsigned
                                  long long. A 0 (zero) means polling is
                                  disabled.
    "iothread.<id>.poll-grow" - polling time factor as an unsigned int.
                                A 0 (zero) indicates to allow the underlying
                                hypervisor to choose how to grow the
                                polling time.
    "iothread.<id>.poll-shrink" - polling time divisor as an unsigned int.
                                A 0 (zero) indicates to allow the underlying
                                hypervisor to choose how to shrink the
                                polling time.

VIR_DOMAIN_STATS_MEMORY:
    Return memory bandwidth statistics and the usage information. The typed
    parameter keys are in this format:

    "memory.bandwidth.monitor.count" - the number of memory bandwidth
                                       monitors for this domain
    "memory.bandwidth.monitor.<num>.name" - the name of monitor <num>
    "memory.bandwidth.monitor.<num>.vcpus" - the vcpu list of monitor <num>
    "memory.bandwidth.monitor.<num>.node.count" - the number of memory
                                           controller in monitor <num>
    "memory.bandwidth.monitor.<num>.node.<index>.id" - host allocated memory
                                                controller id for controller
                                                <index> of monitor <num>
    "memory.bandwidth.monitor.<num>.node.<index>.bytes.local" - the
                      accumulative bytes consumed by @vcpus that passing
                      through the memory controller in the same processor
                      that the scheduled host CPU belongs to.
    "memory.bandwidth.monitor.<num>.node.<index>.bytes.total" - the total
                      bytes consumed by @vcpus that passing through all
                      memory controllers, either local or remote controller.

Note that entire stats groups or individual stat fields may be missing from
the output in case they are not supported by the given hypervisor, are not
applicable for the current state of the guest domain, or their retrieval
was not successful.

Using 0 for @stats returns all stats groups supported by the given
hypervisor.

Specifying VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS as @flags makes
the function return error in case some of the stat types in @stats were
not recognized by the daemon.  However, even with this flag, a hypervisor
may omit individual fields within a known group if the information is not
available; as an extreme example, a supported group may produce zero
fields for offline domains if the statistics are meaningful only for a
running domain.

Passing VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT in
@flags means when libvirt is unable to fetch stats for any of
the domains (for whatever reason) only a subset of statistics
is returned for the domain.  That subset being statistics that
don't involve querying the underlying hypervisor.

Similarly to virConnectListAllDomains, @flags can contain various flags to
filter the list of domains to provide stats for.

VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE selects online domains while
VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE selects offline ones.

VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT and
VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT allow to filter the list
according to their persistence.

To filter the list of VMs by domain state @flags can contain
VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING,
VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED,
VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF and/or
VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER for all other states.]]></info>
      <return type='int' info='the count of returned statistics structures on success, -1 on error. The requested data are returned in the @retStats parameter. The returned array should be freed by the caller. See virDomainStatsRecordListFree.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='stats' type='unsigned int' info='stats to return, binary-OR of virDomainStatsTypes'/>
      <arg name='retStats' type='virDomainStatsRecordPtr **' info='Pointer that will be filled with the array of returned stats'/>
      <arg name='flags' type='unsigned int' info='extra flags; binary-OR of virConnectGetAllDomainStatsFlags'/>
    </function>
    <function name='virConnectGetCPUModelNames' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Get the list of CPU models supported by libvirt for a specific architecture.

The returned list limits CPU models usable with libvirt (empty list means
there's no limit imposed by libvirt) and it does not reflect capabilities of
any particular hypervisor. See the XML returned by
virConnectGetDomainCapabilities() for a list of CPU models supported by
libvirt for domains created on a specific hypervisor.]]></info>
      <return type='int' info='-1 on error, number of elements in @models on success (0 means libvirt accepts any CPU model).'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='arch' type='const char *' info='Architecture'/>
      <arg name='models' type='char ** *' info='Pointer to a variable to store the NULL-terminated array of the CPU models supported for the specified architecture.  Each element and the array itself must be freed by the caller with free.  Pass NULL if only the list length is needed.'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0.'/>
    </function>
    <function name='virConnectGetCapabilities' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Provides capabilities of the hypervisor / driver.]]></info>
      <return type='char *' info='NULL in case of error, or an XML string defining the capabilities. The client must free the returned string after use.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetDomainCapabilities' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Prior creating a domain (for instance via virDomainCreateXML
or virDomainDefineXML) it may be suitable to know what the
underlying emulator and/or libvirt is capable of. For
instance, if host, libvirt and qemu is capable of VFIO
passthrough and so on.]]></info>
      <return type='char *' info='NULL in case of error or an XML string defining the capabilities.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='emulatorbin' type='const char *' info='path to emulator'/>
      <arg name='arch' type='const char *' info='domain architecture'/>
      <arg name='machine' type='const char *' info='machine type'/>
      <arg name='virttype' type='const char *' info='virtualization type'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virConnectGetHostname' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[This returns a system hostname on which the hypervisor is
running (based on the result of the gethostname system call, but
possibly expanded to a fully-qualified domain name via getaddrinfo).
If we are connected to a remote system, then this returns the
hostname of the remote system.]]></info>
      <return type='char *' info='the hostname which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
    </function>
    <function name='virConnectGetLibVersion' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Provides @libVer, which is the version of libvirt used by the
  daemon running on the @conn host]]></info>
      <return type='int' info='-1 in case of failure, 0 otherwise, and values for @libVer have the format major * 1,000,000 + minor * 1,000 + release.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='libVer' type='unsigned long *' info='returns the libvirt library version used on the connection (OUT)'/>
    </function>
    <function name='virConnectGetMaxVcpus' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Provides the maximum number of virtual CPUs supported for a guest VM of a
specific type. The 'type' parameter here corresponds to the 'type'
attribute in the <domain> element of the XML. This API doesn't take emulator
limits into consideration, hence the returned value is not guaranteed to be
usable. It is recommended to use virConnectGetDomainCapabilities() and look
for "<vcpu max='...'>" in its output instead.]]></info>
      <return type='int' info='the maximum of virtual CPU or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='type' type='const char *' info='value of the &apos;type&apos; attribute in the &lt;domain&gt; element'/>
    </function>
    <function name='virConnectGetStoragePoolCapabilities' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Prior creating a storage pool (for instance via virStoragePoolCreateXML
or virStoragePoolDefineXML) it may be suitable to know what pool types
are supported along with the file/disk formats for each pool.]]></info>
      <return type='char *' info='NULL in case of error or an XML string defining the capabilities.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virConnectGetSysinfo' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[This returns the XML description of the sysinfo details for the
host on which the hypervisor is running, in the same format as the
<sysinfo> element of a domain XML.  This information is generally
available only for hypervisors running with root privileges.]]></info>
      <return type='char *' info='the XML string which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virConnectGetType' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Get the name of the Hypervisor driver used. This is merely the driver
name; for example, both KVM and QEMU guests are serviced by the
driver for the qemu:// URI, so a return of "QEMU" does not indicate
whether KVM acceleration is present.  For more details about the
hypervisor, use virConnectGetCapabilities().]]></info>
      <return type='const char *' info='NULL in case of error, a static zero terminated string otherwise.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetURI' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[This returns the URI (name) of the hypervisor connection.
Normally this is the same as or similar to the string passed
to the virConnectOpen/virConnectOpenReadOnly call, but
the driver may make the URI canonical.  If name == NULL
was passed to virConnectOpen, then the driver will return
a non-NULL URI which can be used to connect to the same
hypervisor later.]]></info>
      <return type='char *' info='the URI string which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
    </function>
    <function name='virConnectGetVersion' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Get the version level of the Hypervisor running. This may work only with
hypervisor call, i.e. with privileged access to the hypervisor, not
with a Read-Only connection.]]></info>
      <return type='int' info='-1 in case of error, 0 otherwise. if the version can&apos;t be extracted by lack of capacities returns 0 and @hvVer is 0, otherwise @hvVer value is major * 1,000,000 + minor * 1,000 + release'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='hvVer' type='unsigned long *' info='return value for the version of the running hypervisor (OUT)'/>
    </function>
    <function name='virConnectIsAlive' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Determine if the connection to the hypervisor is still alive

A connection will be classed as alive if it is either local, or running
over a channel (TCP or UNIX socket) which is not closed.]]></info>
      <return type='int' info='1 if alive, 0 if dead, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection object'/>
    </function>
    <function name='virConnectIsEncrypted' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Determine if the connection to the hypervisor is encrypted]]></info>
      <return type='int' info='1 if encrypted, 0 if not encrypted, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection object'/>
    </function>
    <function name='virConnectIsSecure' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Determine if the connection to the hypervisor is secure

A connection will be classed as secure if it is either
encrypted, or running over a channel which is not exposed
to eavesdropping (eg a UNIX domain socket, or pipe)]]></info>
      <return type='int' info='1 if secure, 0 if not secure, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection object'/>
    </function>
    <function name='virConnectListAllDomains' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Collect a possibly-filtered list of all domains, and return an allocated
array of information for each.  This API solves the race inherent in
virConnectListDomains() and virConnectListDefinedDomains().

Normally, all domains are returned; however, @flags can be used to
filter the results for a smaller list of targeted domains.  The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a domain, and where all bits
within a group describe all possible domains.  Some hypervisors might
reject explicit bits from a group where the hypervisor cannot make a
distinction (for example, not all hypervisors can tell whether domains
have snapshots).  For a group supported by a given hypervisor, the
behavior when no bits of a group are set is identical to the behavior
when all bits in that group are set.  When setting bits from more than
one group, it is possible to select an impossible combination (such
as an inactive transient domain), in that case a hypervisor may return
either 0 or an error.

The first group of @flags is VIR_CONNECT_LIST_DOMAINS_ACTIVE (online
domains) and VIR_CONNECT_LIST_DOMAINS_INACTIVE (offline domains).

The next group of @flags is VIR_CONNECT_LIST_DOMAINS_PERSISTENT (defined
domains) and VIR_CONNECT_LIST_DOMAINS_TRANSIENT (running but not defined).

The next group of @flags covers various domain states:
VIR_CONNECT_LIST_DOMAINS_RUNNING, VIR_CONNECT_LIST_DOMAINS_PAUSED,
VIR_CONNECT_LIST_DOMAINS_SHUTOFF, and a catch-all for all other states
(such as crashed, this catch-all covers the possibility of adding new
states).

The remaining groups cover boolean attributes commonly asked about
domains; they include VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE and
VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE, for filtering based on whether
a managed save image exists; VIR_CONNECT_LIST_DOMAINS_AUTOSTART and
VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART, for filtering based on autostart;
VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT and
VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT, for filtering based on whether
a domain has snapshots; VIR_CONNECT_LIST_DOMAINS_HAS_CHECKPOINT and
VIR_CONNECT_LIST_DOMAINS_NO_CHECKPOINT, for filtering based on whether
a domain has checkpoints.

Example of usage:

  virDomainPtr *domains;
  size_t i;
  int ret;
  unsigned int flags = VIR_CONNECT_LIST_DOMAINS_RUNNING |
                       VIR_CONNECT_LIST_DOMAINS_PERSISTENT;
  ret = virConnectListAllDomains(conn, &domains, flags);
  if (ret < 0)
      error();
  for (i = 0; i < ret; i++) {
       do_something_with_domain(domains[i]);
       //here or in a separate loop if needed
       virDomainFree(domains[i]);
  }
  free(domains);]]></info>
      <return type='int' info='the number of domains found or -1 and sets domains to NULL in case of error.  On success, the array stored into @domains is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virDomainFree() on each array element, then calling free() on @domains.'/>
      <arg name='conn' type='virConnectPtr' info='Pointer to the hypervisor connection.'/>
      <arg name='domains' type='virDomainPtr **' info='Pointer to a variable to store the array containing domain objects or NULL if the list is not required (just returns number of guests).'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectListAllDomainsFlags'/>
    </function>
    <function name='virConnectListAllInterfaces' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Collect the list of interfaces, and allocate an array to store those
objects. This API solves the race inherent between virConnectListInterfaces
and virConnectListDefinedInterfaces.

Normally, all interfaces are returned; however, @flags can be used to
filter the results for a smaller list of targeted interfaces.  The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a interface, and where all bits
within a group describe all possible interfaces.

The only group of @flags is VIR_CONNECT_LIST_INTERFACES_ACTIVE (up) and
VIR_CONNECT_LIST_INTERFACES_INACTIVE (down) to filter the interfaces by state.]]></info>
      <return type='int' info='the number of interfaces found or -1 and sets @ifaces to  NULL in case of error.  On success, the array stored into @ifaces is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virStorageInterfaceFree() on each array element, then calling free() on @ifaces.'/>
      <arg name='conn' type='virConnectPtr' info='Pointer to the hypervisor connection.'/>
      <arg name='ifaces' type='virInterfacePtr **' info='Pointer to a variable to store the array containing the interface objects or NULL if the list is not required (just returns number of interfaces).'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectListAllInterfacesFlags.'/>
    </function>
    <function name='virConnectListAllNWFilterBindings' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Collect the list of network filters, and allocate an array to store those
objects.]]></info>
      <return type='int' info='the number of network filters found or -1 and sets @filters to  NULL in case of error.  On success, the array stored into @filters is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virNWFilterFree() on each array element, then calling free() on @filters.'/>
      <arg name='conn' type='virConnectPtr' info='Pointer to the hypervisor connection.'/>
      <arg name='bindings' type='virNWFilterBindingPtr **' info='Pointer to a variable to store the array containing the network filter objects or NULL if the list is not required (just returns number of network filters).'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virConnectListAllNWFilters' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Collect the list of network filters, and allocate an array to store those
objects.]]></info>
      <return type='int' info='the number of network filters found or -1 and sets @filters to  NULL in case of error.  On success, the array stored into @filters is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virNWFilterFree() on each array element, then calling free() on @filters.'/>
      <arg name='conn' type='virConnectPtr' info='Pointer to the hypervisor connection.'/>
      <arg name='filters' type='virNWFilterPtr **' info='Pointer to a variable to store the array containing the network filter objects or NULL if the list is not required (just returns number of network filters).'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virConnectListAllNetworks' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Collect the list of networks, and allocate an array to store those
objects. This API solves the race inherent between virConnectListNetworks
and virConnectListDefinedNetworks.

Normally, all networks are returned; however, @flags can be used to
filter the results for a smaller list of targeted networks.  The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a network, and where all bits
within a group describe all possible networks.

The first group of @flags is VIR_CONNECT_LIST_NETWORKS_ACTIVE (up) and
VIR_CONNECT_LIST_NETWORKS_INACTIVE (down) to filter the networks by state.

The second group of @flags is VIR_CONNECT_LIST_NETWORKS_PERSISTENT (defined)
and VIR_CONNECT_LIST_NETWORKS_TRANSIENT (running but not defined), to filter
the networks by whether they have persistent config or not.

The third group of @flags is VIR_CONNECT_LIST_NETWORKS_AUTOSTART
and VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART, to filter the networks by
whether they are marked as autostart or not.]]></info>
      <return type='int' info='the number of networks found or -1 and sets @nets to  NULL in case of error.  On success, the array stored into @nets is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virNetworkFree() on each array element, then calling free() on @nets.'/>
      <arg name='conn' type='virConnectPtr' info='Pointer to the hypervisor connection.'/>
      <arg name='nets' type='virNetworkPtr **' info='Pointer to a variable to store the array containing the network objects or NULL if the list is not required (just returns number of networks).'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectListAllNetworksFlags.'/>
    </function>
    <function name='virConnectListAllNodeDevices' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Collect the list of node devices, and allocate an array to store those
objects.

Normally, all node devices are returned; however, @flags can be used to
filter the results for a smaller list of targeted node devices.  The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a node device, and where all bits
within a group describe all possible node devices.

Only one group of the @flags is provided to filter the node devices by
capability type, flags include:
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_DRM
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV_TYPES
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV
  VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV]]></info>
      <return type='int' info='the number of node devices found or -1 and sets @devices to NULL in case of error.  On success, the array stored into @devices is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virNodeDeviceFree() on each array element, then calling free() on @devices.'/>
      <arg name='conn' type='virConnectPtr' info='Pointer to the hypervisor connection.'/>
      <arg name='devices' type='virNodeDevicePtr **' info='Pointer to a variable to store the array containing the node device objects or NULL if the list is not required (just returns number of node devices).'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectListAllNodeDeviceFlags.'/>
    </function>
    <function name='virConnectListAllSecrets' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Collect the list of secrets, and allocate an array to store those
objects.

Normally, all secrets are returned; however, @flags can be used to
filter the results for a smaller list of targeted secrets. The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a secret, and where all bits
within a group describe all possible secrets.

The first group of @flags is used to filter secrets by its storage
location. Flag VIR_CONNECT_LIST_SECRETS_EPHEMERAL selects secrets that
are kept only in memory. Flag VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL
selects secrets that are kept in persistent storage.

The second group of @flags is used to filter secrets by privacy. Flag
VIR_CONNECT_LIST_SECRETS_PRIVATE selects secrets that are never revealed
to any caller of libvirt nor to any other node. Flag
VIR_CONNECT_LIST_SECRETS_NO_PRIVATE selects non-private secrets.]]></info>
      <return type='int' info='the number of secrets found or -1 and sets @secrets to NULL in case of error.  On success, the array stored into @secrets is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virSecretFree() on each array element, then calling free() on @secrets.'/>
      <arg name='conn' type='virConnectPtr' info='Pointer to the hypervisor connection.'/>
      <arg name='secrets' type='virSecretPtr **' info='Pointer to a variable to store the array containing the secret objects or NULL if the list is not required (just returns the number of secrets).'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectListAllSecretsFlags.'/>
    </function>
    <function name='virConnectListAllStoragePools' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Collect the list of storage pools, and allocate an array to store those
objects. This API solves the race inherent between
virConnectListStoragePools and virConnectListDefinedStoragePools.

Normally, all storage pools are returned; however, @flags can be used to
filter the results for a smaller list of targeted pools.  The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a pool, and where all bits
within a group describe all possible pools.

The first group of @flags is VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE (online)
and VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE (offline) to filter the pools
by state.

The second group of @flags is VIR_CONNECT_LIST_STORAGE_POOLS_PERSITENT
(defined) and VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT (running but not
defined), to filter the pools by whether they have persistent config or not.

The third group of @flags is VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART
and VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART, to filter the pools by
whether they are marked as autostart or not.

The last group of @flags is provided to filter the pools by the types,
the flags include:
VIR_CONNECT_LIST_STORAGE_POOLS_DIR
VIR_CONNECT_LIST_STORAGE_POOLS_FS
VIR_CONNECT_LIST_STORAGE_POOLS_NETFS
VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL
VIR_CONNECT_LIST_STORAGE_POOLS_DISK
VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI
VIR_CONNECT_LIST_STORAGE_POOLS_SCSI
VIR_CONNECT_LIST_STORAGE_POOLS_MPATH
VIR_CONNECT_LIST_STORAGE_POOLS_RBD
VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG
VIR_CONNECT_LIST_STORAGE_POOLS_GLUSTER
VIR_CONNECT_LIST_STORAGE_POOLS_ZFS
VIR_CONNECT_LIST_STORAGE_POOLS_VSTORAGE
VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI_DIRECT]]></info>
      <return type='int' info='the number of storage pools found or -1 and sets @pools to NULL in case of error.  On success, the array stored into @pools is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virStoragePoolFree() on each array element, then calling free() on @pools.'/>
      <arg name='conn' type='virConnectPtr' info='Pointer to the hypervisor connection.'/>
      <arg name='pools' type='virStoragePoolPtr **' info='Pointer to a variable to store the array containing storage pool objects or NULL if the list is not required (just returns number of pools).'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectListAllStoragePoolsFlags.'/>
    </function>
    <function name='virConnectListDefinedDomains' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[list the defined but inactive domains, stores the pointers to the names
in @names

For active domains, see virConnectListDomains().  For more control over
the results, see virConnectListAllDomains().]]></info>
      <return type='int' info='the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a domain can be defined between a call to virConnectNumOfDefinedDomains() and this call; you are only guaranteed that all currently defined domains were listed if the return is less than @maxids.  The client must call free() on each returned name.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='pointer to an array to store the names'/>
      <arg name='maxnames' type='int' info='size of the array'/>
    </function>
    <function name='virConnectListDefinedInterfaces' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Collect the list of defined (inactive) physical host interfaces,
and store their names in @names.

For more control over the results, see virConnectListAllInterfaces().]]></info>
      <return type='int' info='the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a interface can be defined between a call to virConnectNumOfDefinedInterfaces() and this call; you are only guaranteed that all currently defined interfaces were listed if the return is less than @maxnames.  The client must call free() on each returned name.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of interfaces'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectListDefinedNetworks' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[list the inactive networks, stores the pointers to the names in @names

For more control over the results, see virConnectListAllNetworks().]]></info>
      <return type='int' info='the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a network can be defined between a call to virConnectNumOfDefinedNetworks() and this call; you are only guaranteed that all currently defined networks were listed if the return is less than @maxnames.  The client must call free() on each returned name.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='pointer to an array to store the names'/>
      <arg name='maxnames' type='int' info='size of the array'/>
    </function>
    <function name='virConnectListDefinedStoragePools' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Provides the list of names of inactive storage pools up to maxnames.
If there are more than maxnames, the remaining names will be silently
ignored.

For more control over the results, see virConnectListAllStoragePools().]]></info>
      <return type='int' info='the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a pool can be defined between a call to virConnectNumOfDefinedStoragePools() and this call; you are only guaranteed that all currently defined pools were listed if the return is less than @maxnames.  The client must call free() on each returned name.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='names' type='char ** const' info='array of char * to fill with pool names (allocated by caller)'/>
      <arg name='maxnames' type='int' info='size of the names array'/>
    </function>
    <function name='virConnectListDomains' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Collect the list of active domains, and store their IDs in array @ids

For inactive domains, see virConnectListDefinedDomains().  For more
control over the results, see virConnectListAllDomains().]]></info>
      <return type='int' info='the number of domains found or -1 in case of error.  Note that this command is inherently racy; a domain can be started between a call to virConnectNumOfDomains() and this call; you are only guaranteed that all currently active domains were listed if the return is less than @maxids.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='ids' type='int *' info='array to collect the list of IDs of active domains'/>
      <arg name='maxids' type='int' info='size of @ids'/>
    </function>
    <function name='virConnectListInterfaces' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Collect the list of active physical host interfaces,
and store their names in @names

For more control over the results, see virConnectListAllInterfaces().]]></info>
      <return type='int' info='the number of interfaces found or -1 in case of error.  Note that this command is inherently racy; a interface can be started between a call to virConnectNumOfInterfaces() and this call; you are only guaranteed that all currently active interfaces were listed if the return is less than @maxnames. The client must call free() on each returned name.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of interfaces'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectListNWFilters' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Collect the list of network filters, and store their names in @names]]></info>
      <return type='int' info='the number of network filters found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of network filters'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectListNetworks' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Collect the list of active networks, and store their names in @names

For more control over the results, see virConnectListAllNetworks().]]></info>
      <return type='int' info='the number of networks found or -1 in case of error.  Note that this command is inherently racy; a network can be started between a call to virConnectNumOfNetworks() and this call; you are only guaranteed that all currently active networks were listed if the return is less than @maxnames. The client must call free() on each returned name.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of active networks'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectListSecrets' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[List UUIDs of defined secrets, store pointers to names in uuids.]]></info>
      <return type='int' info='the number of UUIDs provided in the array, or -1 on failure.'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='uuids' type='char **' info='Pointer to an array to store the UUIDs'/>
      <arg name='maxuuids' type='int' info='size of the array.'/>
    </function>
    <function name='virConnectListStoragePools' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Provides the list of names of active storage pools up to maxnames.
If there are more than maxnames, the remaining names will be silently
ignored.

For more control over the results, see virConnectListAllStoragePools().]]></info>
      <return type='int' info='the number of pools found or -1 in case of error.  Note that this command is inherently racy; a pool can be started between a call to virConnectNumOfStoragePools() and this call; you are only guaranteed that all currently active pools were listed if the return is less than @maxnames. The client must call free() on each returned name.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='names' type='char ** const' info='array of char * to fill with pool names (allocated by caller)'/>
      <arg name='maxnames' type='int' info='size of the names array'/>
    </function>
    <function name='virConnectNetworkEventDeregisterAny' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Removes an event callback. The callbackID parameter should be the
value obtained from a previous virConnectNetworkEventRegisterAny() method.]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='callbackID' type='int' info='the callback identifier'/>
    </function>
    <functype name='virConnectNetworkEventGenericCallback' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[A generic network event callback handler, for use with
virConnectNetworkEventRegisterAny(). Specific events usually
have a customization with extra parameters, often with @opaque being
passed in a different parameter position; use VIR_NETWORK_EVENT_CALLBACK()
when registering an appropriate handler.]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='the connection pointer'/>
      <arg name='net' type='virNetworkPtr' info='the network pointer'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectNetworkEventLifecycleCallback' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[This callback occurs when the network is started or stopped.

The callback signature to use when registering for an event of type
VIR_NETWORK_EVENT_ID_LIFECYCLE with virConnectNetworkEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='net' type='virNetworkPtr' info='network on which the event occurred'/>
      <arg name='event' type='int' info='The specific virNetworkEventLifeCycleType which occurred'/>
      <arg name='detail' type='int' info='contains some details on the reason of the event. It will be 0 for the while.'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <function name='virConnectNetworkEventRegisterAny' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Adds a callback to receive notifications of arbitrary network events
occurring on a network.  This function requires that an event loop
has been previously registered with virEventRegisterImpl() or
virEventRegisterDefaultImpl().

If @net is NULL, then events will be monitored for any network. If @net
is non-NULL, then only the specific network will be monitored.

Most types of event have a callback providing a custom set of parameters
for the event. When registering an event, it is thus necessary to use
the VIR_NETWORK_EVENT_CALLBACK() macro to cast the supplied function pointer
to match the signature of this method.

The virNetworkPtr object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the network object after the callback
returns, it shall take a reference to it, by calling virNetworkRef().
The reference can be released once the object is no longer required
by calling virNetworkFree().

The return value from this method is a positive integer identifier
for the callback. To unregister a callback, this callback ID should
be passed to the virConnectNetworkEventDeregisterAny() method.]]></info>
      <return type='int' info='a callback identifier on success, -1 on failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='net' type='virNetworkPtr' info='pointer to the network'/>
      <arg name='eventID' type='int' info='the event type to receive'/>
      <arg name='cb' type='virConnectNetworkEventGenericCallback' info='callback to the function handling network events'/>
      <arg name='opaque' type='void *' info='opaque data to pass on to the callback'/>
      <arg name='freecb' type='virFreeCallback' info='optional function to deallocate opaque when not used anymore'/>
    </function>
    <function name='virConnectNodeDeviceEventDeregisterAny' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Removes an event callback. The callbackID parameter should be the
value obtained from a previous virConnectNodeDeviceEventRegisterAny() method.]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='callbackID' type='int' info='the callback identifier'/>
    </function>
    <functype name='virConnectNodeDeviceEventGenericCallback' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[A generic node device event callback handler, for use with
virConnectNodeDeviceEventRegisterAny(). Specific events usually
have a customization with extra parameters, often with @opaque being
passed in a different parameter position; use
VIR_NODE_DEVICE_EVENT_CALLBACK() when registering an appropriate handler.]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='the connection pointer'/>
      <arg name='dev' type='virNodeDevicePtr' info='the node device pointer'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectNodeDeviceEventLifecycleCallback' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[This callback is called when a node device lifecycle action is performed,
like added or removed.

The callback signature to use when registering for an event of type
VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE with
virConnectNodeDeviceEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dev' type='virNodeDevicePtr' info='node device on which the event occurred'/>
      <arg name='event' type='int' info='The specific virNodeDeviceEventLifeCycleType which occurred'/>
      <arg name='detail' type='int' info='contains some details on the reason of the event.'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <function name='virConnectNodeDeviceEventRegisterAny' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Adds a callback to receive notifications of arbitrary node device events
occurring on a node device. This function requires that an event loop
has been previously registered with virEventRegisterImpl() or
virEventRegisterDefaultImpl().

If @dev is NULL, then events will be monitored for any node device.
If @dev is non-NULL, then only the specific node device will be monitored.

Most types of events have a callback providing a custom set of parameters
for the event. When registering an event, it is thus necessary to use
the VIR_NODE_DEVICE_EVENT_CALLBACK() macro to cast the
supplied function pointer to match the signature of this method.

The virNodeDevicePtr object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the node device object after the callback
returns, it shall take a reference to it, by calling virNodeDeviceRef().
The reference can be released once the object is no longer required
by calling virNodeDeviceFree().

The return value from this method is a positive integer identifier
for the callback. To unregister a callback, this callback ID should
be passed to the virConnectNodeDeviceEventDeregisterAny() method.]]></info>
      <return type='int' info='a callback identifier on success, -1 on failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
      <arg name='eventID' type='int' info='the event type to receive'/>
      <arg name='cb' type='virConnectNodeDeviceEventGenericCallback' info='callback to the function handling node device events'/>
      <arg name='opaque' type='void *' info='opaque data to pass on to the callback'/>
      <arg name='freecb' type='virFreeCallback' info='optional function to deallocate opaque when not used anymore'/>
    </function>
    <function name='virConnectNumOfDefinedDomains' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Provides the number of defined but inactive domains.]]></info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDefinedInterfaces' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Provides the number of defined (inactive) interfaces on the physical host.]]></info>
      <return type='int' info='the number of defined interface found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDefinedNetworks' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Provides the number of inactive networks.]]></info>
      <return type='int' info='the number of networks found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDefinedStoragePools' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Provides the number of inactive storage pools]]></info>
      <return type='int' info='the number of pools found, or -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDomains' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Provides the number of active domains.]]></info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfInterfaces' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Provides the number of active interfaces on the physical host.]]></info>
      <return type='int' info='the number of active interfaces found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfNWFilters' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Provides the number of nwfilters.]]></info>
      <return type='int' info='the number of nwfilters found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfNetworks' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Provides the number of active networks.]]></info>
      <return type='int' info='the number of network found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfSecrets' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Fetch number of currently defined secrets.]]></info>
      <return type='int' info='the number currently defined secrets.'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
    </function>
    <function name='virConnectNumOfStoragePools' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Provides the number of active storage pools]]></info>
      <return type='int' info='the number of pools found, or -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
    </function>
    <function name='virConnectOpen' file='libvirt-host' module='libvirt'>
      <info><![CDATA[This function should be called first to get a connection to the
Hypervisor and xen store

If @name is NULL, if the LIBVIRT_DEFAULT_URI environment variable is set,
then it will be used. Otherwise if the client configuration file
has the "uri_default" parameter set, then it will be used. Finally
probing will be done to determine a suitable default driver to activate.
This involves trying each hypervisor in turn until one successfully opens.

If connecting to an unprivileged hypervisor driver which requires
the libvirtd daemon to be active, it will automatically be launched
if not already running. This can be prevented by setting the
environment variable LIBVIRT_AUTOSTART=0

URIs are documented at https://libvirt.org/uri.html

virConnectClose should be used to release the resources after the connection
is no longer needed.]]></info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error'/>
      <arg name='name' type='const char *' info='(optional) URI of the hypervisor'/>
    </function>
    <function name='virConnectOpenAuth' file='libvirt-host' module='libvirt'>
      <info><![CDATA[This function should be called first to get a connection to the
Hypervisor. If necessary, authentication will be performed fetching
credentials via the callback

See virConnectOpen for notes about environment variables which can
have an effect on opening drivers and freeing the connection resources

URIs are documented at https://libvirt.org/uri.html]]></info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error'/>
      <arg name='name' type='const char *' info='(optional) URI of the hypervisor'/>
      <arg name='auth' type='virConnectAuthPtr' info='Authenticate callback parameters'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virConnectFlags'/>
    </function>
    <function name='virConnectOpenReadOnly' file='libvirt-host' module='libvirt'>
      <info><![CDATA[This function should be called first to get a restricted connection to the
library functionalities. The set of APIs usable are then restricted
on the available methods to control the domains.

See virConnectOpen for notes about environment variables which can
have an effect on opening drivers and freeing the connection resources

URIs are documented at https://libvirt.org/uri.html]]></info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error'/>
      <arg name='name' type='const char *' info='(optional) URI of the hypervisor'/>
    </function>
    <function name='virConnectRef' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Increment the reference count on the connection. For each
additional call to this method, there shall be a corresponding
call to virConnectClose to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a connection would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='the connection to hold a reference on'/>
    </function>
    <function name='virConnectRegisterCloseCallback' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Registers a callback to be invoked when the connection
is closed. This callback is invoked when there is any
condition that causes the socket connection to the
hypervisor to be closed.

This function is only applicable to hypervisor drivers
which maintain a persistent open connection. Drivers
which open a new connection for every operation will
not invoke this.

The @freecb must not invoke any other libvirt public
APIs, since it is not called from a re-entrant safe
context.]]></info>
      <return type='int' info='0 on success, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to connection object'/>
      <arg name='cb' type='virConnectCloseFunc' info='callback to invoke upon close'/>
      <arg name='opaque' type='void *' info='user data to pass to @cb'/>
      <arg name='freecb' type='virFreeCallback' info='callback to free @opaque'/>
    </function>
    <function name='virConnectSecretEventDeregisterAny' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Removes an event callback. The callbackID parameter should be the
value obtained from a previous virConnectSecretEventRegisterAny() method.]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='callbackID' type='int' info='the callback identifier'/>
    </function>
    <functype name='virConnectSecretEventGenericCallback' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[A generic secret event callback handler, for use with
virConnectSecretEventRegisterAny(). Specific events usually
have a customization with extra parameters, often with @opaque being
passed in a different parameter position; use
VIR_SECRET_EVENT_CALLBACK() when registering an appropriate handler.]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='the connection pointer'/>
      <arg name='secret' type='virSecretPtr' info='the secret pointer'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectSecretEventLifecycleCallback' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[This callback is called when a secret lifecycle action is performed,
like added or removed.

The callback signature to use when registering for an event of type
VIR_SECRET_EVENT_ID_LIFECYCLE with
virConnectSecretEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='secret' type='virSecretPtr' info='secret on which the event occurred'/>
      <arg name='event' type='int' info='The specific virSecretEventLifeCycleType which occurred'/>
      <arg name='detail' type='int' info='contains some details on the reason of the event.'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <function name='virConnectSecretEventRegisterAny' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Adds a callback to receive notifications of arbitrary secret events
occurring on a secret. This function requires that an event loop
has been previously registered with virEventRegisterImpl() or
virEventRegisterDefaultImpl().

If @secret is NULL, then events will be monitored for any secret.
If @secret is non-NULL, then only the specific secret will be monitored.

Most types of events have a callback providing a custom set of parameters
for the event. When registering an event, it is thus necessary to use
the VIR_SECRET_EVENT_CALLBACK() macro to cast the
supplied function pointer to match the signature of this method.

The virSecretPtr object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the secret object after the callback
returns, it shall take a reference to it, by calling virSecretRef().
The reference can be released once the object is no longer required
by calling virSecretFree().

The return value from this method is a positive integer identifier
for the callback. To unregister a callback, this callback ID should
be passed to the virConnectSecretEventDeregisterAny() method.]]></info>
      <return type='int' info='a callback identifier on success, -1 on failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='secret' type='virSecretPtr' info='pointer to the secret'/>
      <arg name='eventID' type='int' info='the event type to receive'/>
      <arg name='cb' type='virConnectSecretEventGenericCallback' info='callback to the function handling secret events'/>
      <arg name='opaque' type='void *' info='opaque data to pass on to the callback'/>
      <arg name='freecb' type='virFreeCallback' info='optional function to deallocate opaque when not used anymore'/>
    </function>
    <function name='virConnectSetIdentity' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Override the default identity information associated with
the connection. When connecting to a stateful driver over
a UNIX socket, the daemon will interrogate the remote end
of the UNIX socket to acquire the application's identity.
This identity is used for the fine grained access control
checks on API calls.

There may be times when application is operating on behalf
of a variety of users, and thus the identity that the
application runs as is not appropriate for access control
checks. In this case, if the application is considered
trustworthy, it can supply alternative identity information.

The driver may reject the request to change the identity
on a connection if the application is not trustworthy.]]></info>
      <return type='int' info='0 if the identity change was accepted, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='params' type='virTypedParameterPtr' info='parameters containing the identity attributes'/>
      <arg name='nparams' type='int' info='size of @params array'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virConnectSetKeepAlive' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Start sending keepalive messages after @interval seconds of inactivity and
consider the connection to be broken when no response is received after
@count keepalive messages sent in a row.  In other words, sending count + 1
keepalive message results in closing the connection.  When @interval is
<= 0, no keepalive messages will be sent.  When @count is 0, the connection
will be automatically closed after @interval seconds of inactivity without
sending any keepalive messages.

Note: The client has to implement and run an event loop with
virEventRegisterImpl() or virEventRegisterDefaultImpl() to be able to
use keepalive messages.  Failure to do so may result in connections
being closed unexpectedly.

Note: This API function controls only keepalive messages sent by the client.
If the server is configured to use keepalive you still need to run the event
loop to respond to them, even if you disable keepalives by this function.]]></info>
      <return type='int' info='-1 on error, 0 on success, 1 when remote party doesn&apos;t support keepalive messages.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
      <arg name='interval' type='int' info='number of seconds of inactivity before a keepalive message is sent'/>
      <arg name='count' type='unsigned int' info='number of messages that can be sent in a row'/>
    </function>
    <function name='virConnectStoragePoolEventDeregisterAny' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Removes an event callback. The callbackID parameter should be the
value obtained from a previous virConnectStoragePoolEventRegisterAny() method.]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='callbackID' type='int' info='the callback identifier'/>
    </function>
    <functype name='virConnectStoragePoolEventGenericCallback' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[A generic storage pool event callback handler, for use with
virConnectStoragePoolEventRegisterAny(). Specific events usually
have a customization with extra parameters, often with @opaque being
passed in a different parameter position; use
VIR_STORAGE_POOL_EVENT_CALLBACK() when registering an appropriate handler.]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='the connection pointer'/>
      <arg name='pool' type='virStoragePoolPtr' info='the pool pointer'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectStoragePoolEventLifecycleCallback' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[This callback is called when a pool lifecycle action is performed, like start
or stop.

The callback signature to use when registering for an event of type
VIR_STORAGE_POOL_EVENT_ID_LIFECYCLE with
virConnectStoragePoolEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='pool' type='virStoragePoolPtr' info='pool on which the event occurred'/>
      <arg name='event' type='int' info='The specific virStoragePoolEventLifeCycleType which occurred'/>
      <arg name='detail' type='int' info='contains some details on the reason of the event.'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <function name='virConnectStoragePoolEventRegisterAny' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Adds a callback to receive notifications of arbitrary storage pool events
occurring on a storage pool. This function requires that an event loop
has been previously registered with virEventRegisterImpl() or
virEventRegisterDefaultImpl().

If @pool is NULL, then events will be monitored for any storage pool.
If @pool is non-NULL, then only the specific storage pool will be monitored.

Most types of events have a callback providing a custom set of parameters
for the event. When registering an event, it is thus necessary to use
the VIR_STORAGE_POOL_EVENT_CALLBACK() macro to cast the
supplied function pointer to match the signature of this method.

The virStoragePoolPtr object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the storage pool object after the callback
returns, it shall take a reference to it, by calling virStoragePoolRef().
The reference can be released once the object is no longer required
by calling virStoragePoolFree().

The return value from this method is a positive integer identifier
for the callback. To unregister a callback, this callback ID should
be passed to the virConnectStoragePoolEventDeregisterAny() method.]]></info>
      <return type='int' info='a callback identifier on success, -1 on failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to the storage pool'/>
      <arg name='eventID' type='int' info='the event type to receive'/>
      <arg name='cb' type='virConnectStoragePoolEventGenericCallback' info='callback to the function handling network events'/>
      <arg name='opaque' type='void *' info='opaque data to pass on to the callback'/>
      <arg name='freecb' type='virFreeCallback' info='optional function to deallocate opaque when not used anymore'/>
    </function>
    <function name='virConnectUnregisterCloseCallback' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Unregisters the callback previously set with the
virConnectRegisterCloseCallback method. The callback
will no longer receive notifications when the connection
closes. If a virFreeCallback was provided at time of
registration, it will be invoked]]></info>
      <return type='int' info='0 on success, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to connection object'/>
      <arg name='cb' type='virConnectCloseFunc' info='pointer to the current registered callback'/>
    </function>
    <function name='virCopyLastError' file='virterror' module='virerror'>
      <info><![CDATA[Copy the content of the last error caught at the library level

The error object is kept in thread local storage, so separate
threads can safely access this concurrently.

One will need to free the result with virResetError()]]></info>
      <return type='int' info='error code or -1 in case of parameter error.'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virDefaultErrorFunc' file='virterror' module='virerror'>
      <info><![CDATA[Default routine reporting an error to stderr.]]></info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the error.'/>
    </function>
    <function name='virDomainAbortJob' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Requests that the current background job be aborted at the
soonest opportunity. In case the job is a migration in a post-copy mode,
virDomainAbortJob will report an error (see virDomainMigrateStartPostCopy
for more details).]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainAddIOThread' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically add an IOThread to the domain. It is left up to the
underlying virtual hypervisor to determine the valid range for an
@iothread_id and determining whether the @iothread_id already exists.

Note that this call can fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrarily limited.
This function requires privileged access to the hypervisor.

@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain
and may fail if domain is not alive.
If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='iothread_id' type='unsigned int' info='the specific IOThread ID value to add'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainAgentSetResponseTimeout' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Set how long to wait for a response from guest agent commands. By default,
agent commands block forever waiting for a response.

@timeout must be a value from virDomainAgentResponseTimeoutValues or
positive:

  VIR_DOMAIN_AGENT_RESPONSE_TIMEOUT_BLOCK(-2): meaning to block forever
     waiting for a result.
  VIR_DOMAIN_AGENT_RESPONSE_TIMEOUT_DEFAULT(-1): use default timeout value.
  VIR_DOMAIN_AGENT_RESPONSE_TIMEOUT_NOWAIT(0): does not wait.
  positive value: wait for @timeout seconds]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='timeout' type='int' info='timeout in seconds'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainAttachDevice' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Create a virtual device attachment to backend.  This function,
having hotplug semantics, is only allowed on an active domain.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.

Be aware that hotplug changes might not persist across a domain going
into S4 state (also known as hibernation) unless you also modify the
persistent domain definition.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
    </function>
    <function name='virDomainAttachDeviceFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Attach a virtual device to a domain, using the flags parameter
to control how the device is attached.  VIR_DOMAIN_AFFECT_CURRENT
specifies that the device allocation is made based on current domain
state.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be
allocated to the active domain instance only and is not added to the
persisted domain configuration.  VIR_DOMAIN_AFFECT_CONFIG
specifies that the device shall be allocated to the persisted domain
configuration only.  Note that the target hypervisor must return an
error if unable to satisfy flags.  E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.

Be aware that hotplug changes might not persist across a domain going
into S4 state (also known as hibernation) unless you also modify the
persistent domain definition.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainDeviceModifyFlags'/>
    </function>
    <function name='virDomainBackupBegin' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Start a point-in-time backup job for the specified disks of a
running domain.

A backup job is a domain job and thus mutually exclusive with any other
domain job such as migration.

For now, backup jobs are also mutually exclusive with any
other block job on the same device, although this restriction may
be lifted in a future release. Progress of the backup job can be
tracked via virDomainGetJobStats(). Completion of the job is also announced
asynchronously via VIR_DOMAIN_EVENT_ID_JOB_COMPLETED event.

There are two fundamental backup approaches. The first, called a
push model, instructs the hypervisor to copy the state of the guest
disk to the designated storage destination (which may be on the
local file system or a network device). In this mode, the
hypervisor writes the content of the guest disk to the destination,
then emits VIR_DOMAIN_EVENT_ID_JOB_COMPLETED when the backup is
either complete or failed (the backup image is invalid if the job
fails or virDomainAbortJob() is used prior to the event being
emitted). This kind of the job finishes automatically. Users can
determine success by using virDomainGetJobStats() with
VIR_DOMAIN_JOB_STATS_COMPLETED flag.

The second, called a pull model, instructs the hypervisor to expose
the state of the guest disk over an NBD export. A third-party
client can then connect to this export and read whichever portions
of the disk it desires.  In this mode libvirt has to be informed via
virDomainAbortJob() when the third-party NBD client is done and the backup
resources can be released.

The @backupXML parameter contains details about the backup in the top-level
element <domainbackup>, including which backup mode to use, whether the
backup is incremental from a previous checkpoint, which disks
participate in the backup, the destination for a push model backup,
and the temporary storage and NBD server details for a pull model
backup.

virDomainBackupGetXMLDesc() can be called to learn actual
values selected.  For more information, see
formatcheckpoint.html#BackupAttributes.

The @checkpointXML parameter is optional; if non-NULL, then libvirt
behaves as if virDomainCheckpointCreateXML() were called to create
a checkpoint atomically covering the same point in time as the
backup.

The VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL specifies that the output or
temporary files described by the @backupXML document were created by the
caller with correct format and size to hold the backup or temporary data.

The creation of a new checkpoint allows for future incremental backups.
Note that some hypervisors may require a particular disk format, such as
qcow2, in order to take advantage of checkpoints, while allowing arbitrary
formats if checkpoints are not involved.]]></info>
      <return type='int' info='0 on success or -1 on failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='backupXML' type='const char *' info='description of the requested backup'/>
      <arg name='checkpointXML' type='const char *' info='description of a checkpoint to create or NULL'/>
      <arg name='flags' type='unsigned int' info='bitwise or of virDomainBackupBeginFlags'/>
    </function>
    <function name='virDomainBackupGetXMLDesc' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Queries the configuration of the active backup job.

In some cases, a user can start a backup job without supplying all
details and rely on libvirt to fill in the rest (for example,
selecting the port used for an NBD export). This API can then be
used to learn what default values were chosen.]]></info>
      <return type='char *' info='a NUL-terminated UTF-8 encoded XML instance or NULL in case of error.  The caller must free() the returned value.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainBlockCommit' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Commit changes that were made to temporary top-level files within a disk
image backing file chain into a lower-level base file.  In other words,
take all the difference between @base and @top, and update @base to contain
that difference; after the commit, any portion of the chain that previously
depended on @top will now depend on @base, and all files after @base up
to and including @top will now be invalidated.  A typical use of this
command is to reduce the length of a backing file chain after taking an
external disk snapshot.  To move data in the opposite direction, see
virDomainBlockPull().

This command starts a long-running commit block job, whose status may
be tracked by virDomainBlockJobInfo() with a job type of
VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT, and the operation can be aborted with
virDomainBlockJobAbort().  When finished, an asynchronous event is
raised to indicate the final status, and the job no longer exists.  If
the job is aborted, it is up to the hypervisor whether starting a new
job will resume from the same point, or start over.

As a special case, if @top is the active image (or NULL), and @flags
includes VIR_DOMAIN_BLOCK_COMMIT_ACTIVE, the block job will have a type
of VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT, and operates in two phases.
In the first phase, the contents are being committed into @base, and the
job can only be canceled.  The job transitions to the second phase when
the block job event with state VIR_DOMAIN_BLOCK_JOB_READY is
emitted for the given device. This information is also visible in the
live XML as 'ready="yes"' attribute of the corresponding <mirror> element.
Once in the second phase, the user must choose whether to cancel the job
(keeping @top as the active image, but now containing only the changes
since the time the job ended) or to pivot the job (adjusting to @base as
the active image, and invalidating @top).

Be aware that this command may invalidate files even if it is aborted;
the user is cautioned against relying on the contents of invalidated
intermediate files such as @top (when @top is not the active image)
without manually rebasing those files to use a backing file of a
read-only copy of @base prior to the point where the commit operation
was started (and such a rebase cannot be safely done until the commit
has successfully completed).  However, the domain itself will not have
any issues; the active layer remains valid throughout the entire commit
operation.

Some hypervisors may support a shortcut where if @flags contains
VIR_DOMAIN_BLOCK_COMMIT_DELETE, then this command will unlink all files
that were invalidated, after the commit successfully completes.

If @flags contains VIR_DOMAIN_BLOCK_COMMIT_RELATIVE, the name recorded
into the overlay of the @top image (if there is such image) as the
path to the new backing file will be kept relative to other images.
The operation will fail if libvirt can't infer the name.

By default, if @base is NULL, the commit target will be the bottom of
the backing chain; if @flags contains VIR_DOMAIN_BLOCK_COMMIT_SHALLOW,
then the immediate backing file of @top will be used instead.  If @top
is NULL, the active image at the top of the chain will be used.  Some
hypervisors place restrictions on how much can be committed, and might
fail if @base is not the immediate backing file of @top, or if @top is
the active layer in use by a running domain but @flags did not include
VIR_DOMAIN_BLOCK_COMMIT_ACTIVE, or if @top is not the top-most file;
restrictions may differ for online vs. offline domains.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or the device target shorthand (the
<target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The @base and @top parameters can be either paths to files within the
backing chain, or the device target shorthand (the <target dev='...'/>
sub-element, such as "vda") followed by an index to the backing chain
enclosed in square brackets. Backing chain indexes can be found by
inspecting //disk//backingStore/@index in the domain XML. Thus, for
example, "vda[3]" refers to the backing store with index equal to "3"
in the chain of disk "vda".

The maximum bandwidth that will be used to do the commit can be
specified with the @bandwidth parameter.  If set to 0, there is no
limit.  If @flags includes VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES,
@bandwidth is in bytes/second; otherwise, it is in MiB/second.
Values larger than 2^52 bytes/sec may be rejected due to overflow
considerations based on the word size of both client and server,
and values larger than 2^31 bytes/sec may cause overflow problems
if later queried by virDomainGetBlockJobInfo() without scaling.
Hypervisors may further restrict the range of valid bandwidth
values.  Some hypervisors do not support this feature and will
return an error if bandwidth is not 0; in this case, it might still
be possible for a later call to virDomainBlockJobSetSpeed() to
succeed.  The actual speed can be determined with
virDomainGetBlockJobInfo().]]></info>
      <return type='int' info='0 if the operation has started, -1 on failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='base' type='const char *' info='path to backing file to merge into, or device shorthand, or NULL for default'/>
      <arg name='top' type='const char *' info='path to file within backing chain that contains data to be merged, or device shorthand, or NULL to merge all possible data'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify bandwidth limit; flags determine the unit'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainBlockCommitFlags'/>
    </function>
    <function name='virDomainBlockCopy' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Copy the guest-visible contents of a disk image to a new file described
by @destxml.  The destination XML has a top-level element of <disk>, and
resembles what is used when hot-plugging a disk via virDomainAttachDevice(),
except that only sub-elements related to describing the new host resource
are necessary (sub-elements related to the guest view, such as <target>,
are ignored).  It is strongly recommended to include a <driver type='...'/>
format designation for the destination, to avoid the potential of any
security problem that might be caused by probing a file for its format.

This command starts a long-running copy.  By default, the copy will pull
the entire source chain into the destination file, but if @flags also
contains VIR_DOMAIN_BLOCK_COPY_SHALLOW, then only the top of the source
chain will be copied (the source and destination have a common backing
file).  The format of the destination file is controlled by the <driver>
sub-element of the XML.  The destination will be created unless the
VIR_DOMAIN_BLOCK_COPY_REUSE_EXT flag is present stating that the file
was pre-created with the correct format and metadata and sufficient
size to hold the copy. In case the VIR_DOMAIN_BLOCK_COPY_SHALLOW flag
is used the pre-created file has to exhibit the same guest visible contents
as the backing file of the original image. This allows a management app to
pre-create files with relative backing file names, rather than the default
of absolute backing file names.

A copy job has two parts; in the first phase, the source is copied into
the destination, and the job can only be canceled by reverting to the
source file; progress in this phase can be tracked via the
virDomainBlockJobInfo() command, with a job type of
VIR_DOMAIN_BLOCK_JOB_TYPE_COPY.  The job transitions to the second
phase when the block job event with state VIR_DOMAIN_BLOCK_JOB_READY is
emitted for the given device. This information is also visible in the
live XML as 'ready="yes"' attribute of the corresponding <mirror> element.
All further changes are saved to both source and destination.  The user must
call virDomainBlockJobAbort() to end the mirroring while choosing
whether to revert to source or pivot to the destination.  An event is
issued when the job ends, and depending on the hypervisor, an event may
also be issued when the job transitions from pulling to mirroring.  If
the job is aborted, a new job will have to start over from the beginning
of the first phase.

Some hypervisors will restrict certain actions, such as virDomainSave()
or virDomainDetachDevice(), while a copy job is active; they may
also restrict a copy job to transient domains.

If @flags contains VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB the job will not be
recoverable if the VM is turned off while job is active. This flag will
remove the restriction of copy jobs to transient domains. Note that this flag
is automatically implied if the VM is transient at the time it's started.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or the device target shorthand (the
<target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The @params and @nparams arguments can be used to set hypervisor-specific
tuning parameters, such as maximum bandwidth or granularity.  For a
parameter that the hypervisor understands, explicitly specifying 0
behaves the same as omitting the parameter, to use the hypervisor
default; however, omitting a parameter is less likely to fail.

This command is a superset of the older virDomainBlockRebase() when used
with the VIR_DOMAIN_BLOCK_REBASE_COPY flag, and offers better control
over the destination format, the ability to copy to a destination that
is not a local file, and the possibility of additional tuning parameters.]]></info>
      <return type='int' info='0 if the operation has started, -1 on failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='destxml' type='const char *' info='XML description of the copy destination'/>
      <arg name='params' type='virTypedParameterPtr' info='Pointer to block copy parameter objects, or NULL'/>
      <arg name='nparams' type='int' info='Number of block copy parameters (this value can be the same or less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainBlockCopyFlags'/>
    </function>
    <function name='virDomainBlockJobAbort' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Cancel the active block job on the given disk.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the <target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, then
by default, this function performs a synchronous operation and the caller
may assume that the operation has completed when 0 is returned.  However,
BlockJob operations may take a long time to cancel, and during this time
further domain interactions may be unresponsive.  To avoid this problem,
pass VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC in the @flags argument to enable
asynchronous behavior, returning as soon as possible.  When the job has
been canceled, a BlockJob event will be emitted, with status
VIR_DOMAIN_BLOCK_JOB_CANCELED (even if the ABORT_ASYNC flag was not
used); it is also possible to poll virDomainBlockJobInfo() to see if
the job cancellation is still pending.  This type of job can be restarted
to pick up from where it left off.

If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_COPY, then
the default is to abort the mirroring and revert to the source disk;
likewise, if the current job is VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT,
the default is to abort without changing the active layer of @disk.
Adding @flags of VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT causes this call to
fail with VIR_ERR_BLOCK_COPY_ACTIVE if the copy or commit is not yet
ready; otherwise it will swap the disk over to the new active image
to end the mirroring or active commit.  An event will be issued when the
job is ended, and it is possible to use VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC
to control whether this command waits for the completion of the job.
Restarting a copy or active commit job requires starting over from the
beginning of the first phase.]]></info>
      <return type='int' info='-1 in case of failure, 0 when successful.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainBlockJobAbortFlags'/>
    </function>
    <function name='virDomainBlockJobSetSpeed' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Set the maximum allowable bandwidth that a block job may consume.  If
bandwidth is 0, the limit will revert to the hypervisor default of
unlimited.

If @flags contains VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES, @bandwidth
is in bytes/second; otherwise, it is in MiB/second.  Values larger than
2^52 bytes/sec may be rejected due to overflow considerations based on
the word size of both client and server, and values larger than 2^31
bytes/sec may cause overflow problems if later queried by
virDomainGetBlockJobInfo() without scaling.  Hypervisors may further
restrict the range of valid bandwidth values.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the <target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.]]></info>
      <return type='int' info='-1 in case of failure, 0 when successful.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='bandwidth' type='unsigned long' info='specify bandwidth limit; flags determine the unit'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainBlockJobSetSpeedFlags'/>
    </function>
    <function name='virDomainBlockPeek' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This function allows you to read the contents of a domain's
disk device.

Typical uses for this are to determine if the domain has
written a Master Boot Record (indicating that the domain
has completed installation), or to try to work out the state
of the domain's filesystems.

(Note that in the local case you might try to open the
block device or file directly, but that won't work in the
remote case, nor if you don't have sufficient permission.
Hence the need for this call).

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the <target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

'offset' and 'size' represent an area which must lie entirely
within the device or file.  'size' may be 0 to test if the
call would succeed.

'buffer' is the return buffer and must be at least 'size' bytes.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to <= 65536 bytes.
However, with 0.9.13 this RPC limit has been raised to 1M byte.
Starting with version 1.0.6 the RPC limit has been raised again.
Now large requests up to 16M byte are supported.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='offset' type='unsigned long long' info='offset within block device'/>
      <arg name='size' type='size_t' info='size to read'/>
      <arg name='buffer' type='void *' info='return buffer (must be at least size bytes)'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainBlockPull' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Populate a disk image with data from its backing image.  Once all data from
its backing image has been pulled, the disk no longer depends on a backing
image.  This function pulls data for the entire device in the background.
Progress of the operation can be checked with virDomainGetBlockJobInfo() and
the operation can be aborted with virDomainBlockJobAbort().  When finished,
an asynchronous event is raised to indicate the final status.  To move
data in the opposite direction, see virDomainBlockCommit().

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the <target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The maximum bandwidth that will be used to do the copy can be
specified with the @bandwidth parameter.  If set to 0, there is no
limit.  If @flags includes VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES,
@bandwidth is in bytes/second; otherwise, it is in MiB/second.
Values larger than 2^52 bytes/sec may be rejected due to overflow
considerations based on the word size of both client and server,
and values larger than 2^31 bytes/sec may cause overflow problems
if later queried by virDomainGetBlockJobInfo() without scaling.
Hypervisors may further restrict the range of valid bandwidth
values.  Some hypervisors do not support this feature and will
return an error if bandwidth is not 0; in this case, it might still
be possible for a later call to virDomainBlockJobSetSpeed() to
succeed.  The actual speed can be determined with
virDomainGetBlockJobInfo().

This is shorthand for virDomainBlockRebase() with a NULL base.]]></info>
      <return type='int' info='0 if the operation has started, -1 on failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify bandwidth limit; flags determine the unit'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainBlockPullFlags'/>
    </function>
    <function name='virDomainBlockRebase' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Populate a disk image with data from its backing image chain, and
setting the backing image to @base, or alternatively copy an entire
backing chain to a new file @base.

When @flags is 0, this starts a pull, where @base must be the absolute
path of one of the backing images further up the chain, or NULL to
convert the disk image so that it has no backing image.  Once all
data from its backing image chain has been pulled, the disk no
longer depends on those intermediate backing images.  This function
pulls data for the entire device in the background.  Progress of
the operation can be checked with virDomainGetBlockJobInfo() with a
job type of VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, and the operation can be
aborted with virDomainBlockJobAbort().  When finished, an asynchronous
event is raised to indicate the final status, and the job no longer
exists.  If the job is aborted, a new one can be started later to
resume from the same point.

If @flags contains VIR_DOMAIN_BLOCK_REBASE_RELATIVE, the name recorded
into the active disk as the location for @base will be kept relative.
The operation will fail if libvirt can't infer the name.

When @flags includes VIR_DOMAIN_BLOCK_REBASE_COPY, this starts a copy,
where @base must be the name of a new file to copy the chain to.  By
default, the copy will pull the entire source chain into the destination
file, but if @flags also contains VIR_DOMAIN_BLOCK_REBASE_SHALLOW, then
only the top of the source chain will be copied (the source and
destination have a common backing file).  By default, @base will be
created with the same file format as the source, but this can be altered
by adding VIR_DOMAIN_BLOCK_REBASE_COPY_RAW to force the copy to be raw
(does not make sense with the shallow flag unless the source is also raw),
or by using VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT to reuse an existing file
which was pre-created with the correct format and metadata and sufficient
size to hold the copy. In case the VIR_DOMAIN_BLOCK_REBASE_SHALLOW flag
is used the pre-created file has to exhibit the same guest visible contents
as the backing file of the original image. This allows a management app to
pre-create files with relative backing file names, rather than the default
of absolute backing file names; as a security precaution, you should
generally only use reuse_ext with the shallow flag and a non-raw
destination file.  By default, the copy destination will be treated as
type='file', but using VIR_DOMAIN_BLOCK_REBASE_COPY_DEV treats the
destination as type='block' (affecting how virDomainGetBlockInfo() will
report allocation after pivoting).

A copy job has two parts; in the first phase, the @bandwidth parameter
affects how fast the source is pulled into the destination, and the job
can only be canceled by reverting to the source file; progress in this
phase can be tracked via the virDomainBlockJobInfo() command, with a
job type of VIR_DOMAIN_BLOCK_JOB_TYPE_COPY.  The job transitions to the
second phase when the job info states cur == end, and remains alive to
mirror all further changes to both source and destination.  The user
must call virDomainBlockJobAbort() to end the mirroring while choosing
whether to revert to source or pivot to the destination.  An event is
issued when the job ends, and depending on the hypervisor, an event may
also be issued when the job transitions from pulling to mirroring.  If
the job is aborted, a new job will have to start over from the beginning
of the first phase.

Some hypervisors will restrict certain actions, such as virDomainSave()
or virDomainDetachDevice(), while a copy job is active; they may
also restrict a copy job to transient domains.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or the device target shorthand (the
<target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The @base parameter can be either a path to a file within the backing
chain, or the device target shorthand (the <target dev='...'/>
sub-element, such as "vda") followed by an index to the backing chain
enclosed in square brackets. Backing chain indexes can be found by
inspecting //disk//backingStore/@index in the domain XML. Thus, for
example, "vda[3]" refers to the backing store with index equal to "3"
in the chain of disk "vda".

The maximum bandwidth that will be used to do the copy can be
specified with the @bandwidth parameter.  If set to 0, there is no
limit.  If @flags includes VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES,
@bandwidth is in bytes/second; otherwise, it is in MiB/second.
Values larger than 2^52 bytes/sec may be rejected due to overflow
considerations based on the word size of both client and server,
and values larger than 2^31 bytes/sec may cause overflow problems
if later queried by virDomainGetBlockJobInfo() without scaling.
Hypervisors may further restrict the range of valid bandwidth
values.  Some hypervisors do not support this feature and will
return an error if bandwidth is not 0; in this case, it might still
be possible for a later call to virDomainBlockJobSetSpeed() to
succeed.  The actual speed can be determined with
virDomainGetBlockJobInfo().

When @base is NULL and @flags is 0, this is identical to
virDomainBlockPull().  When @flags contains VIR_DOMAIN_BLOCK_REBASE_COPY,
this command is shorthand for virDomainBlockCopy() where the destination
XML encodes @base as a <disk type='file'>, @bandwidth is properly scaled
and passed as a typed parameter, the shallow and reuse external flags
are preserved, and remaining flags control whether the XML encodes a
destination format of raw instead of leaving the destination identical
to the source format or probed from the reused file.]]></info>
      <return type='int' info='0 if the operation has started, -1 on failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='base' type='const char *' info='path to backing file to keep, or device shorthand, or NULL for no backing file'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify bandwidth limit; flags determine the unit'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainBlockRebaseFlags'/>
    </function>
    <function name='virDomainBlockResize' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Resize a block device of domain while the domain is running.  If
@flags is 0, then @size is in kibibytes (blocks of 1024 bytes);
since 0.9.11, if @flags includes VIR_DOMAIN_BLOCK_RESIZE_BYTES,
@size is in bytes instead.  @size is taken directly as the new
size.  Depending on the file format, the hypervisor may round up
to the next alignment boundary.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the <target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

Note that this call may fail if the underlying virtualization hypervisor
does not support it; this call requires privileged access to the
hypervisor.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='disk' type='const char *' info='path to the block image, or shorthand'/>
      <arg name='size' type='unsigned long long' info='new size of the block image, see below for unit'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainBlockResizeFlags'/>
    </function>
    <function name='virDomainBlockStats' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This function returns block device (disk) stats for block
devices attached to the domain.

The @disk parameter is either the device target shorthand (the
<target dev='...'/> sub-element, such as "vda"), or (since 0.9.8)
an unambiguous source name of the block device (the <source
file='...'/> sub-element, such as "/path/to/image").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk. Some drivers might also
accept the empty string for the @disk parameter, and then yield
summary stats for the entire domain.

Domains may have more than one block device.  To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='stats' type='virDomainBlockStatsPtr' info='block device stats (returned)'/>
      <arg name='size' type='size_t' info='size of stats structure'/>
    </function>
    <function name='virDomainBlockStatsFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This function is to get block stats parameters for block
devices attached to the domain.

The @disk parameter is either the device target shorthand (the
<target dev='...'/> sub-element, such as "vda"), or (since 0.9.8)
an unambiguous source name of the block device (the <source
file='...'/> sub-element, such as "/path/to/image").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk. Some drivers might also
accept the empty string for the @disk parameter, and then yield
summary stats for the entire domain.

Domains may have more than one block device.  To get stats for
each you should make multiple calls to this function.

On input, @nparams gives the size of the @params array; on output,
@nparams gives how many slots were filled with parameter
information, which might be less but will not exceed the input
value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. (Note that block devices of different types
might support different parameters, so it might be necessary to compute
@nparams for each block device). The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again. See virDomainGetMemoryParameters() for more details.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to block stats parameter object (return value, allocated by the caller)'/>
      <arg name='nparams' type='int *' info='pointer to number of block stats; input and output'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virTypedParameterFlags'/>
    </function>
    <function name='virDomainCheckpointCreateXML' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Create a new checkpoint using @xmlDesc, with a top-level
<domaincheckpoint> element, on a running @domain.  Note that
@xmlDesc must validate against the <domaincheckpoint> XML schema.
Typically, it is more common to create a new checkpoint as part of
kicking off a backup job with virDomainBackupBegin(); however, it
is also possible to start a checkpoint without a backup.

See <a href="formatcheckpoint.html#CheckpointAttributes">Checkpoint XML</a>
for more details on @xmlDesc. In particular, some hypervisors may require
particular disk formats, such as qcow2, in order to support this
command; where @xmlDesc can be used to limit the checkpoint to a working
subset of the domain's disks.

If @flags includes VIR_DOMAIN_CHECKPOINT_CREATE_REDEFINE, then this
is a request to reinstate checkpoint metadata that was previously
captured from virDomainCheckpointGetXMLDesc() before removing that
metadata, rather than creating a new checkpoint.  Note that while
original creation can omit a number of elements from @xmlDesc (and
libvirt will supply sane defaults based on the domain state at that
point in time), a redefinition must supply more elements (as the
domain may have changed in the meantime, so that libvirt no longer
has a way to resupply correct defaults).  Not all hypervisors support
this flag.

If @flags includes VIR_DOMAIN_CHECKPOINT_CREATE_QUIESCE, then the
libvirt will attempt to use guest agent to freeze and thaw all file
systems in use within domain OS. However, if the guest agent is not
present, an error is thrown. This flag is incompatible with
VIR_DOMAIN_CHECKPOINT_CREATE_REDEFINE.]]></info>
      <return type='virDomainCheckpointPtr' info='an (opaque) new virDomainCheckpointPtr on success or NULL on failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='xmlDesc' type='const char *' info='description of the checkpoint to create'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainCheckpointCreateFlags'/>
    </function>
    <function name='virDomainCheckpointDelete' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Removes a checkpoint from the domain.

When removing a checkpoint, the record of which portions of the
disk were dirtied after the checkpoint will be merged into the
record tracked by the parent checkpoint, if any.

If @flags includes VIR_DOMAIN_CHECKPOINT_DELETE_CHILDREN, then any
descendant checkpoints are also deleted. If @flags includes
VIR_DOMAIN_CHECKPOINT_DELETE_CHILDREN_ONLY, then any descendant
checkepoints are deleted, but this checkpoint remains. These two
flags are mutually exclusive.

If @flags includes VIR_DOMAIN_CHECKPOINT_DELETE_METADATA_ONLY, then
any checkpoint metadata tracked by libvirt is removed while keeping
the checkpoint contents intact; if a hypervisor does not require
any libvirt metadata to track checkpoints, then this flag is
silently ignored.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='checkpoint' type='virDomainCheckpointPtr' info='the checkpoint to remove'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainCheckpointDeleteFlags'/>
    </function>
    <function name='virDomainCheckpointFree' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Free the domain checkpoint object.  The checkpoint itself is not modified.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='checkpoint' type='virDomainCheckpointPtr' info='a domain checkpoint object'/>
    </function>
    <function name='virDomainCheckpointGetConnect' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Provides the connection pointer associated with a checkpoint.  The
reference counter on the connection is not increased by this
call.]]></info>
      <return type='virConnectPtr' info='the connection or NULL.'/>
      <arg name='checkpoint' type='virDomainCheckpointPtr' info='a checkpoint object'/>
    </function>
    <function name='virDomainCheckpointGetDomain' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Provides the domain pointer associated with a checkpoint.  The
reference counter on the domain is not increased by this
call.]]></info>
      <return type='virDomainPtr' info='the domain or NULL.'/>
      <arg name='checkpoint' type='virDomainCheckpointPtr' info='a checkpoint object'/>
    </function>
    <function name='virDomainCheckpointGetName' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Get the public name for that checkpoint]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated as its lifetime will be the same as the checkpoint object.'/>
      <arg name='checkpoint' type='virDomainCheckpointPtr' info='a checkpoint object'/>
    </function>
    <function name='virDomainCheckpointGetParent' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Get the parent checkpoint for @checkpoint, if any.

virDomainCheckpointFree should be used to free the resources after the
checkpoint object is no longer needed.]]></info>
      <return type='virDomainCheckpointPtr' info='a domain checkpoint object or NULL in case of failure.  If the given checkpoint is a root (no parent), then the VIR_ERR_NO_DOMAIN_CHECKPOINT error is raised.'/>
      <arg name='checkpoint' type='virDomainCheckpointPtr' info='a checkpoint object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainCheckpointGetXMLDesc' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Provide an XML description of the domain checkpoint.

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_CHECKPOINT_XML_SECURE; this flag is rejected on read-only
connections.

Normally, the XML description includes an element giving a full
description of the domain at the time the checkpoint was created; to
reduce parsing time, it will be suppressed when @flags contains
VIR_DOMAIN_CHECKPOINT_XML_NO_DOMAIN.

By default, the XML description contains only static information that
does not change over time. However, when @flags contains
VIR_DOMAIN_CHECKPOINT_XML_SIZE, each <disk> listing adds an additional
attribute that shows an estimate of the current size in bytes that
have been dirtied between the time the checkpoint was created and the
current point in time. Note that updating the size may be expensive and
data will be inaccurate once guest OS writes to the disk.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='checkpoint' type='virDomainCheckpointPtr' info='a domain checkpoint object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainCheckpointXMLFlags'/>
    </function>
    <function name='virDomainCheckpointListAllChildren' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Collect the list of domain checkpoints that are children of the given
checkpoint, and allocate an array to store those objects.

If @flags contains VIR_DOMAIN_CHECKPOINT_LIST_TOPOLOGICAL,
@checkpoints is non-NULL, and no other connection is modifying
checkpoints, then it is guaranteed that for any checkpoint in the
resulting list, no checkpoints later in the list can be reached by
a sequence of virDomainCheckpointGetParent() starting from that
earlier checkpoint; otherwise, the order of checkpoints in the
resulting list is unspecified.

By default, this command covers only direct children. It is also
possible to expand things to cover all descendants, when @flags
includes VIR_DOMAIN_CHECKPOINT_LIST_DESCENDANTS.  Additional
are provided via the remaining @flags values as documented in
virDomainListAllCheckpoints(), with the exception that
VIR_DOMAIN_CHECKPOINT_LIST_ROOTS is not supported (in fact,
VIR_DOMAIN_CHECKPOINT_LIST_DESCENDANTS has the same bit value but
opposite semantics of widening rather than narrowing the listing).]]></info>
      <return type='int' info='the number of domain checkpoints found or -1 and sets @children to NULL in case of error.  On success, the array stored into @children is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virDomainCheckpointFree() on each array element, then calling free() on @children.'/>
      <arg name='checkpoint' type='virDomainCheckpointPtr' info='a domain checkpoint object'/>
      <arg name='children' type='virDomainCheckpointPtr **' info='pointer to variable to store the array containing checkpoint objects or NULL if the list is not required (just returns number of checkpoints)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainCheckpointListFlags'/>
    </function>
    <function name='virDomainCheckpointLookupByName' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Try to lookup a domain checkpoint based on its name.]]></info>
      <return type='virDomainCheckpointPtr' info='a domain checkpoint object or NULL in case of failure.  If the domain checkpoint cannot be found, then the VIR_ERR_NO_DOMAIN_CHECKPOINT error is raised.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='name' type='const char *' info='name for the domain checkpoint'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainCheckpointRef' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Increment the reference count on the checkpoint. For each
additional call to this method, there shall be a corresponding
call to virDomainCheckpointFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection and domain remain open until all threads have finished
using the checkpoint. ie, each new thread using a checkpoint would
increment the reference count.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='checkpoint' type='virDomainCheckpointPtr' info='the checkpoint to hold a reference on'/>
    </function>
    <function name='virDomainCoreDump' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This method will dump the core of a domain on a given file for analysis.
Note that for remote Xen Daemon the file path will be interpreted in
the remote host. Hypervisors may require  the user to manually ensure
proper permissions on the file named by @to.

If @flags includes VIR_DUMP_CRASH, then leave the guest shut off with
a crashed state after the dump completes.  If @flags includes
VIR_DUMP_LIVE, then make the core dump while continuing to allow
the guest to run; otherwise, the guest is suspended during the dump.
VIR_DUMP_RESET flag forces reset of the guest after dump.
The above three flags are mutually exclusive.

Additionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt
will attempt to bypass the file system cache while creating the file,
or fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.

For more control over the output format, see virDomainCoreDumpWithFormat().]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the core file'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainCoreDumpFlags'/>
    </function>
    <function name='virDomainCoreDumpWithFormat' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This method will dump the core of a domain on a given file for analysis.
Note that for remote Xen Daemon the file path will be interpreted in
the remote host. Hypervisors may require  the user to manually ensure
proper permissions on the file named by @to.

@dumpformat controls which format the dump will have; use of
VIR_DOMAIN_CORE_DUMP_FORMAT_RAW mirrors what virDomainCoreDump() will
perform.  Not all hypervisors are able to support all formats.

If @flags includes VIR_DUMP_CRASH, then leave the guest shut off with
a crashed state after the dump completes.  If @flags includes
VIR_DUMP_LIVE, then make the core dump while continuing to allow
the guest to run; otherwise, the guest is suspended during the dump.
VIR_DUMP_RESET flag forces reset of the guest after dump.
The above three flags are mutually exclusive.

Additionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt
will attempt to bypass the file system cache while creating the file,
or fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the core file'/>
      <arg name='dumpformat' type='unsigned int' info='format of domain memory&apos;s dump (one of virDomainCoreDumpFormat enum)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainCoreDumpFlags'/>
    </function>
    <function name='virDomainCreate' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.  The domain will be paused only
if restoring from managed state created from a paused domain.  For more
control, see virDomainCreateWithFlags().]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <function name='virDomainCreateLinux' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Deprecated after 0.4.6.
Renamed to virDomainCreateXML() providing identical functionality.
This existing name will be left indefinitely for API compatibility.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the domain'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainCreateWithFiles' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.

@files provides an array of file descriptors which will be
made available to the 'init' process of the guest. The file
handles exposed to the guest will be renumbered to start
from 3 (ie immediately following stderr). This is only
supported for guests which use container based virtualization
technology.

If the VIR_DOMAIN_START_PAUSED flag is set, or if the guest domain
has a managed save image that requested paused state (see
virDomainManagedSave()) the guest domain will be started, but its
CPUs will remain paused. The CPUs can later be manually started
using virDomainResume().  In all other cases, the guest domain will
be running.

If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration, save-to-file, or snapshots.

If the VIR_DOMAIN_START_BYPASS_CACHE flag is set, and there is a
managed save file for this domain (created by virDomainManagedSave()),
then libvirt will attempt to bypass the file system cache while restoring
the file, or fail if it cannot do so for the given system; this can allow
less pressure on file system cache, but also risks slowing loads from NFS.

If the VIR_DOMAIN_START_FORCE_BOOT flag is set, then any managed save
file for this domain is discarded, and the domain boots from scratch.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
      <arg name='nfiles' type='unsigned int' info='number of file descriptors passed'/>
      <arg name='files' type='int *' info='list of file descriptors passed'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainCreateFlags'/>
    </function>
    <function name='virDomainCreateWithFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.

If the VIR_DOMAIN_START_PAUSED flag is set, or if the guest domain
has a managed save image that requested paused state (see
virDomainManagedSave()) the guest domain will be started, but its
CPUs will remain paused. The CPUs can later be manually started
using virDomainResume().  In all other cases, the guest domain will
be running.

If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration. Hypervisors may also block save-to-file,
or snapshots.

If the VIR_DOMAIN_START_BYPASS_CACHE flag is set, and there is a
managed save file for this domain (created by virDomainManagedSave()),
then libvirt will attempt to bypass the file system cache while restoring
the file, or fail if it cannot do so for the given system; this can allow
less pressure on file system cache, but also risks slowing loads from NFS.

If the VIR_DOMAIN_START_FORCE_BOOT flag is set, then any managed save
file for this domain is discarded, and the domain boots from scratch.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainCreateFlags'/>
    </function>
    <function name='virDomainCreateXML' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Launch a new guest domain, based on an XML description similar
to the one returned by virDomainGetXMLDesc()
This function may require privileged access to the hypervisor.
The domain is not persistent, so its definition will disappear when it
is destroyed, or if the host is restarted (see virDomainDefineXML() to
define persistent domains).

If the VIR_DOMAIN_START_PAUSED flag is set, the guest domain
will be started, but its CPUs will remain paused. The CPUs
can later be manually started using virDomainResume.

If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration. Hypervisors may also block save-to-file,
or snapshots.

virDomainFree should be used to free the resources after the
domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the domain'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainCreateFlags'/>
    </function>
    <function name='virDomainCreateXMLWithFiles' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Launch a new guest domain, based on an XML description similar
to the one returned by virDomainGetXMLDesc()
This function may require privileged access to the hypervisor.
The domain is not persistent, so its definition will disappear when it
is destroyed, or if the host is restarted (see virDomainDefineXML() to
define persistent domains).

@files provides an array of file descriptors which will be
made available to the 'init' process of the guest. The file
handles exposed to the guest will be renumbered to start
from 3 (ie immediately following stderr). This is only
supported for guests which use container based virtualization
technology.

If the VIR_DOMAIN_START_PAUSED flag is set, the guest domain
will be started, but its CPUs will remain paused. The CPUs
can later be manually started using virDomainResume.

If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration. Hypervisors may also block
save-to-file, or snapshots.

virDomainFree should be used to free the resources after the
domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the domain'/>
      <arg name='nfiles' type='unsigned int' info='number of file descriptors passed'/>
      <arg name='files' type='int *' info='list of file descriptors passed'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainCreateFlags'/>
    </function>
    <function name='virDomainDefineXML' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Define a domain, but does not start it.
This definition is persistent, until explicitly undefined with
virDomainUndefine(). A previous definition for this domain would be
overridden if it already exists.

virDomainFree should be used to free the resources after the
domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='NULL in case of error, a pointer to the domain otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the domain, preferably in UTF-8'/>
    </function>
    <function name='virDomainDefineXMLFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Defines a domain, but does not start it.
This definition is persistent, until explicitly undefined with
virDomainUndefine(). A previous definition for this domain would be
overridden if it already exists.

virDomainFree should be used to free the resources after the
domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='NULL in case of error, a pointer to the domain otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the domain, preferably in UTF-8'/>
      <arg name='flags' type='unsigned int' info='bitwise OR of the virDomainDefineFlags constants'/>
    </function>
    <function name='virDomainDelIOThread' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically delete an IOThread from the domain. The @iothread_id to be
deleted must not have a resource associated with it and can be any of
the currently valid IOThread ID's.

Note that this call can fail if the underlying virtualization hypervisor
does not support it or if reducing the number is arbitrarily limited.
This function requires privileged access to the hypervisor.

@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain
and may fail if domain is not alive.
If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='iothread_id' type='unsigned int' info='the specific IOThread ID value to delete'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainDestroy' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Destroy the domain object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor. This
does not free the associated virDomainPtr object.
This function may require privileged access.

virDomainDestroy first requests that a guest terminate
(e.g. SIGTERM), then waits for it to comply. After a reasonable
timeout, if the guest still exists, virDomainDestroy will
forcefully terminate the guest (e.g. SIGKILL) if necessary (which
may produce undesirable results, for example unflushed disk cache
in the guest). To avoid this possibility, it's recommended to
instead call virDomainDestroyFlags, sending the
VIR_DOMAIN_DESTROY_GRACEFUL flag.

If the domain is transient and has any snapshot metadata (see
virDomainSnapshotNum()), then that metadata will automatically
be deleted when the domain quits.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainDestroyFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Destroy the domain object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor.
This does not free the associated virDomainPtr object.
This function may require privileged access.

Calling this function with no @flags set (equal to zero) is
equivalent to calling virDomainDestroy, and after a reasonable
timeout will forcefully terminate the guest (e.g. SIGKILL) if
necessary (which may produce undesirable results, for example
unflushed disk cache in the guest). Including
VIR_DOMAIN_DESTROY_GRACEFUL in the flags will prevent the forceful
termination of the guest, and virDomainDestroyFlags will instead
return an error if the guest doesn't terminate by the end of the
timeout; at that time, the management application can decide if
calling again without VIR_DOMAIN_DESTROY_GRACEFUL is appropriate.

Another alternative which may produce cleaner results for the
guest's disks is to use virDomainShutdown() instead, but that
depends on guest support (some hypervisor/guest combinations may
ignore the shutdown request).]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainDestroyFlagsValues'/>
    </function>
    <function name='virDomainDetachDevice' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This is an equivalent of virDomainDetachDeviceFlags() when called with
@flags parameter set to VIR_DOMAIN_AFFECT_LIVE.

See virDomainDetachDeviceFlags() for more details.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
    </function>
    <function name='virDomainDetachDeviceAlias' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Detach a virtual device from a domain, using the alias to
specify the device. The value of @flags should be either
VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of values from
VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CURRENT, although
hypervisors vary in which flags are supported.

In contrast to virDomainDetachDeviceFlags() this API is
asynchronous - it returns immediately after sending the detach
request to the hypervisor. It's caller's responsibility to
wait for VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED event to signal
actual device removal or for
VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED to signal rejected
device removal.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a domain object'/>
      <arg name='alias' type='const char *' info='device alias'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainDeviceModifyFlags'/>
    </function>
    <function name='virDomainDetachDeviceFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Detach a virtual device from a domain, using the flags parameter
to control how the device is detached.  VIR_DOMAIN_AFFECT_CURRENT
specifies that the device allocation is removed based on current domain
state.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be
deallocated from the active domain instance only and is not from the
persisted domain configuration.  VIR_DOMAIN_AFFECT_CONFIG
specifies that the device shall be deallocated from the persisted domain
configuration only.  Note that the target hypervisor must return an
error if unable to satisfy flags.  E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports removing the
persisted device allocation.

Some hypervisors may prevent this operation if there is a current
block job running operation on the device being detached; in that case,
use virDomainBlockJobAbort() to stop the block job first.

Beware that depending on the hypervisor and device type, detaching a device
from a running domain may be asynchronous. That is, calling
virDomainDetachDeviceFlags may just request device removal while the device
is actually removed later (in cooperation with a guest OS). Previously,
this fact was ignored and the device could have been removed from domain
configuration before it was actually removed by the hypervisor causing
various failures on subsequent operations. To check whether the device was
successfully removed, either recheck domain configuration using
virDomainGetXMLDesc() or add a handler for the VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED
event. In case the device is already gone when virDomainDetachDeviceFlags
returns, the event is delivered before this API call ends. To help existing
clients work better in most cases, this API will try to transform an
asynchronous device removal that finishes shortly after the request into
a synchronous removal. In other words, this API may wait a bit for the
removal to complete in case it was not synchronous.

Be aware that hotplug changes might not persist across a domain going
into S4 state (also known as hibernation) unless you also modify the
persistent domain definition.

The supplied XML description of the device should be as specific
as its definition in the domain XML. The set of attributes used
to match the device are internal to the drivers. Using a partial definition,
or attempting to detach a device that is not present in the domain XML,
but shares some specific attributes with one that is present,
may lead to unexpected results.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainDeviceModifyFlags'/>
    </function>
    <function name='virDomainFSFreeze' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Freeze specified filesystems within the guest (hence guest agent
may be required depending on hypervisor used). If @mountpoints is NULL and
@nmountpoints is 0, every mounted filesystem on the guest is frozen.
In some environments (e.g. QEMU guest with guest agent which doesn't
support mountpoints argument), @mountpoints may need to be NULL.]]></info>
      <return type='int' info='the number of frozen filesystems on success, -1 otherwise.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='mountpoints' type='const char **' info='list of mount points to be frozen'/>
      <arg name='nmountpoints' type='unsigned int' info='the number of mount points specified in @mountpoints'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainFSInfoFree' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Frees all the memory occupied by @info.]]></info>
      <return type='void'/>
      <arg name='info' type='virDomainFSInfoPtr' info='pointer to a FSInfo object'/>
    </function>
    <function name='virDomainFSThaw' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Thaw specified filesystems within the guest. If @mountpoints is NULL and
@nmountpoints is 0, every mounted filesystem on the guest is thawed.
In some drivers (e.g. QEMU driver), @mountpoints may need to be NULL.]]></info>
      <return type='int' info='the number of thawed filesystems on success, -1 otherwise.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='mountpoints' type='const char **' info='list of mount points to be thawed'/>
      <arg name='nmountpoints' type='unsigned int' info='the number of mount points specified in @mountpoints'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainFSTrim' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Calls FITRIM within the guest (hence guest agent may be
required depending on hypervisor used). Either call it on each
mounted filesystem (@mountPoint is NULL) or just on specified
@mountPoint. @minimum hints that free ranges smaller than this
may be ignored (this is a hint and the guest may not respect
it).  By increasing this value, the fstrim operation will
complete more quickly for filesystems with badly fragmented
free space, although not all blocks will be discarded.
If @minimum is not zero, the command may fail.]]></info>
      <return type='int' info='0 on success, -1 otherwise.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='mountPoint' type='const char *' info='which mount point to trim'/>
      <arg name='minimum' type='unsigned long long' info='Minimum contiguous free range to discard in bytes'/>
      <arg name='flags' type='unsigned int' info='extra flags, not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainFree' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Free the domain object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetAutostart' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Provides a boolean value indicating whether the domain
configured to be automatically started when the host
machine boots.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='autostart' type='int *' info='the value returned'/>
    </function>
    <function name='virDomainGetBlkioParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get all blkio parameters.  On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.

See virDomainGetMemoryParameters() for an equivalent usage example.

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to blkio parameter object (return value, allocated by the caller)'/>
      <arg name='nparams' type='int *' info='pointer to number of blkio parameters; input and output'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact and virTypedParameterFlags'/>
    </function>
    <function name='virDomainGetBlockInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract information about a domain's block device.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the <target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

For QEMU domains, the allocation and physical virDomainBlockInfo
values returned will generally be the same, except when using a
non raw, block backing device, such as qcow2 for an active domain.
When the persistent domain is not active, QEMU will return the
default which is the same value for allocation and physical.

Active QEMU domains can return an allocation value which is more
representative of the currently used blocks by the device compared
to the physical size of the device. Applications can use/monitor
the allocation value with the understanding that if the domain
becomes inactive during an attempt to get the value, the default
values will be returned. Thus, the application should check
after the call for the domain being inactive if the values are
the same. Optionally, the application could be watching for a
shutdown event and then ignore any values received afterwards.
This can be an issue when a domain is being migrated and the
exact timing of the domain being made inactive and check of
the allocation value results the default being returned. For
a transient domain in the similar situation, this call will return
-1 and an error message indicating the "domain is not running".

The following is some pseudo code illustrating the call sequence:

  ...
  virDomainPtr dom;
  virDomainBlockInfo info;
  char *device;
  ...
  // Either get a list of all domains or a specific domain
  // via a virDomainLookupBy*() call.
  //
  // It's also required to fill in the device pointer, but that's
  // specific to the implementation. For the purposes of this example
  // a qcow2 backed device name string would need to be provided.
  ...
  // If the following call is made on a persistent domain with a
  // qcow2 block backed block device, then it's possible the returned
  // allocation equals the physical value. In that case, the domain
  // that may have been active prior to calling has become inactive,
  // such as is the case during a domain migration. Thus once we
  // get data returned, check for active domain when the values are
  // the same.
  if (virDomainGetBlockInfo(dom, device, &info, 0) < 0)
      goto failure;
  if (info.allocation == info.physical) {
      // If the domain is no longer active,
      // then the defaults are being returned.
      if (!virDomainIsActive())
              goto ignore_return;
  }
  // Do something with the allocation and physical values
  ...]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='info' type='virDomainBlockInfoPtr' info='pointer to a virDomainBlockInfo structure allocated by the user'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainGetBlockIoTune' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get all block IO tunable parameters for a given device.  On input,
@nparams gives the size of the @params array; on output, @nparams
gives how many slots were filled with parameter information, which
might be less but will not exceed the input value.

As a special case, calling with @params as NULL and @nparams as 0
on input will cause @nparams on output to contain the number of
parameters supported by the hypervisor, either for the given @disk
(note that block devices of different types might support different
parameters), or if @disk is NULL, for all possible disks. The
caller should then allocate @params array,
i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.  See virDomainGetMemoryParameters() for more details.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or the device target shorthand (the <target
dev='...'/> sub-element, such as "xvda").  Valid names can be found
by calling virDomainGetXMLDesc() and inspecting elements
within //domain/devices/disk.  This parameter cannot be NULL
unless @nparams is 0 on input.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='params' type='virTypedParameterPtr' info='Pointer to blkio parameter object (return value, allocated by the caller)'/>
      <arg name='nparams' type='int *' info='Pointer to number of blkio parameters'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact and virTypedParameterFlags'/>
    </function>
    <function name='virDomainGetBlockJobInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Request block job information for the given disk.  If an operation is active
@info will be updated with the current progress.  The units used for the
bandwidth field of @info depends on @flags.  If @flags includes
VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES, bandwidth is in bytes/second
(although this mode can risk failure due to overflow, depending on both
client and server word size); otherwise, the value is rounded up to MiB/s.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the <target dev='...'/> sub-element, such as "vda").  Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

As a corner case underlying hypervisor may report cur == 0 and
end == 0 when the block job hasn't been started yet. In this
case libvirt reports cur = 0 and end = 1. However, hypervisor
may return cur == 0 and end == 0 if the block job has finished
and was no-op. In this case libvirt reports cur = 1 and end = 1.
Since 2.3.0.

Note that the progress reported for blockjobs corresponding to a pull-mode
backup don't report progress of the backup but rather usage of temporary
space required for the backup.]]></info>
      <return type='int' info='-1 in case of failure, 0 when nothing found, 1 when info was found.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='info' type='virDomainBlockJobInfoPtr' info='pointer to a virDomainBlockJobInfo structure'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainBlockJobInfoFlags'/>
    </function>
    <function name='virDomainGetCPUStats' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get statistics relating to CPU usage attributable to a single
domain (in contrast to the statistics returned by
virNodeGetCPUStats() for all processes on the host).  @dom
must be running (an inactive domain has no attributable cpu
usage).  On input, @params must contain at least @nparams * @ncpus
entries, allocated by the caller.

If @start_cpu is -1, then @ncpus must be 1, and the returned
results reflect the statistics attributable to the entire
domain (such as user and system time for the process as a
whole).  Otherwise, @start_cpu represents which cpu to start
with, and @ncpus represents how many consecutive processors to
query, with statistics attributable per processor (such as
per-cpu usage).  If @ncpus is larger than the number of cpus
available to query, then the trailing part of the array will
be unpopulated.

The remote driver imposes a limit of 128 @ncpus and 16 @nparams;
the number of parameters per cpu should not exceed 16, but if you
have a host with more than 128 CPUs, your program should split
the request into multiple calls.

As special cases, if @params is NULL and @nparams is 0 and
@ncpus is 1, and the return value will be how many
statistics are available for the given @start_cpu.  This number
may be different for @start_cpu of -1 than for any non-negative
value, but will be the same for all non-negative @start_cpu.
Likewise, if @params is NULL and @nparams is 0 and @ncpus is 0,
the number of cpus available to query is returned.  From the
host perspective, this would typically match the cpus member
of virNodeGetInfo(), but might be less due to host cpu hotplug.

For now, @flags is unused, and the statistics all relate to the
usage from the host perspective.  It is possible that a future
version will support a flag that queries the cpu usage from the
guest's perspective, where the maximum cpu to query would be
related to virDomainGetVcpusFlags() rather than virNodeGetInfo().
An individual guest vcpu cannot be reliably mapped back to a
specific host cpu unless a single-processor vcpu pinning was used,
but when @start_cpu is -1, any difference in usage between a host
and guest perspective would serve as a measure of hypervisor overhead.

Typical use sequence is below.

getting total stats: set start_cpu as -1, ncpus 1

  virDomainGetCPUStats(dom, NULL, 0, -1, 1, 0); // nparams
  params = calloc(nparams, sizeof(virTypedParameter))
  virDomainGetCPUStats(dom, params, nparams, -1, 1, 0); // total stats.

getting per-cpu stats:

  virDomainGetCPUStats(dom, NULL, 0, 0, 0, 0); // ncpus
  virDomainGetCPUStats(dom, NULL, 0, 0, 1, 0); // nparams
  params = calloc(ncpus * nparams, sizeof(virTypedParameter));
  virDomainGetCPUStats(dom, params, nparams, 0, ncpus, 0); // per-cpu stats]]></info>
      <return type='int' info='-1 on failure, or the number of statistics that were populated per cpu on success (this will be less than the total number of populated @params, unless @ncpus was 1; and may be less than @nparams).  The populated parameters start at each stride of @nparams, which means the results may be discontiguous; any unpopulated parameters will be zeroed on success (this includes skipped elements if @nparams is too large, and tail elements if @ncpus is too large).  The caller is responsible for freeing any returned string parameters.'/>
      <arg name='domain' type='virDomainPtr' info='domain to query'/>
      <arg name='params' type='virTypedParameterPtr' info='array to populate on output'/>
      <arg name='nparams' type='unsigned int' info='number of parameters per cpu'/>
      <arg name='start_cpu' type='int' info='which cpu to start with, or -1 for summary'/>
      <arg name='ncpus' type='unsigned int' info='how many cpus to query'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virTypedParameterFlags'/>
    </function>
    <function name='virDomainGetConnect' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Provides the connection pointer associated with a domain.  The
reference counter on the connection is not increased by this
call.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to a domain'/>
    </function>
    <function name='virDomainGetControlInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract details about current state of control interface to a domain.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainControlInfoPtr' info='pointer to a virDomainControlInfo structure allocated by the user'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainGetDiskErrors' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The function populates @errors array with all disks that encountered an
I/O error.  Disks with no error will not be returned in the @errors array.
Each disk is identified by its target (the dev attribute of target
subelement in domain XML), such as "vda", and accompanied with the error
that was seen on it.  The caller is also responsible for calling free()
on each disk name returned.

In a special case when @errors is NULL and @maxerrors is 0, the function
returns preferred size of @errors that the caller should use to get all
disk errors.

Since calling virDomainGetDiskErrors(dom, NULL, 0, 0) to get preferred size
of @errors array and getting the errors are two separate operations, new
disks may be hotplugged to the domain and new errors may be encountered
between the two calls.  Thus, this function may not return all disk errors
because the supplied array is not large enough.  Such errors may, however,
be detected by listening to domain events.]]></info>
      <return type='int' info='number of disks with errors filled in the @errors array or -1 on error.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='errors' type='virDomainDiskErrorPtr' info='array to populate on output'/>
      <arg name='maxerrors' type='unsigned int' info='size of @errors array'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainGetEmulatorPinInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Query the CPU affinity setting of all emulator threads of domain, store
it in cpumap.]]></info>
      <return type='int' info='1 in case of success, 0 in case of no emulator threads are pined to pcpus, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='cpumap' type='unsigned char *' info='pointer to a bit map of real CPUs for all emulator threads of this domain (in 8-bit bytes) (OUT) There is only one cpumap for all emulator threads. Must not be NULL.'/>
      <arg name='maplen' type='int' info='the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive.'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact Must not be VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG concurrently.'/>
    </function>
    <function name='virDomainGetFSInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get a list of mapping information for each mounted file systems within the
specified guest and the disks.]]></info>
      <return type='int' info='the number of returned mount points, or -1 in case of error. On success, the array of the information is stored into @info. The caller is responsible for calling virDomainFSInfoFree() on each array element, then calling free() on @info. On error, @info is set to NULL.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainFSInfoPtr **' info='a pointer to a variable to store an array of mount points information'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainGetGuestInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Queries the guest agent for the various information about the guest system.
The reported data depends on the guest agent implementation. The information
is returned as an array of typed parameters containing the individual
parameters. The parameter name for each information field consists of a
dot-separated string containing the name of the requested group followed by
a group-specific description of the statistic value.

The information groups are enabled using the @types parameter which is a
binary-OR of enum virDomainGuestInfoTypes. The following groups are available
(although not necessarily implemented for each hypervisor):

VIR_DOMAIN_GUEST_INFO_USERS:
 returns information about users that are currently logged in within the
 guest domain. The typed parameter keys are in this format:

     "user.count" - the number of active users on this domain as an
                    unsigned int
     "user.<num>.name" - username of the user as a string
     "user.<num>.domain" - domain of the user as a string (may only be
                           present on certain guest types)
     "user.<num>.login-time" - the login time of a user in milliseconds
                               since the epoch as unsigned long long

VIR_DOMAIN_GUEST_INFO_OS:
 Return information about the operating system running within the guest. The
 typed parameter keys are in this format:

     "os.id" - a string identifying the operating system
     "os.name" - the name of the operating system, suitable for presentation
                 to a user, as a string
     "os.pretty-name" - a pretty name for the operating system, suitable for
                        presentation to a user, as a string
     "os.version" - the version of the operating system suitable for
                    presentation to a user, as a string
     "os.version-id" - the version id of the operating system suitable for
                       processing by scripts, as a string
     "os.kernel-release" - the release of the operating system kernel, as a
                           string
     "os.kernel-version" - the version of the operating system kernel, as a
                           string
     "os.machine" - the machine hardware name as a string
     "os.variant" - a specific variant or edition of the operating system
                    suitable for presentation to a user, as a string
     "os.variant-id" - the id for a specific variant or edition of the
                       operating system, as a string

VIR_DOMAIN_GUEST_INFO_TIMEZONE:
 Returns information about the timezone within the domain. The typed
 parameter keys are in this format:

     "timezone.name" - the name of the timezone as a string
     "timezone.offset" - the offset to UTC in seconds as an int

VIR_DOMAIN_GUEST_INFO_FILESYSTEM:
 Returns information about the filesystems within the domain.  The typed
 parameter keys are in this format:

     "fs.count" - the number of filesystems defined on this domain
                  as an unsigned int
     "fs.<num>.mountpoint" - the path to the mount point for the filesystem
     "fs.<num>.name" - device name in the guest (e.g. "sda1")
     "fs.<num>.fstype" - the type of filesystem
     "fs.<num>.total-bytes" - the total size of the filesystem
     "fs.<num>.used-bytes" - the number of bytes used in the filesystem
     "fs.<num>.disk.count" - the number of disks targeted by this filesystem
     "fs.<num>.disk.<num>.alias" - the device alias of the disk (e.g. sda)
     "fs.<num>.disk.<num>.serial" - the serial number of the disk
     "fs.<num>.disk.<num>.device" - the device node of the disk

VIR_DOMAIN_GUEST_INFO_HOSTNAME:
 Returns information about the hostname of the domain. The typed
 parameter keys are in this format:

     "hostname" - the hostname of the domain

Using 0 for @types returns all information groups supported by the given
hypervisor.

This API requires the VM to run. The caller is responsible for calling
virTypedParamsFree to free memory returned in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='types' type='unsigned int' info='types of information to return, binary-OR of virDomainGuestInfoTypes'/>
      <arg name='params' type='virTypedParameterPtr *' info='location to store the guest info parameters'/>
      <arg name='nparams' type='int *' info='number of items in @params'/>
      <arg name='flags' type='unsigned int' info='currently unused, set to 0'/>
    </function>
    <function name='virDomainGetGuestVcpus' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Queries the guest agent for state and information regarding vCPUs from
guest's perspective. The reported data depends on the guest agent
implementation.

Reported fields stored in @params:
'vcpus': string containing bitmap representing vCPU ids as reported by the
         guest
'online': string containing bitmap representing online vCPUs as reported
          by the guest agent.
'offlinable': string containing bitmap representing ids of vCPUs that can be
              offlined

This API requires the VM to run. The caller is responsible for calling
virTypedParamsFree to free memory returned in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer that will be filled with an array of typed parameters'/>
      <arg name='nparams' type='unsigned int *' info='pointer filled with number of elements in @params'/>
      <arg name='flags' type='unsigned int' info='currently unused, callers shall pass 0'/>
    </function>
    <function name='virDomainGetHostname' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get the hostname for that domain. If no hostname is found,
then an error is raised with VIR_ERR_NO_HOSTNAME code.

Dependent on hypervisor and @flags used, this may require a
guest agent to be available.]]></info>
      <return type='char *' info='the hostname which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainGetHostnameFlags'/>
    </function>
    <function name='virDomainGetID' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get the hypervisor ID number for the domain]]></info>
      <return type='unsigned int' info='the domain ID number or (unsigned int) -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetIOThreadInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Fetch IOThreads of an active domain including the cpumap information to
determine on which CPU the IOThread has affinity to run.]]></info>
      <return type='int' info='the number of IOThreads or -1 in case of error. On success, the array of information is stored into @info. The caller is responsible for calling virDomainIOThreadInfoFree() on each array element, then calling free() on @info. On error, @info is set to NULL.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainIOThreadInfoPtr **' info='pointer to an array of virDomainIOThreadInfo structures (OUT)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact Must not be VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG concurrently.'/>
    </function>
    <function name='virDomainGetInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract information about a domain. Note that if the connection
used to get the domain is limited only a partial set of the information
can be extracted.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainInfoPtr' info='pointer to a virDomainInfo structure allocated by the user'/>
    </function>
    <function name='virDomainGetInterfaceParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get all interface parameters. On input, @nparams gives the size of
the @params array; on output, @nparams gives how many slots were
filled with parameter information, which might be less but will not
exceed the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the
API again. See virDomainGetMemoryParameters() for an equivalent usage
example.

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='device' type='const char *' info='the interface name or mac address'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to interface parameter objects (return value, allocated by the caller)'/>
      <arg name='nparams' type='int *' info='pointer to number of interface parameter; input and output'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact and virTypedParameterFlags'/>
    </function>
    <function name='virDomainGetJobInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract information about progress of a background job on a domain.
Will return an error if the domain is not active.

This function returns a limited amount of information in comparison
to virDomainGetJobStats().]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainJobInfoPtr' info='pointer to a virDomainJobInfo structure allocated by the user'/>
    </function>
    <function name='virDomainGetJobStats' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract information about progress of a background job on a domain.
Will return an error if the domain is not active. The function returns
a superset of progress information provided by virDomainGetJobInfo.
Possible fields returned in @params are defined by VIR_DOMAIN_JOB_*
macros and new fields will likely be introduced in the future so callers
may receive fields that they do not understand in case they talk to a
newer server.

When @flags contains VIR_DOMAIN_JOB_STATS_COMPLETED, the function will
return statistics about a recently completed job. Specifically, this
flag may be used to query statistics of a completed incoming pre-copy
migration (statistics for post-copy migration are only available on the
source host). Statistics of a completed job are automatically destroyed
once read (unless the VIR_DOMAIN_JOB_STATS_COMPLETED_KEEP is used as well)
or when libvirtd is restarted. Note that time information
returned for completed migrations may be completely irrelevant unless both
source and destination hosts have synchronized time (i.e., NTP daemon is
running on both of them). The statistics of a completed job can also be
obtained by listening to a VIR_DOMAIN_EVENT_ID_JOB_COMPLETED event (on the
source host in case of a migration job).]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='type' type='int *' info='where to store the job type (one of virDomainJobType)'/>
      <arg name='params' type='virTypedParameterPtr *' info='where to store job statistics'/>
      <arg name='nparams' type='int *' info='number of items in @params'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainGetJobStatsFlags'/>
    </function>
    <function name='virDomainGetLaunchSecurityInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get the launch security info. In case of the SEV guest, this will
return the launch measurement.]]></info>
      <return type='int' info='-1 in case of failure, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='params' type='virTypedParameterPtr *' info='where to store security info'/>
      <arg name='nparams' type='int *' info='number of items in @params'/>
      <arg name='flags' type='unsigned int' info='currently used, set to 0.'/>
    </function>
    <function name='virDomainGetMaxMemory' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Retrieve the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this get the amount of memory reserved
to Domain0 i.e. the domain where the application runs.]]></info>
      <return type='unsigned long' info='the memory size in kibibytes (blocks of 1024 bytes), or 0 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
    </function>
    <function name='virDomainGetMaxVcpus' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Provides the maximum number of virtual CPUs supported for
the guest VM. If the guest is inactive, this is basically
the same as virConnectGetMaxVcpus(). If the guest is running
this will reflect the maximum number of virtual CPUs the
guest was booted with.  For more details, see virDomainGetVcpusFlags().]]></info>
      <return type='int' info='the maximum of virtual CPU or -1 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
    </function>
    <function name='virDomainGetMemoryParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get all memory parameters.  On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.

Here is a sample code snippet:

  if (virDomainGetMemoryParameters(dom, NULL, &nparams, 0) == 0 &&
      nparams != 0) {
      if ((params = malloc(sizeof(*params) * nparams)) == NULL)
          goto error;
      memset(params, 0, sizeof(*params) * nparams);
      if (virDomainGetMemoryParameters(dom, params, &nparams, 0))
          goto error;
  }

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to memory parameter object (return value, allocated by the caller)'/>
      <arg name='nparams' type='int *' info='pointer to number of memory parameters; input and output'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact and virTypedParameterFlags'/>
    </function>
    <function name='virDomainGetMetadata' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Retrieves the appropriate domain element given by @type.
If VIR_DOMAIN_METADATA_ELEMENT is requested parameter @uri
must be set to the name of the namespace the requested elements
belong to, otherwise must be NULL.

If an element of the domain XML is not present, the resulting
error will be VIR_ERR_NO_DOMAIN_METADATA.  This method forms
a shortcut for seeing information from virDomainSetMetadata()
without having to go through virDomainGetXMLDesc().

@flags controls whether the live domain or persistent
configuration will be queried.]]></info>
      <return type='char *' info='the metadata string on success (caller must free), or NULL in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='type' type='int' info='type of metadata, from virDomainMetadataType'/>
      <arg name='uri' type='const char *' info='XML namespace identifier'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainGetName' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get the public name for that domain]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetNumaParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get all numa parameters.  On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.

See virDomainGetMemoryParameters() for an equivalent usage example.

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to numa parameter object (return value, allocated by the caller)'/>
      <arg name='nparams' type='int *' info='pointer to number of numa parameters'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact and virTypedParameterFlags'/>
    </function>
    <function name='virDomainGetOSType' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get the type of domain operation system.]]></info>
      <return type='char *' info='the new string or NULL in case of error, the string must be freed by the caller.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetPerfEvents' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get all Linux perf events setting. Possible fields returned in
@params are defined by VIR_PERF_EVENT_* macros and new fields
will likely be introduced in the future.

Linux perf events are performance analyzing tool in Linux.]]></info>
      <return type='int' info='-1 in case of failure, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='params' type='virTypedParameterPtr *' info='where to store perf events setting'/>
      <arg name='nparams' type='int *' info='number of items in @params'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact and virTypedParameterFlags'/>
    </function>
    <function name='virDomainGetSchedulerParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get all scheduler parameters.  On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.  @nparams cannot be 0.

It is hypervisor specific whether this returns the live or
persistent state; for more control, use
virDomainGetSchedulerParametersFlags().]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to scheduler parameter objects (return value)'/>
      <arg name='nparams' type='int *' info='pointer to number of scheduler parameter objects (this value should generally be as large as the returned value nparams of virDomainGetSchedulerType()); input and output'/>
    </function>
    <function name='virDomainGetSchedulerParametersFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get all scheduler parameters.  On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.  @nparams cannot be 0.

The value of @flags can be exactly VIR_DOMAIN_AFFECT_CURRENT,
VIR_DOMAIN_AFFECT_LIVE, or VIR_DOMAIN_AFFECT_CONFIG.

Here is a sample code snippet:

  char *ret = virDomainGetSchedulerType(dom, &nparams);
  if (ret && nparams != 0) {
      if ((params = malloc(sizeof(*params) * nparams)) == NULL)
          goto error;
      memset(params, 0, sizeof(*params) * nparams);
      if (virDomainGetSchedulerParametersFlags(dom, params, &nparams, 0))
          goto error;
  }]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to scheduler parameter object (return value)'/>
      <arg name='nparams' type='int *' info='pointer to number of scheduler parameter (this value should be same than the returned value nparams of virDomainGetSchedulerType()); input and output'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact and virTypedParameterFlags'/>
    </function>
    <function name='virDomainGetSchedulerType' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get the scheduler type and the number of scheduler parameters.]]></info>
      <return type='char *' info='NULL in case of error. The caller must free the returned string.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='nparams' type='int *' info='pointer to number of scheduler parameters, can be NULL (return value)'/>
    </function>
    <function name='virDomainGetSecurityLabel' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract security label of an active domain. The 'label' field
in the @seclabel argument will be initialized to the empty
string if the domain is not running under a security model.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='seclabel' type='virSecurityLabelPtr' info='pointer to a virSecurityLabel structure'/>
    </function>
    <function name='virDomainGetSecurityLabelList' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract the security labels of an active domain. The 'label' field
in the @seclabels argument will be initialized to the empty
string if the domain is not running under a security model.]]></info>
      <return type='int' info='number of elements in @seclabels on success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='seclabels' type='virSecurityLabelPtr *' info='will be auto-allocated and filled with domains&apos; security labels. Caller must free memory on return.'/>
    </function>
    <function name='virDomainGetState' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract domain state. Each state can be accompanied with a reason (if known)
which led to the state.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='state' type='int *' info='returned state of the domain (one of virDomainState)'/>
      <arg name='reason' type='int *' info='returned reason which led to @state (one of virDomain*Reason corresponding to the current state); it is allowed to be NULL'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainGetTime' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract information about guest time and store it into
@seconds and @nseconds. The @seconds represents the number of
seconds since the UNIX Epoch of 1970-01-01 00:00:00 in UTC.

Please note that some hypervisors may require guest agent to
be configured and running in order to run this API.]]></info>
      <return type='int' info='0 on success, -1 otherwise.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='seconds' type='long long *' info='domain&apos;s time in seconds'/>
      <arg name='nseconds' type='unsigned int *' info='the nanosecond part of @seconds'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainGetUUID' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get the UUID for a domain]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virDomainGetUUIDString' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get the UUID for a domain as string. For more information about
UUID see RFC4122.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virDomainGetVcpuPinInfo' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Query the CPU affinity setting of all virtual CPUs of domain, store it
in cpumaps.]]></info>
      <return type='int' info='the number of virtual CPUs in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='ncpumaps' type='int' info='the number of cpumap (listed first to match virDomainGetVcpus)'/>
      <arg name='cpumaps' type='unsigned char *' info='pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) It&apos;s assumed there is &lt;ncpumaps&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (ncpumaps * maplen) bytes (ie: calloc(ncpumaps, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API. Must not be NULL.'/>
      <arg name='maplen' type='int' info='the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive.'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact Must not be VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG concurrently.'/>
    </function>
    <function name='virDomainGetVcpus' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Extract information about virtual CPUs of domain, store it in info array
and also in cpumaps if this pointer isn't NULL.  This call may fail
on an inactive domain.

See also virDomainGetVcpuPinInfo for querying just cpumaps, including on
an inactive domain.]]></info>
      <return type='int' info='the number of info filled in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='info' type='virVcpuInfoPtr' info='pointer to an array of virVcpuInfo structures (OUT)'/>
      <arg name='maxinfo' type='int' info='number of structures in info array'/>
      <arg name='cpumaps' type='unsigned char *' info='pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cpumap information is returned by the API. It&apos;s assumed there is &lt;maxinfo&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API.'/>
      <arg name='maplen' type='int' info='number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). Must be zero when cpumaps is NULL and positive when it is non-NULL.'/>
    </function>
    <function name='virDomainGetVcpusFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Query the number of virtual CPUs used by the domain.  Note that
this call may fail if the underlying virtualization hypervisor does
not support it.  This function may require privileged access to the
hypervisor.

If @flags includes VIR_DOMAIN_AFFECT_LIVE, this will query a
running domain (which will fail if domain is not active); if
it includes VIR_DOMAIN_AFFECT_CONFIG, this will query the XML
description of the domain.  It is an error to set both flags.
If neither flag is set (that is, VIR_DOMAIN_AFFECT_CURRENT),
then the configuration queried depends on whether the domain
is currently running.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then the maximum
virtual CPU limit is queried.  Otherwise, this call queries the
current virtual CPU count.

If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of the processors
is queried in the guest instead of the hypervisor. This flag is only usable
on live domains. Guest agent may be needed for this flag to be available.]]></info>
      <return type='int' info='the number of vCPUs in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainVcpuFlags'/>
    </function>
    <function name='virDomainGetXMLDesc' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Provide an XML description of the domain. The description may be reused
later to relaunch the domain with virDomainCreateXML().

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_XML_SECURE; this flag is rejected on read-only
connections.  If @flags includes VIR_DOMAIN_XML_INACTIVE, then the
XML represents the configuration that will be used on the next boot
of a persistent domain; otherwise, the configuration represents the
currently running domain.  If @flags contains
VIR_DOMAIN_XML_UPDATE_CPU, then the portion of the domain XML
describing CPU capabilities is modified to match actual
capabilities of the host.

If @flags contains VIR_DOMAIN_XML_MIGRATABLE, the XML is altered to
assist in migrations, since the source and destination may be
running different libvirt versions.  This may include trimming
redundant or default information that might confuse an older
recipient, or exposing internal details that aid a newer recipient;
this flag is rejected on read-only connections, and the resulting
XML might not validate against the schema, so it is mainly for
internal use.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainXMLFlags'/>
    </function>
    <function name='virDomainHasCurrentSnapshot' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Determine if the domain has a current snapshot.]]></info>
      <return type='int' info='1 if such snapshot exists, 0 if it doesn&apos;t, -1 on error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainHasManagedSaveImage' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Check if a domain has a managed save image as created by
virDomainManagedSave(). Note that any running domain should not have
such an image, as it should have been removed on restart.]]></info>
      <return type='int' info='0 if no image is present, 1 if an image is present, and -1 in case of error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainIOThreadInfoFree' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Frees the memory used by @info.]]></info>
      <return type='void'/>
      <arg name='info' type='virDomainIOThreadInfoPtr' info='pointer to a virDomainIOThreadInfo object'/>
    </function>
    <function name='virDomainInjectNMI' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Send NMI to the guest]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainInterfaceAddresses' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Return a pointer to the allocated array of pointers to interfaces
present in given domain along with their IP and MAC addresses. Note that
single interface can have multiple or even 0 IP addresses.

This API dynamically allocates the virDomainInterfacePtr struct based on
how many interfaces domain @dom has, usually there's 1:1 correlation. The
count of the interfaces is returned as the return value.

If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE, the DHCP lease
file associated with any virtual networks will be examined to obtain
the interface addresses. This only returns data for interfaces which
are connected to virtual networks managed by libvirt.

If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT, a configured
guest agent is needed for successful return from this API. Moreover, if
guest agent is used then the interface name is the one seen by guest OS.
To match such interface with the one from @dom XML use MAC address or IP
range.

If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP, the host
ARP table will be check to obtain the interface addresses. As
the arp cache refreshes in time, the returned ip address may
be unreachable. Depending on the route table config of the
guest, the returned mac address may be duplicated.

Note that for some @source values some pieces of returned @ifaces
might be unset (e.g. VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP does not
set IP address prefix as ARP table does not have any notion of that).

@ifaces->name and @ifaces->hwaddr are never NULL.

The caller *must* free @ifaces when no longer needed. Usual use case
looks like this:

  virDomainInterfacePtr *ifaces = NULL;
  int ifaces_count = 0;
  size_t i, j;
  virDomainPtr dom = ... obtain a domain here ...;

  if ((ifaces_count = virDomainInterfaceAddresses(dom, &ifaces,
           VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE)) < 0)
      goto cleanup;

 ... do something with returned values, for example:

  for (i = 0; i < ifaces_count; i++) {
      printf("name: %s", ifaces[i]->name);
      if (ifaces[i]->hwaddr)
          printf(" hwaddr: %s", ifaces[i]->hwaddr);

      for (j = 0; j < ifaces[i]->naddrs; j++) {
          virDomainIPAddressPtr ip_addr = ifaces[i]->addrs + j;
          printf("[addr: %s prefix: %d type: %d]",
                 ip_addr->addr, ip_addr->prefix, ip_addr->type);
      }
      printf("\n");
  }

  cleanup:
      if (ifaces && ifaces_count > 0)
          for (i = 0; i < ifaces_count; i++)
              virDomainInterfaceFree(ifaces[i]);
      free(ifaces);]]></info>
      <return type='int' info='the number of interfaces on success, -1 in case of error.'/>
      <arg name='dom' type='virDomainPtr' info='domain object'/>
      <arg name='ifaces' type='virDomainInterfacePtr **' info='pointer to an array of pointers pointing to interface objects'/>
      <arg name='source' type='unsigned int' info='one of the virDomainInterfaceAddressesSource constants'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass zero'/>
    </function>
    <function name='virDomainInterfaceFree' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Free the interface object. The data structure is
freed and should not be used thereafter. If @iface
is NULL, then this method has no effect.]]></info>
      <return type='void'/>
      <arg name='iface' type='virDomainInterfacePtr' info='an interface object'/>
    </function>
    <function name='virDomainInterfaceStats' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This function returns network interface stats for interfaces
attached to the domain.

The @device parameter is the network interface either by name or MAC
address.

Domains may have more than one network interface.  To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.

The returned stats are from domain's point of view.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='device' type='const char *' info='the interface name or MAC address'/>
      <arg name='stats' type='virDomainInterfaceStatsPtr' info='network interface stats (returned)'/>
      <arg name='size' type='size_t' info='size of stats structure'/>
    </function>
    <function name='virDomainIsActive' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Determine if the domain is currently running]]></info>
      <return type='int' info='1 if running, 0 if inactive, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
    </function>
    <function name='virDomainIsPersistent' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Determine if the domain has a persistent configuration
which means it will still exist after shutting down]]></info>
      <return type='int' info='1 if persistent, 0 if transient, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
    </function>
    <function name='virDomainIsUpdated' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Determine if the domain has been updated.]]></info>
      <return type='int' info='1 if updated, 0 if not, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
    </function>
    <function name='virDomainListAllCheckpoints' file='libvirt-domain-checkpoint' module='libvirt-domain-checkpoint'>
      <info><![CDATA[Collect the list of domain checkpoints for the given domain and allocate
an array to store those objects.

If @flags contains VIR_DOMAIN_CHECKPOINT_LIST_TOPOLOGICAL,
@checkpoints is non-NULL, and no other connection is modifying
checkpoints, then it is guaranteed that for any checkpoint in the
resulting list, no checkpoints later in the list can be reached by
a sequence of virDomainCheckpointGetParent() starting from that
earlier checkpoint; otherwise, the order of checkpoints in the
resulting list is unspecified.

By default, this command covers all checkpoints. It is also
possible to limit things to just checkpoints with no parents, when
@flags includes VIR_DOMAIN_CHECKPOINT_LIST_ROOTS.  Additional
filters are provided in groups listed below. Within a group, bits
are mutually exclusive, where all possible checkpoints are
described by exactly one bit from the group. Some hypervisors might
reject particular flags where it cannot make a distinction for
filtering. If the set of filter flags selected forms an impossible
combination, the hypervisor may return either 0 or an error.

The first group of @flags is VIR_DOMAIN_CHECKPOINT_LIST_LEAVES and
VIR_DOMAIN_CHECKPOINT_LIST_NO_LEAVES, to filter based on checkpoints that
have no further children (a leaf checkpoint).]]></info>
      <return type='int' info='the number of domain checkpoints found or -1 and sets @checkpoints to NULL in case of error.  On success, the array stored into @checkpoints is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virDomainCheckpointFree() on each array element, then calling free() on @checkpoints.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='checkpoints' type='virDomainCheckpointPtr **' info='pointer to variable to store the array containing checkpoint object, or NULL if the list is not required (just returns number of checkpoints)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainCheckpoinListFlags'/>
    </function>
    <function name='virDomainListAllSnapshots' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Collect the list of domain snapshots for the given domain and allocate
an array to store those objects.  This API solves the race inherent in
virDomainSnapshotListNames().

If @flags contains VIR_DOMAIN_SNAPSHOT_LIST_TOPOLOGICAL and @snaps
is non-NULL, and no other connection is modifying snapshots, then
it is guaranteed that for any snapshot in the resulting list, no
snapshots later in the list can be reached by a sequence of
virDomainSnapshotGetParent() starting from that earlier snapshot;
otherwise, the order of snapshots in the resulting list is
unspecified.

By default, this command covers all snapshots. It is also possible
to limit things to just snapshots with no parents, when @flags
includes VIR_DOMAIN_SNAPSHOT_LIST_ROOTS.  Additional filters are
provided in groups listed below. Within a group, bits are mutually
exclusive, where all possible snapshots are described by exactly
one bit from the group. Some hypervisors might reject particular
flags where it cannot make a distinction for filtering. If the set
of filter flags selected forms an impossible combination, the
hypervisor may return either 0 or an error.

The first group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_LEAVES and
VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that
have no further children (a leaf snapshot).

The next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_METADATA and
VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on
whether they have metadata that would prevent the removal of the last
reference to a domain.

The next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,
VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,
for filtering snapshots based on what domain state is tracked by the
snapshot.

The next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL and
VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on
whether the snapshot is stored inside the disk images or as
additional files.]]></info>
      <return type='int' info='the number of domain snapshots found or -1 and sets @snaps to NULL in case of error.  On success, the array stored into @snaps is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virDomainSnapshotFree() on each array element, then calling free() on @snaps.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='snaps' type='virDomainSnapshotPtr **' info='pointer to variable to store the array containing snapshot objects or NULL if the list is not required (just returns number of snapshots)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSnapshotListFlags'/>
    </function>
    <function name='virDomainListGetStats' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Query statistics for domains provided by @doms. Note that all domains in
@doms must share the same connection.

Report statistics of various parameters for a running VM according to @stats
field. The statistics are returned as an array of structures for each queried
domain. The structure contains an array of typed parameters containing the
individual statistics. The typed parameter name for each statistic field
consists of a dot-separated string containing name of the requested group
followed by a group specific description of the statistic value.

The statistic groups are enabled using the @stats parameter which is a
binary-OR of enum virDomainStatsTypes. The stats groups are documented
in virConnectGetAllDomainStats.

Using 0 for @stats returns all stats groups supported by the given
hypervisor.

Specifying VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS as @flags makes
the function return error in case some of the stat types in @stats were
not recognized by the daemon.  However, even with this flag, a hypervisor
may omit individual fields within a known group if the information is not
available; as an extreme example, a supported group may produce zero
fields for offline domains if the statistics are meaningful only for a
running domain.

Passing VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT in
@flags means when libvirt is unable to fetch stats for any of
the domains (for whatever reason) only a subset of statistics
is returned for the domain.  That subset being statistics that
don't involve querying the underlying hypervisor.

Note that any of the domain list filtering flags in @flags may be rejected
by this function.]]></info>
      <return type='int' info='the count of returned statistics structures on success, -1 on error. The requested data are returned in the @retStats parameter. The returned array should be freed by the caller. See virDomainStatsRecordListFree. Note that the count of returned stats may be less than the domain count provided via @doms.'/>
      <arg name='doms' type='virDomainPtr *' info='NULL terminated array of domains'/>
      <arg name='stats' type='unsigned int' info='stats to return, binary-OR of virDomainStatsTypes'/>
      <arg name='retStats' type='virDomainStatsRecordPtr **' info='Pointer that will be filled with the array of returned stats'/>
      <arg name='flags' type='unsigned int' info='extra flags; binary-OR of virConnectGetAllDomainStatsFlags'/>
    </function>
    <function name='virDomainLookupByID' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Try to find a domain based on the hypervisor ID number
Note that this won't work for inactive domains which have an ID of -1,
in that case a lookup based on the Name or UUId need to be done instead.

virDomainFree should be used to free the resources after the
domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='id' type='int' info='the domain ID number'/>
    </function>
    <function name='virDomainLookupByName' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Try to lookup a domain on the given hypervisor based on its name.

virDomainFree should be used to free the resources after the
domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the domain'/>
    </function>
    <function name='virDomainLookupByUUID' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Try to lookup a domain on the given hypervisor based on its UUID.

virDomainFree should be used to free the resources after the
domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the domain'/>
    </function>
    <function name='virDomainLookupByUUIDString' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Try to lookup a domain on the given hypervisor based on its UUID.

virDomainFree should be used to free the resources after the
domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the domain'/>
    </function>
    <function name='virDomainManagedSave' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore.
The difference from virDomainSave() is that libvirt is keeping track of
the saved state itself, and will reuse it once the domain is being
restarted (automatically or via an explicit libvirt call).
As a result any running domain is sure to not have a managed saved image.
This also implies that managed save only works on persistent domains,
since the domain must still exist in order to use virDomainCreate() to
restart it.

If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will
attempt to bypass the file system cache while creating the file, or
fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.

Normally, the managed saved state will remember whether the domain
was running or paused, and start will resume to the same state.
Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in
@flags will override the default saved into the file.  These two
flags are mutually exclusive.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainSaveRestoreFlags'/>
    </function>
    <function name='virDomainManagedSaveDefineXML' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This updates the definition of a domain stored in a saved state
file.

@dxml can be used to alter host-specific portions of the domain XML
that will be used on the next start of the domain. For example, it is
possible to alter the backing filename that is associated with a
disk device.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in
@flags will override the default saved into the file; omitting both
leaves the file's default unchanged.  These two flags are mutually
exclusive.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='dxml' type='const char *' info='XML config for adjusting guest xml used on restore'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainSaveRestoreFlags'/>
    </function>
    <function name='virDomainManagedSaveGetXMLDesc' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This method will extract the XML description of the managed save
state file of a domain.

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_SAVE_IMAGE_XML_SECURE; this flag is rejected on read-only
connections.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error.  The caller must free() the returned value.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSaveImageXMLFlags'/>
    </function>
    <function name='virDomainManagedSaveRemove' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Remove any managed save image for this domain.]]></info>
      <return type='int' info='0 in case of success, and -1 in case of error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainMemoryPeek' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This function allows you to read the contents of a domain's
memory.

The memory which is read is controlled by the 'start', 'size'
and 'flags' parameters.

If 'flags' is VIR_MEMORY_VIRTUAL then the 'start' and 'size'
parameters are interpreted as virtual memory addresses for
whichever task happens to be running on the domain at the
moment.  Although this sounds haphazard it is in fact what
you want in order to read Linux kernel state, because it
ensures that pointers in the kernel image can be interpreted
coherently.

'buffer' is the return buffer and must be at least 'size' bytes.
'size' may be 0 to test if the call would succeed.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to <= 65536 bytes.
However, with 0.9.13 this RPC limit has been raised to 1M byte.
Starting with version 1.0.6 the RPC limit has been raised again.
Now large requests up to 16M byte are supported.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='start' type='unsigned long long' info='start of memory to peek'/>
      <arg name='size' type='size_t' info='size of memory to peek'/>
      <arg name='buffer' type='void *' info='return buffer (must be at least size bytes)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainMemoryFlags'/>
    </function>
    <function name='virDomainMemoryStats' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This function provides memory statistics for the domain.

Up to 'nr_stats' elements of 'stats' will be populated with memory statistics
from the domain.  Only statistics supported by the domain, the driver, and
this version of libvirt will be returned.

Memory Statistics:

VIR_DOMAIN_MEMORY_STAT_SWAP_IN:
    The total amount of data read from swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_SWAP_OUT:
    The total amount of memory written out to swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT:
    The number of page faults that required disk IO to service.
VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT:
    The number of page faults serviced without disk IO.
VIR_DOMAIN_MEMORY_STAT_UNUSED:
    The amount of memory which is not being used for any purpose (in kb).
VIR_DOMAIN_MEMORY_STAT_AVAILABLE:
    The total amount of memory available to the domain's OS (in kb).
VIR_DOMAIN_MEMORY_STAT_USABLE:
    How much the balloon can be inflated without pushing the guest system
    to swap, corresponds to 'Available' in /proc/meminfo
VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON:
    Current balloon value (in kb).
VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE
    Timestamp of the last statistic
VIR_DOMAIN_MEMORY_STAT_DISK_CACHES
    Memory that can be reclaimed without additional I/O, typically disk
    caches (in kb).
VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGALLOC
    The number of successful huge page allocations from inside the domain
VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGFAIL
    The number of failed huge page allocations from inside the domain]]></info>
      <return type='int' info='The number of stats provided or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='stats' type='virDomainMemoryStatPtr' info='nr_stats-sized array of stat structures (returned)'/>
      <arg name='nr_stats' type='unsigned int' info='number of memory statistics requested'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainMigrate' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Migrate the domain object from its current host to the destination
host given by dconn (a connection to the destination host).

This function is similar to virDomainMigrate3, but it only supports a fixed
set of parameters: @dname corresponds to VIR_MIGRATE_PARAM_DEST_NAME, @uri
is VIR_MIGRATE_PARAM_URI, and @bandwidth is VIR_MIGRATE_PARAM_BANDWIDTH.

virDomainFree should be used to free the resources after the
returned domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='the new domain object if the migration was successful, or NULL in case of error.  Note that the new domain object exists in the scope of the destination connection (dconn).'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='dconn' type='virConnectPtr' info='destination host (a connection object)'/>
      <arg name='flags' type='unsigned long' info='bitwise-OR of virDomainMigrateFlags'/>
      <arg name='dname' type='const char *' info='(optional) rename domain to this at destination'/>
      <arg name='uri' type='const char *' info='(optional) dest hostname/URI as seen from the source host'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify migration bandwidth limit in MiB/s'/>
    </function>
    <function name='virDomainMigrate2' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Migrate the domain object from its current host to the destination
host given by dconn (a connection to the destination host).

This function is similar to virDomainMigrate3, but it only supports a fixed
set of parameters: @dxml corresponds to VIR_MIGRATE_PARAM_DEST_XML, @dname
is VIR_MIGRATE_PARAM_DEST_NAME, @uri is VIR_MIGRATE_PARAM_URI, and
@bandwidth is VIR_MIGRATE_PARAM_BANDWIDTH.

virDomainFree should be used to free the resources after the
returned domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='the new domain object if the migration was successful, or NULL in case of error.  Note that the new domain object exists in the scope of the destination connection (dconn).'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='dconn' type='virConnectPtr' info='destination host (a connection object)'/>
      <arg name='dxml' type='const char *' info='(optional) XML config for launching guest on target'/>
      <arg name='flags' type='unsigned long' info='bitwise-OR of virDomainMigrateFlags'/>
      <arg name='dname' type='const char *' info='(optional) rename domain to this at destination'/>
      <arg name='uri' type='const char *' info='(optional) dest hostname/URI as seen from the source host'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify migration bandwidth limit in MiB/s'/>
    </function>
    <function name='virDomainMigrate3' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Migrate the domain object from its current host to the destination host
given by dconn (a connection to the destination host).

See VIR_MIGRATE_PARAM_* and virDomainMigrateFlags for detailed description
of accepted migration parameters and flags.

See virDomainMigrateFlags documentation for description of individual flags.

VIR_MIGRATE_TUNNELLED and VIR_MIGRATE_PEER2PEER are not supported by this
API, use virDomainMigrateToURI3 instead.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.

virDomainFree should be used to free the resources after the
returned domain object is no longer needed.]]></info>
      <return type='virDomainPtr' info='the new domain object if the migration was successful, or NULL in case of error.  Note that the new domain object exists in the scope of the destination connection (dconn).'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='dconn' type='virConnectPtr' info='destination host (a connection object)'/>
      <arg name='params' type='virTypedParameterPtr' info='(optional) migration parameters'/>
      <arg name='nparams' type='unsigned int' info='(optional) number of migration parameters in @params'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainMigrateFlags'/>
    </function>
    <function name='virDomainMigrateGetCompressionCache' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Gets current size of the cache (in bytes) used for compressing repeatedly
transferred memory pages during live migration.]]></info>
      <return type='int' info='0 in case of success, -1 otherwise.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='cacheSize' type='unsigned long long *' info='return value of current size of the cache (in bytes)'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainMigrateGetMaxDowntime' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Gets current maximum tolerable time for which the domain may be paused
at the end of live migration.]]></info>
      <return type='int' info='0 in case of success, -1 otherwise.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='downtime' type='unsigned long long *' info='return value of the maximum tolerable downtime for live migration, in milliseconds'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainMigrateGetMaxSpeed' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Get the current maximum bandwidth (in MiB/s) that will be used if the
domain is migrated.  Not all hypervisors will support a bandwidth limit.
When VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY is set in @flags, this API
gets the current maximum bandwidth for the post-copy phase of the
migration.]]></info>
      <return type='int' info='0 in case of success, -1 otherwise.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='bandwidth' type='unsigned long *' info='return value of current migration bandwidth limit in MiB/s'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainMigrateMaxSpeedFlags'/>
    </function>
    <function name='virDomainMigrateSetCompressionCache' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Sets size of the cache (in bytes) used for compressing repeatedly
transferred memory pages during live migration. It's supposed to be called
while the domain is being live-migrated as a reaction to migration progress
and increasing number of compression cache misses obtained from
virDomainGetJobStats.]]></info>
      <return type='int' info='0 in case of success, -1 otherwise.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='cacheSize' type='unsigned long long' info='size of the cache (in bytes) used for compression'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainMigrateSetMaxDowntime' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Sets maximum tolerable time for which the domain is allowed to be paused
at the end of live migration. It's supposed to be called while the domain is
being live-migrated as a reaction to migration progress.]]></info>
      <return type='int' info='0 in case of success, -1 otherwise.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='downtime' type='unsigned long long' info='maximum tolerable downtime for live migration, in milliseconds'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainMigrateSetMaxSpeed' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[The maximum bandwidth (in MiB/s) that will be used to do migration
can be specified with the bandwidth parameter. Not all hypervisors
will support a bandwidth cap. When VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY
is set in @flags, this API sets the maximum bandwidth for the post-copy
phase of the migration.]]></info>
      <return type='int' info='0 in case of success, -1 otherwise.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='bandwidth' type='unsigned long' info='migration bandwidth limit in MiB/s'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainMigrateMaxSpeedFlags'/>
    </function>
    <function name='virDomainMigrateStartPostCopy' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Starts post-copy migration. This function has to be called while
migration (initiated with VIR_MIGRATE_POSTCOPY flag) is in progress.

Traditional pre-copy migration iteratively walks through guest memory
pages and migrates those that changed since the previous iteration. The
iterative phase stops when the number of dirty pages is low enough so that
the virtual CPUs can be paused, all dirty pages transferred to the
destination, where the virtual CPUs are unpaused, and all this can happen
within a predefined downtime period. It's clear that this process may never
converge if downtime is too short and/or the guest keeps changing a lot of
memory pages.

When migration is switched to post-copy mode, the virtual CPUs are paused
immediately, only a minimum set of pages is transferred, and the CPUs are
unpaused on destination. The source keeps sending all remaining memory pages
to the destination while the guest is already running there. Whenever the
guest tries to read a memory page which has not been migrated yet, the
hypervisor has to tell the source to transfer that page in a priority
channel. To minimize such page faults, it is a good idea to run at least one
iteration of pre-copy migration before switching to post-copy.

Post-copy migration is guaranteed to converge since each page is transferred
at most once no matter how fast it changes. On the other hand once the
guest is running on the destination host, the migration can no longer be
rolled back because none of the hosts has complete state. If this happens,
libvirt will leave the domain paused on both hosts with
VIR_DOMAIN_PAUSED_POSTCOPY_FAILED reason. It's up to the upper layer to
decide what to do in such case. Because of this, libvirt will refuse to
cancel post-copy migration via virDomainAbortJob.

The following domain life cycle events are emitted during post-copy
migration:
 VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY (on the source) -- migration entered
     post-copy mode.
 VIR_DOMAIN_EVENT_RESUMED_POSTCOPY (on the destination) -- the guest is
     running on the destination host while some of its memory pages still
     remain on the source host; neither the source nor the destination host
     contain a complete guest state from this point until migration
     finishes.
 VIR_DOMAIN_EVENT_RESUMED_MIGRATED (on the destination),
 VIR_DOMAIN_EVENT_STOPPED_MIGRATED (on the source) -- migration finished
     successfully and the destination host holds a complete guest state.
 VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED (on the destination) -- emitted
     when migration fails in post-copy mode and it's unclear whether any
     of the hosts has a complete guest state.

The progress of a post-copy migration can be monitored normally using
virDomainGetJobStats on the source host. Fetching statistics of a completed
post-copy migration can also be done on the source host (by calling
virDomainGetJobStats or listening to VIR_DOMAIN_EVENT_ID_JOB_COMPLETED
event, but (in contrast to pre-copy migration) the statistics are not
available on the destination host. Thus, VIR_DOMAIN_EVENT_ID_JOB_COMPLETED
event is the only way of getting statistics of a completed post-copy
migration of a transient domain (because the domain is removed after
migration and there's no domain to run virDomainGetJobStats on).]]></info>
      <return type='int' info='0 in case of success, -1 otherwise.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainMigrateToURI' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Migrate the domain object from its current host to the destination
host given by duri.

This function is similar to virDomainMigrateToURI3, but it only supports a
fixed set of parameters: @dname corresponds to VIR_MIGRATE_PARAM_DEST_NAME,
and @bandwidth corresponds to VIR_MIGRATE_PARAM_BANDWIDTH.

The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.

If the VIR_MIGRATE_PEER2PEER flag IS set, the @duri parameter must be a
valid libvirt connection URI, by which the source libvirt driver can connect
to the destination libvirt. In other words, @duri corresponds to @dconnuri
of virDomainMigrateToURI3.

If the VIR_MIGRATE_PEER2PEER flag is NOT set, the @duri parameter takes a
hypervisor specific URI used to initiate the migration. In this case @duri
corresponds to VIR_MIGRATE_PARAM_URI of virDomainMigrateToURI3.]]></info>
      <return type='int' info='0 if the migration succeeded, -1 upon error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='duri' type='const char *' info='mandatory URI for the destination host'/>
      <arg name='flags' type='unsigned long' info='bitwise-OR of virDomainMigrateFlags'/>
      <arg name='dname' type='const char *' info='(optional) rename domain to this at destination'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify migration bandwidth limit in MiB/s'/>
    </function>
    <function name='virDomainMigrateToURI2' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Migrate the domain object from its current host to the destination
host given by @dconnuri.

This function is similar to virDomainMigrateToURI3, but it only supports a
fixed set of parameters: @miguri corresponds to VIR_MIGRATE_PARAM_URI, @dxml
is VIR_MIGRATE_PARAM_DEST_XML, @dname is VIR_MIGRATE_PARAM_DEST_NAME, and
@bandwidth corresponds to VIR_MIGRATE_PARAM_BANDWIDTH.

The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.

If the VIR_MIGRATE_PEER2PEER flag IS set, the @dconnuri parameter must be a
valid libvirt connection URI, by which the source libvirt driver can connect
to the destination libvirt. In other words, @dconnuri has the same semantics
as in virDomainMigrateToURI3.

If the VIR_MIGRATE_PEER2PEER flag is NOT set, the @dconnuri must be NULL
and the @miguri parameter takes a hypervisor specific URI used to initiate
the migration. In this case @miguri corresponds to VIR_MIGRATE_PARAM_URI of
virDomainMigrateToURI3.]]></info>
      <return type='int' info='0 if the migration succeeded, -1 upon error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='dconnuri' type='const char *' info='(optional) URI for target libvirtd if @flags includes VIR_MIGRATE_PEER2PEER'/>
      <arg name='miguri' type='const char *' info='(optional) URI for invoking the migration, not if @flags includs VIR_MIGRATE_TUNNELLED'/>
      <arg name='dxml' type='const char *' info='(optional) XML config for launching guest on target'/>
      <arg name='flags' type='unsigned long' info='bitwise-OR of virDomainMigrateFlags'/>
      <arg name='dname' type='const char *' info='(optional) rename domain to this at destination'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify migration bandwidth limit in MiB/s'/>
    </function>
    <function name='virDomainMigrateToURI3' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Migrate the domain object from its current host to the destination host
given by URI.

See VIR_MIGRATE_PARAM_* and virDomainMigrateFlags for detailed description
of accepted migration parameters and flags.

The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.

If the VIR_MIGRATE_PEER2PEER flag is set, the @dconnuri parameter must be a
valid libvirt connection URI, by which the source libvirt daemon can connect
to the destination libvirt.

If the VIR_MIGRATE_PEER2PEER flag is NOT set, then @dconnuri must be NULL
and VIR_MIGRATE_PARAM_URI migration parameter must be filled in with
hypervisor specific URI used to initiate the migration. The uri_transports
element of the hypervisor capabilities XML includes supported URI schemes.
This is called "direct" migration. Not all hypervisors support this mode of
migration, so if the VIR_MIGRATE_PEER2PEER flag is not set, then it may be
necessary to use the alternative virDomainMigrate3 API providing an explicit
virConnectPtr for the destination host.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.]]></info>
      <return type='int' info='0 if the migration succeeded, -1 upon error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='dconnuri' type='const char *' info='(optional) URI for target libvirtd if @flags includes VIR_MIGRATE_PEER2PEER'/>
      <arg name='params' type='virTypedParameterPtr' info='(optional) migration parameters'/>
      <arg name='nparams' type='unsigned int' info='(optional) number of migration parameters in @params'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainMigrateFlags'/>
    </function>
    <function name='virDomainOpenChannel' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This opens the host interface associated with a channel device on a
guest, if the host interface is supported.  If @name is given, it
can match either the device alias (e.g. "channel0"), or the virtio
target name (e.g. "org.qemu.guest_agent.0").  If @name is omitted,
then the first channel is opened. The channel is associated with
the passed in @st stream, which should have been opened in
non-blocking mode for bi-directional I/O.

By default, when @flags is 0, the open will fail if libvirt detects
that the channel is already in use by another client; passing
VIR_DOMAIN_CHANNEL_FORCE will cause libvirt to forcefully remove the
other client prior to opening this channel.]]></info>
      <return type='int' info='0 if the channel was opened, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='name' type='const char *' info='the channel name, or NULL'/>
      <arg name='st' type='virStreamPtr' info='a stream to associate with the channel'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainChannelFlags'/>
    </function>
    <function name='virDomainOpenConsole' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This opens the backend associated with a console, serial or
parallel port device on a guest, if the backend is supported.
If the @dev_name is omitted, then the first console or serial
device is opened. The console is associated with the passed
in @st stream, which should have been opened in non-blocking
mode for bi-directional I/O.

By default, when @flags is 0, the open will fail if libvirt
detects that the console is already in use by another client;
passing VIR_DOMAIN_CONSOLE_FORCE will cause libvirt to forcefully
remove the other client prior to opening this console.

If flag VIR_DOMAIN_CONSOLE_SAFE the console is opened only in the
case where the hypervisor driver supports safe (mutually exclusive)
console handling.

Older servers did not support either flag, and also did not forbid
simultaneous clients on a console, with potentially confusing results.
When passing @flags of 0 in order to support a wider range of server
versions, it is up to the client to ensure mutual exclusion.]]></info>
      <return type='int' info='0 if the console was opened, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='dev_name' type='const char *' info='the console, serial or parallel port device alias, or NULL'/>
      <arg name='st' type='virStreamPtr' info='a stream to associate with the console'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainConsoleFlags'/>
    </function>
    <function name='virDomainOpenGraphics' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This will attempt to connect the file descriptor @fd, to
the graphics backend of @dom. If @dom has multiple graphics
backends configured, then @idx will determine which one is
opened, starting from @idx 0.

To disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH
constant for @flags.

The caller should use an anonymous socketpair to open
@fd before invocation.

This method can only be used when connected to a local
libvirt hypervisor, over a UNIX domain socket. Attempts
to use this method over a TCP connection will always fail]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='idx' type='unsigned int' info='index of graphics config to open'/>
      <arg name='fd' type='int' info='file descriptor to attach graphics to'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainOpenGraphicsFlags'/>
    </function>
    <function name='virDomainOpenGraphicsFD' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This will create a socket pair connected to the graphics backend of @dom.
One end of the socket will be returned on success, and the other end is
handed to the hypervisor.
If @dom has multiple graphics backends configured, then @idx will determine
which one is opened, starting from @idx 0.

To disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH
constant for @flags.

This method can only be used when connected to a local
libvirt hypervisor, over a UNIX domain socket. Attempts
to use this method over a TCP connection will always fail.]]></info>
      <return type='int' info='an fd on success, -1 on failure'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='idx' type='unsigned int' info='index of graphics config to open'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainOpenGraphicsFlags'/>
    </function>
    <function name='virDomainPMSuspendForDuration' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Attempt to have the guest enter the given @target power management
suspension level.  If @duration is non-zero, also schedule the guest to
resume normal operation after that many seconds, if nothing else has
resumed it earlier.  Some hypervisors require that @duration be 0, for
an indefinite suspension.

Dependent on hypervisor used, this may require a
guest agent to be available, e.g. QEMU.

Beware that at least for QEMU, the domain's process will be terminated
when VIR_NODE_SUSPEND_TARGET_DISK is used and a new process will be
launched when libvirt is asked to wake up the domain. As a result of
this, any runtime changes, such as device hotplug or memory settings,
are lost unless such changes were made with VIR_DOMAIN_AFFECT_CONFIG
flag.]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='target' type='unsigned int' info='a value from virNodeSuspendTarget'/>
      <arg name='duration' type='unsigned long long' info='duration in seconds to suspend, or 0 for indefinite'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainPMWakeup' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Inject a wakeup into the guest that previously used
virDomainPMSuspendForDuration, rather than waiting for the
previously requested duration (if any) to elapse.]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainPinEmulator' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the real CPUs which can be allocated to all emulator
threads. This function may require privileged access to the hypervisor.

@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain
and may fail if domain is not alive.
If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.
Not all hypervisors can support all flag combinations.

See also virDomainGetEmulatorPinInfo for querying this information.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='cpumap' type='unsigned char *' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.'/>
      <arg name='maplen' type='int' info='number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainPinIOThread' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the real CPUs which can be allocated to an IOThread.
This function may require privileged access to the hypervisor.

@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain
and may fail if domain is not alive.
If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.
Not all hypervisors can support all flag combinations.

See also virDomainGetIOThreadInfo for querying this information.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='iothread_id' type='unsigned int' info='the IOThread ID to set the CPU affinity'/>
      <arg name='cpumap' type='unsigned char *' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.'/>
      <arg name='maplen' type='int' info='number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainPinVcpu' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the real CPUs which can be allocated to a virtual CPU.
This function may require privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='vcpu' type='unsigned int' info='virtual CPU number'/>
      <arg name='cpumap' type='unsigned char *' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.'/>
      <arg name='maplen' type='int' info='number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.'/>
    </function>
    <function name='virDomainPinVcpuFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the real CPUs which can be allocated to a virtual CPU.
This function may require privileged access to the hypervisor.

@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain
and may fail if domain is not alive.
If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.
Not all hypervisors can support all flag combinations.

See also virDomainGetVcpuPinInfo for querying this information.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='vcpu' type='unsigned int' info='virtual CPU number'/>
      <arg name='cpumap' type='unsigned char *' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.'/>
      <arg name='maplen' type='int' info='number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainReboot' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Reboot a domain, the domain object is still usable thereafter, but
the domain OS is being stopped for a restart.
Note that the guest OS may ignore the request.
Additionally, the hypervisor may check and support the domain
'on_reboot' XML setting resulting in a domain that shuts down instead
of rebooting.

If @flags is set to zero, then the hypervisor will choose the
method of shutdown it considers best. To have greater control
pass one or more of the virDomainRebootFlagValues. The order
in which the hypervisor tries each shutdown method is undefined,
and a hypervisor is not required to support all methods.

To use guest agent (VIR_DOMAIN_REBOOT_GUEST_AGENT) the domain XML
must have <channel> configured.

Due to implementation limitations in some drivers (the qemu driver,
for instance) it is not advised to migrate or save a guest that is
rebooting as a result of this API. Migrating such a guest can lead
to a plain shutdown on the destination.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainRebootFlagValues'/>
    </function>
    <function name='virDomainRef' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Increment the reference count on the domain. For each
additional call to this method, there shall be a corresponding
call to virDomainFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a domain would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='the domain to hold a reference on'/>
    </function>
    <function name='virDomainRename' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Rename a domain. New domain name is specified in the second
argument. Depending on each driver implementation it may be
required that domain is in a specific state.

There might be some attributes and/or elements in domain XML that if no
value provided at XML defining time, libvirt will derive their value from
the domain name. These are not updated by this API. Users are strongly
advised to change these after the rename was successful.]]></info>
      <return type='int' info='0 if successfully renamed, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='new_name' type='const char *' info='new domain name'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainReset' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Reset a domain immediately without any guest OS shutdown.
Reset emulates the power reset button on a machine, where all
hardware sees the RST line set and reinitializes internal state.

Note that there is a risk of data loss caused by reset without any
guest OS shutdown.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainRestore' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This method will restore a domain saved to disk by virDomainSave().

See virDomainRestoreFlags() for more control.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='from' type='const char *' info='path to the input file'/>
    </function>
    <function name='virDomainRestoreFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This method will restore a domain saved to disk by virDomainSave().

If the hypervisor supports it, @dxml can be used to alter
host-specific portions of the domain XML that will be used when
restoring an image.  For example, it is possible to alter the
backing filename that is associated with a disk device, in order to
prepare for file renaming done as part of backing up the disk
device while the domain is stopped.

If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will
attempt to bypass the file system cache while restoring the file, or
fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing restores from NFS.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in
@flags will override the default read from the file.  These two
flags are mutually exclusive.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='from' type='const char *' info='path to the input file'/>
      <arg name='dxml' type='const char *' info='(optional) XML config for adjusting guest xml used on restore'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainSaveRestoreFlags'/>
    </function>
    <function name='virDomainResume' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Resume a suspended domain, the process is restarted from the state where
it was frozen by calling virDomainSuspend().
This function may require privileged access
Moreover, resume may not be supported if domain is in some
special state like VIR_DOMAIN_PMSUSPENDED.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainRevertToSnapshot' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Revert the domain to a given snapshot.

Normally, the domain will revert to the same state the domain was
in while the snapshot was taken (whether inactive, running, or
paused), except that disk snapshots default to reverting to
inactive state.  Including VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING in
@flags overrides the snapshot state to guarantee a running domain
after the revert; or including VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED in
@flags guarantees a paused domain after the revert.  These two
flags are mutually exclusive.  While a persistent domain does not
need either flag, it is not possible to revert a transient domain
into an inactive state, so transient domains require the use of one
of these two flags.

Reverting to any snapshot discards all configuration changes made since
the last snapshot.  Additionally, reverting to a snapshot from a running
domain is a form of data loss, since it discards whatever is in the
guest's RAM at the time.  Since the very nature of keeping snapshots
implies the intent to roll back state, no additional confirmation is
normally required for these lossy effects.

However, there are two particular situations where reverting will
be refused by default, and where @flags must include
VIR_DOMAIN_SNAPSHOT_REVERT_FORCE to acknowledge the risks.  1) Any
attempt to revert to a snapshot that lacks the metadata to perform
ABI compatibility checks (generally the case for snapshots that
lack a full <domain> when listed by virDomainSnapshotGetXMLDesc(),
such as those created prior to libvirt 0.9.5).  2) Any attempt to
revert a running domain to an active state that requires starting a
new hypervisor instance rather than reusing the existing hypervisor
(since this would terminate all connections to the domain, such as
such as VNC or Spice graphics) - this condition arises from active
snapshots that are provably ABI incompatible, as well as from
inactive snapshots with a @flags request to start the domain after
the revert.]]></info>
      <return type='int' info='0 if the creation is successful, -1 on error.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainSnapshotRevertFlags'/>
    </function>
    <function name='virDomainSave' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore (this ends the life of a transient domain).
Use virDomainRestore() to restore a domain after saving.

See virDomainSaveFlags() for more control.  Also, a save file can
be inspected or modified slightly with virDomainSaveImageGetXMLDesc()
and virDomainSaveImageDefineXML().]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the output file'/>
    </function>
    <function name='virDomainSaveFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore (this ends the life of a transient domain).
Use virDomainRestore() to restore a domain after saving.

If the hypervisor supports it, @dxml can be used to alter
host-specific portions of the domain XML that will be used when
restoring an image.  For example, it is possible to alter the
backing filename that is associated with a disk device, in order to
prepare for file renaming done as part of backing up the disk
device while the domain is stopped.

If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will
attempt to bypass the file system cache while creating the file, or
fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in
@flags will override what state gets saved into the file.  These
two flags are mutually exclusive.

A save file can be inspected or modified slightly with
virDomainSaveImageGetXMLDesc() and virDomainSaveImageDefineXML().

Some hypervisors may prevent this operation if there is a current
block job running; in that case, use virDomainBlockJobAbort()
to stop the block job first.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the output file'/>
      <arg name='dxml' type='const char *' info='(optional) XML config for adjusting guest xml used on restore'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainSaveRestoreFlags'/>
    </function>
    <function name='virDomainSaveImageDefineXML' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This updates the definition of a domain stored in a saved state
file.  @file must be a file created previously by virDomainSave()
or virDomainSaveFlags().

@dxml can be used to alter host-specific portions of the domain XML
that will be used when restoring an image.  For example, it is
possible to alter the backing filename that is associated with a
disk device, to match renaming done as part of backing up the disk
device while the domain is stopped.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in
@flags will override the default saved into the file; omitting both
leaves the file's default unchanged.  These two flags are mutually
exclusive.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='file' type='const char *' info='path to saved state file'/>
      <arg name='dxml' type='const char *' info='XML config for adjusting guest xml used on restore'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainSaveRestoreFlags'/>
    </function>
    <function name='virDomainSaveImageGetXMLDesc' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[This method will extract the XML describing the domain at the time
a saved state file was created.  @file must be a file created
previously by virDomainSave() or virDomainSaveFlags().

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_SAVE_IMAGE_XML_SECURE.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error.  The caller must free() the returned value.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='file' type='const char *' info='path to saved state file'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSaveImageXMLFlags'/>
    </function>
    <function name='virDomainScreenshot' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Take a screenshot of current domain console as a stream. The image format
is hypervisor specific. Moreover, some hypervisors supports multiple
displays per domain. These can be distinguished by @screen argument.

This call sets up a stream; subsequent use of stream API is necessary
to transfer actual data, determine how much data is successfully
transferred, and detect any errors.

The screen ID is the sequential number of screen. In case of multiple
graphics cards, heads are enumerated before devices, e.g. having
two graphics cards, both with four heads, screen ID 5 addresses
the second head on the second card.]]></info>
      <return type='char *' info='a string representing the mime-type of the image format, or NULL upon error. The caller must free() the returned value.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='stream' type='virStreamPtr' info='stream to use as output'/>
      <arg name='screen' type='unsigned int' info='monitor ID to take screenshot from'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainSendKey' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Send key(s) to the guest.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='codeset' type='unsigned int' info='the code set of keycodes, from virKeycodeSet'/>
      <arg name='holdtime' type='unsigned int' info='the duration (in milliseconds) that the keys will be held'/>
      <arg name='keycodes' type='unsigned int *' info='array of keycodes'/>
      <arg name='nkeycodes' type='int' info='number of keycodes, up to VIR_DOMAIN_SEND_KEY_MAX_KEYS'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainSendProcessSignal' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Send a signal to the designated process in the guest

The signal numbers must be taken from the virDomainProcessSignal
enum. These will be translated to the corresponding signal
number for the guest OS, by the guest agent delivering the
signal. If there is no mapping from virDomainProcessSignal to
the native OS signals, this API will report an error.

If @pid_value is an integer greater than zero, it is
treated as a process ID. If @pid_value is an integer
less than zero, it is treated as a process group ID.
All the @pid_value numbers are from the container/guest
namespace. The value zero is not valid.

Not all hypervisors will support sending signals to
arbitrary processes or process groups. If this API is
implemented the minimum requirement is to be able to
use @pid_value == 1 (i.e. kill init). No other value is
required to be supported.

If the @signum is VIR_DOMAIN_PROCESS_SIGNAL_NOP then this
API will simply report whether the process is running in
the container/guest.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='pid_value' type='long long' info='a positive integer process ID, or negative integer process group ID'/>
      <arg name='signum' type='unsigned int' info='a signal from the virDomainProcessSignal enum'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virDomainSetAutostart' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Configure the domain to be automatically started
when the host machine boots.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='autostart' type='int' info='whether the domain should be automatically started 0 or 1'/>
    </function>
    <function name='virDomainSetBlkioParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Change all or a subset of the blkio tunables.
This function may require privileged access to the hypervisor.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to blkio parameter objects'/>
      <arg name='nparams' type='int' info='number of blkio parameters (this value can be the same or less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetBlockIoTune' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Change all or a subset of the per-device block IO tunables.

The @disk parameter is either an unambiguous source name of the
block device (the <source file='...'/> sub-element, such as
"/path/to/image"), or the device target shorthand (the <target
dev='...'/> sub-element, such as "xvda").  Valid names can be found
by calling virDomainGetXMLDesc() and inspecting elements
within //domain/devices/disk.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='disk' type='const char *' info='path to the block device, or device shorthand'/>
      <arg name='params' type='virTypedParameterPtr' info='Pointer to blkio parameter objects'/>
      <arg name='nparams' type='int' info='Number of blkio parameters (this value can be the same or less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetBlockThreshold' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Set the threshold level for delivering the
VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD if the device or backing chain element
described by @dev is written beyond the set threshold level. The threshold
level is unset once the event fires. The event might not be delivered at all
if libvirtd was not running at the moment when the threshold was reached.
Note that if the threshold level is reached for a top level image, the event
is emitted for @dev corresponding to the disk target, and may also be reported
with @dev corresponding to the disk target with an index corresponding to the
'index' attribute of 'source' in the live VM XML if the attribute is present.

@dev can either be a disk target name (vda, sda) or disk target with index (
vda[4]). Without the index the top image in the backing chain will have the
threshold set. The index corresponds to the 'index' attribute reported in the
live VM XML for 'backingStore' or 'source' elements of a disk. If index is
given the threshold is set for the corresponding image.

Note that the threshold event can be registered also for destinations of a
'virDomainBlockCopy' destination by using the 'index' of the 'mirror' source.

Hypervisors report the last written sector of an image in the bulk stats API
(virConnectGetAllDomainStats/virDomainListGetStats) as
"block.<num>.allocation" in the VIR_DOMAIN_STATS_BLOCK group. The current
threshold value is reported as "block.<num>.threshold".

This event allows to use thin-provisioned storage which needs management
tools to grow it without the need for polling of the data.]]></info>
      <return type='int' info='0 if the operation has started, -1 on failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='dev' type='const char *' info='string specifying the block device or backing chain element'/>
      <arg name='threshold' type='unsigned long long' info='threshold in bytes when to fire the event'/>
      <arg name='flags' type='unsigned int' info='currently unused, callers should pass 0'/>
    </function>
    <function name='virDomainSetGuestVcpus' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Sets state of individual vcpus described by @cpumap via guest agent. Other
vcpus are not modified.

This API requires the VM to run. Various hypervisors or guest agent
implementation may limit to operate on just 1 vCPU per call.

@cpumap is a list of vCPU numbers. Its syntax is a comma separated list and
a special markup using '-' and '^' (ex. '0-4', '0-3,^2'). The '-' denotes
the range and the '^' denotes exclusive. The expression is sequentially
evaluated, so "0-15,^8" is identical to "9-14,0-7,15" but not identical to
"^8,0-15".

Note that OSes (notably Linux) may require vCPU 0 to stay online to support
low-level features a S3 sleep.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='cpumap' type='const char *' info='text representation of a bitmap of vcpus to set'/>
      <arg name='state' type='int' info='0 to disable/1 to enable cpus described by @cpumap'/>
      <arg name='flags' type='unsigned int' info='currently unused, callers shall pass 0'/>
    </function>
    <function name='virDomainSetIOThreadParams' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically set IOThread parameters to the domain. It is left up to
the underlying virtual hypervisor to determine the valid range for an
@iothread_id, determining whether the @iothread_id already exists, and
determining the validity of the provided param values.

See VIR_DOMAIN_IOTHREAD_* for detailed description of accepted IOThread
parameters.

Since the purpose of this API is to dynamically modify the IOThread
@flags should only include the VIR_DOMAIN_AFFECT_CURRENT and/or
VIR_DOMAIN_AFFECT_LIVE virDomainMemoryModFlags. Setting other flags
may cause errors from the hypervisor.

Note that this call can fail if the underlying virtualization hypervisor
does not support it or does not support setting the provided values.

This function requires privileged access to the hypervisor.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='iothread_id' type='unsigned int' info='the specific IOThread ID value to add'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to IOThread parameter objects'/>
      <arg name='nparams' type='int' info='number of IOThread parameters'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact and virTypedParameterFlags'/>
    </function>
    <function name='virDomainSetInterfaceParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Change a subset or all parameters of interface; currently this
includes bandwidth parameters.  The value of @flags should be
either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of values
VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG, although
hypervisors vary in which flags are supported.

This function may require privileged access to the hypervisor.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='device' type='const char *' info='the interface name or mac address'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to interface parameter objects'/>
      <arg name='nparams' type='int' info='number of interface parameter (this value can be the same or less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetLifecycleAction' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Changes the actions of lifecycle events for domain represented as
<on_$type>$action</on_$type> in the domain XML.

QEMU driver has a limitation that if all lifecycle events are set
to destroy when the domain is started, it's not possible to change
any action for running domain.]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='type' type='unsigned int' info='the lifecycle type from virDomainLifecycle'/>
      <arg name='action' type='unsigned int' info='the action type from virDomainLifecycleAction'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetMaxMemory' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may require privileged access to the hypervisor.

This command is hypervisor-specific for whether active, persistent,
or both configurations are changed; for more control, use
virDomainSetMemoryFlags().]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kibibytes (blocks of 1024 bytes)'/>
    </function>
    <function name='virDomainSetMemory' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the target amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may require privileged access to the hypervisor.

This command is hypervisor-specific for whether active, persistent,
or both configurations are changed; for more control, use
virDomainSetMemoryFlags().]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kibibytes (blocks of 1024 bytes)'/>
    </function>
    <function name='virDomainSetMemoryFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the target amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may require privileged access to the hypervisor.

@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set. If VIR_DOMAIN_AFFECT_LIVE is set, the change affects
a running domain and will fail if domain is not active.
If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified
(that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain
modifies persistent setup, while an active domain is hypervisor-dependent
on whether just live or both live and persistent state is changed.
If VIR_DOMAIN_MEM_MAXIMUM is set, the change affects domain's maximum memory
size rather than current memory size.
Not all hypervisors can support all flag combinations.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kibibytes (blocks of 1024 bytes)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainMemoryModFlags'/>
    </function>
    <function name='virDomainSetMemoryParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Change all or a subset of the memory tunables.
This function may require privileged access to the hypervisor.

Possible values for all *_limit memory tunables are in range from 0 to
VIR_DOMAIN_MEMORY_PARAM_UNLIMITED.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to memory parameter objects'/>
      <arg name='nparams' type='int' info='number of memory parameter (this value can be the same or less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetMemoryStatsPeriod' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the domain memory balloon driver statistics collection
period. Use 0 to disable and a positive value to enable.

@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set. If VIR_DOMAIN_AFFECT_LIVE is set, the change affects
a running domain and will fail if domain is not active.
If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified
(that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain
modifies persistent setup, while an active domain is hypervisor-dependent
on whether just live or both live and persistent state is changed.

Not all hypervisors can support all flag combinations.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='period' type='int' info='the period in seconds for stats collection'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainMemoryModFlags'/>
    </function>
    <function name='virDomainSetMetadata' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Sets the appropriate domain element given by @type to the
value of @metadata.  A @type of VIR_DOMAIN_METADATA_DESCRIPTION
is free-form text; VIR_DOMAIN_METADATA_TITLE is free-form, but no
newlines are permitted, and should be short (although the length is
not enforced). For these two options @key and @uri are irrelevant and
must be set to NULL.

For type VIR_DOMAIN_METADATA_ELEMENT @metadata  must be well-formed
XML belonging to namespace defined by @uri with local name @key.

Passing NULL for @metadata says to remove that element from the
domain XML (passing the empty string leaves the element present).

The resulting metadata will be present in virDomainGetXMLDesc(),
as well as quick access through virDomainGetMetadata().

@flags controls whether the live domain, persistent configuration,
or both will be modified.]]></info>
      <return type='int' info='0 on success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='type' type='int' info='type of metadata, from virDomainMetadataType'/>
      <arg name='metadata' type='const char *' info='new metadata text'/>
      <arg name='key' type='const char *' info='XML namespace key, or NULL'/>
      <arg name='uri' type='const char *' info='XML namespace URI, or NULL'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetNumaParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Change all or a subset of the numa tunables.
This function may require privileged access to the hypervisor.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to numa parameter objects'/>
      <arg name='nparams' type='int' info='number of numa parameters (this value can be the same or less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetPerfEvents' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Enable or disable the particular list of Linux perf events you
care about. The @params argument should contain any subset of
VIR_PERF_EVENT_ macros.

Linux perf events are performance analyzing tool in Linux.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to perf events parameter object'/>
      <arg name='nparams' type='int' info='number of perf event parameters (this value can be the same less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetSchedulerParameters' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Change all or a subset or the scheduler parameters.  It is
hypervisor-specific whether this sets live, persistent, or both
settings; for more control, use
virDomainSetSchedulerParametersFlags.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to scheduler parameter objects'/>
      <arg name='nparams' type='int' info='number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)'/>
    </function>
    <function name='virDomainSetSchedulerParametersFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Change a subset or all scheduler parameters.  The value of @flags
should be either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of
values from VIR_DOMAIN_AFFECT_LIVE and
VIR_DOMAIN_AFFECT_CURRENT, although hypervisors vary in which
flags are supported.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to scheduler parameter objects'/>
      <arg name='nparams' type='int' info='number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetTime' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[When a domain is suspended or restored from a file the
domain's OS has no idea that there was a big gap in the time.
Depending on how long the gap was, NTP might not be able to
resynchronize the guest.

This API tries to set guest time to the given value. The time
to set (@seconds and @nseconds) should be in seconds relative
to the Epoch of 1970-01-01 00:00:00 in UTC.

Please note that some hypervisors may require guest agent to
be configured and running in order to be able to run this API.]]></info>
      <return type='int' info='0 on success, -1 otherwise.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='seconds' type='long long' info='time to set'/>
      <arg name='nseconds' type='unsigned int' info='the nanosecond part of @seconds'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainSetTimeFlags'/>
    </function>
    <function name='virDomainSetUserPassword' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Sets the @user password to the value specified by @password.
If @flags contain VIR_DOMAIN_PASSWORD_ENCRYPTED, the password
is assumed to be encrypted by the method required by the guest OS.

Please note that some hypervisors may require guest agent to
be configured and running in order to be able to run this API.]]></info>
      <return type='int' info='0 on success, -1 otherwise.'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='user' type='const char *' info='the username that will get a new password'/>
      <arg name='password' type='const char *' info='the password to set'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainSetUserPasswordFlags'/>
    </function>
    <function name='virDomainSetVcpu' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Enables/disables individual vcpus described by @vcpumap in the hypervisor.

Various hypervisor implementations may limit to operate on just 1
hotpluggable entity (which may contain multiple vCPUs on certain platforms).

Note that OSes and hypervisors may require vCPU 0 to stay online.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='vcpumap' type='const char *' info='text representation of a bitmap of vcpus to set'/>
      <arg name='state' type='int' info='0 to disable/1 to enable cpus described by @vcpumap'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainModificationImpact'/>
    </function>
    <function name='virDomainSetVcpus' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrarily limited.
This function may require privileged access to the hypervisor.

Note that if this call is executed before the guest has finished booting,
the guest may fail to process the change.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.  It is hypervisor-dependent
whether it also affects persistent configuration; for more control,
use virDomainSetVcpusFlags().]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='nvcpus' type='unsigned int' info='the new number of virtual CPUs for this domain'/>
    </function>
    <function name='virDomainSetVcpusFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrarily limited.
This function may require privileged access to the hypervisor.

@flags may include VIR_DOMAIN_AFFECT_LIVE to affect a running
domain (which may fail if domain is not active), or
VIR_DOMAIN_AFFECT_CONFIG to affect the next boot via the XML
description of the domain.  Both flags may be set.
If neither flag is specified (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT),
then an inactive domain modifies persistent setup, while an active domain
is hypervisor-dependent on whether just live or both live and persistent
state is changed.

Note that if this call is executed before the guest has finished booting,
the guest may fail to process the change.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then
VIR_DOMAIN_AFFECT_LIVE must be clear, and only the maximum virtual
CPU limit is altered; generally, this value must be less than or
equal to virConnectGetMaxVcpus().  Otherwise, this call affects the
current virtual CPU limit, which must be less than or equal to the
maximum limit. Note that hypervisors may not allow changing the maximum
vcpu count if processor topology is specified.

If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of processors is
modified inside the guest instead of the hypervisor. This flag can only
be used with live guests and is incompatible with VIR_DOMAIN_VCPU_MAXIMUM.
The usage of this flag may require a guest agent configured.

Not all hypervisors can support all flag combinations.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='nvcpus' type='unsigned int' info='the new number of virtual CPUs for this domain, must be at least 1'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainVcpuFlags'/>
    </function>
    <function name='virDomainShutdown' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Shutdown a domain, the domain object is still usable thereafter, but
the domain OS is being stopped. Note that the guest OS may ignore the
request. Additionally, the hypervisor may check and support the domain
'on_poweroff' XML setting resulting in a domain that reboots instead of
shutting down. For guests that react to a shutdown request, the differences
from virDomainDestroy() are that the guests disk storage will be in a
stable state rather than having the (virtual) power cord pulled, and
this command returns as soon as the shutdown request is issued rather
than blocking until the guest is no longer running.

If the domain is transient and has any snapshot metadata (see
virDomainSnapshotNum()), then that metadata will automatically
be deleted when the domain quits.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainShutdownFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Shutdown a domain, the domain object is still usable thereafter but
the domain OS is being stopped. Note that the guest OS may ignore the
request. Additionally, the hypervisor may check and support the domain
'on_poweroff' XML setting resulting in a domain that reboots instead of
shutting down. For guests that react to a shutdown request, the differences
from virDomainDestroy() are that the guest's disk storage will be in a
stable state rather than having the (virtual) power cord pulled, and
this command returns as soon as the shutdown request is issued rather
than blocking until the guest is no longer running.

If the domain is transient and has any snapshot metadata (see
virDomainSnapshotNum()), then that metadata will automatically
be deleted when the domain quits.

If @flags is set to zero, then the hypervisor will choose the
method of shutdown it considers best. To have greater control
pass one or more of the virDomainShutdownFlagValues. The order
in which the hypervisor tries each shutdown method is undefined,
and a hypervisor is not required to support all methods.

To use guest agent (VIR_DOMAIN_SHUTDOWN_GUEST_AGENT) the domain XML
must have <channel> configured.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainShutdownFlagValues'/>
    </function>
    <function name='virDomainSnapshotCreateXML' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Creates a new snapshot of a domain based on the snapshot xml
contained in xmlDesc, with a top-level element <domainsnapshot>.

If @flags is 0, the domain can be active, in which case the
snapshot will be a full system snapshot (capturing both disk state,
and runtime VM state such as RAM contents), where reverting to the
snapshot is
the same as resuming from hibernation (TCP connections may have
timed out, but everything else picks up where it left off); or
the domain can be inactive, in which case the snapshot includes
just the disk state prior to booting.  The newly created snapshot
becomes current (see virDomainSnapshotCurrent()), and is a child
of any previous current snapshot.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE, then @xmlDesc
is validated against the <domainsnapshot> XML schema.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE, then this
is a request to reinstate snapshot metadata that was previously
captured from virDomainSnapshotGetXMLDesc() before removing that
metadata, rather than creating a new snapshot.  This can be used to
recreate a snapshot hierarchy on a destination, then remove it on
the source, in order to allow migration (since migration normally
fails if snapshot metadata still remains on the source machine).
Note that while original creation can omit a number of elements
from @xmlDesc (and libvirt will supply sane defaults based on the
domain state at that point in time), a redefinition must supply
more elements (as the domain may have changed in the meantime, so
that libvirt no longer has a way to resupply correct
defaults). When redefining snapshot metadata, the domain's current
snapshot will not be altered unless the
VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT flag is also present.  It is an
error to request the VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT flag
without VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE.  On some hypervisors,
redefining an existing snapshot can be used to alter host-specific
portions of the domain XML to be used during revert (such as
backing filenames associated with disk devices), but must not alter
guest-visible layout.  When redefining a snapshot name that does
not exist, the hypervisor may validate that reverting to the
snapshot appears to be possible (for example, disk images have
snapshot contents by the requested name).  Not all hypervisors
support these flags.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA, then the
domain's disk images are modified according to @xmlDesc, but
libvirt does not track any metadata (similar to immediately calling
virDomainSnapshotDelete() with
VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY).  This flag is
incompatible with VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_HALT, then the domain
will be inactive after the snapshot completes, regardless of whether
it was active before; otherwise, a running domain will still be
running after the snapshot.  This flag is invalid on transient domains,
and is incompatible with VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_LIVE, then the domain
is not paused while creating the snapshot. This increases the size
of the memory dump file, but reduces downtime of the guest while
taking the snapshot. Some hypervisors only support this flag during
external snapshots.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY, then the
snapshot will be limited to the disks described in @xmlDesc, and no
VM state will be saved.  For an active guest, the disk image may be
inconsistent (as if power had been pulled), and specifying this
with the VIR_DOMAIN_SNAPSHOT_CREATE_HALT flag risks data loss.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE, then the
libvirt will attempt to use guest agent to freeze and thaw all
file systems in use within domain OS. However, if the guest agent
is not present, an error is thrown. Moreover, this flag requires
VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY to be passed as well.

By default, if the snapshot involves external files, and any of the
destination files already exist as a non-empty regular file, the
snapshot is rejected to avoid losing contents of those files.
However, if @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT,
then the destination files must be pre-created manually with
the correct image format and metadata including backing store path
(this allows a management app to pre-create files with relative backing
file names, rather than the default of creating with absolute backing
file names). Note that only the file specified in the snapshot XML is
inserted as a snapshot thus setting incorrect metadata in the pre-created
image may lead to the VM being unable to start or other block jobs may fail.

Be aware that although libvirt prefers to report errors up front with
no other effect, some hypervisors have certain types of failures where
the overall command can easily fail even though the guest configuration
was partially altered (for example, if a disk snapshot request for two
disks fails on the second disk, but the first disk alteration cannot be
rolled back).  If this API call fails, it is therefore normally
necessary to follow up with virDomainGetXMLDesc() and check each disk
to determine if any partial changes occurred.  However, if @flags
contains VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC, then libvirt guarantees
that this command will not alter any disks unless the entire set of
changes can be done atomically, making failure recovery simpler (note
that it is still possible to fail after disks have changed, but only
in the much rarer cases of running out of memory or disk space).

Some hypervisors may prevent this operation if there is a current
block copy operation; in that case, use virDomainBlockJobAbort()
to stop the block copy first.

virDomainSnapshotFree should be used to free the resources after the
snapshot object is no longer needed.]]></info>
      <return type='virDomainSnapshotPtr' info='an (opaque) new virDomainSnapshotPtr on success or NULL on failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the domain snapshot'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainSnapshotCreateFlags'/>
    </function>
    <function name='virDomainSnapshotCurrent' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Get the current snapshot for a domain, if any.

virDomainSnapshotFree should be used to free the resources after the
snapshot object is no longer needed.]]></info>
      <return type='virDomainSnapshotPtr' info='a domain snapshot object or NULL in case of failure.  If the current domain snapshot cannot be found, then the VIR_ERR_NO_DOMAIN_SNAPSHOT error is raised.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainSnapshotDelete' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Delete the snapshot.

If @flags is 0, then just this snapshot is deleted, and changes
from this snapshot are automatically merged into children
snapshots.  If @flags includes VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN,
then this snapshot and any descendant snapshots are deleted.  If
@flags includes VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY, then any
descendant snapshots are deleted, but this snapshot remains.  These
two flags are mutually exclusive.

If @flags includes VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY, then
any snapshot metadata tracked by libvirt is removed while keeping
the snapshot contents intact; if a hypervisor does not require any
libvirt metadata to track snapshots, then this flag is silently
ignored.]]></info>
      <return type='int' info='0 if the selected snapshot(s) were successfully deleted, -1 on error.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSnapshotDeleteFlags'/>
    </function>
    <function name='virDomainSnapshotFree' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Free the domain snapshot object.  The snapshot itself is not modified.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
    </function>
    <function name='virDomainSnapshotGetConnect' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Provides the connection pointer associated with a snapshot.  The
reference counter on the connection is not increased by this
call.]]></info>
      <return type='virConnectPtr' info='the connection or NULL.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a snapshot object'/>
    </function>
    <function name='virDomainSnapshotGetDomain' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Provides the domain pointer associated with a snapshot.  The
reference counter on the domain is not increased by this
call.]]></info>
      <return type='virDomainPtr' info='the domain or NULL.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a snapshot object'/>
    </function>
    <function name='virDomainSnapshotGetName' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Get the public name for that snapshot]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated as its lifetime will be the same as the snapshot object.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a snapshot object'/>
    </function>
    <function name='virDomainSnapshotGetParent' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Get the parent snapshot for @snapshot, if any.

virDomainSnapshotFree should be used to free the resources after the
snapshot object is no longer needed.]]></info>
      <return type='virDomainSnapshotPtr' info='a domain snapshot object or NULL in case of failure.  If the given snapshot is a root (no parent), then the VIR_ERR_NO_DOMAIN_SNAPSHOT error is raised.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a snapshot object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainSnapshotGetXMLDesc' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Provide an XML description of the domain snapshot, with a top-level
element of <domainsnapshot>.

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_SNAPSHOT_XML_SECURE; this flag is rejected on read-only
connections.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSnapshotXMLFlags'/>
    </function>
    <function name='virDomainSnapshotHasMetadata' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Determine if the given snapshot is associated with libvirt metadata
that would prevent the deletion of the domain.]]></info>
      <return type='int' info='1 if the snapshot has metadata, 0 if the snapshot exists without help from libvirt, or -1 on error.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a snapshot object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainSnapshotIsCurrent' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Determine if the given snapshot is the domain's current snapshot.  See
also virDomainHasCurrentSnapshot().]]></info>
      <return type='int' info='1 if current, 0 if not current, or -1 on error.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a snapshot object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainSnapshotListAllChildren' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Collect the list of domain snapshots that are children of the given
snapshot, and allocate an array to store those objects.  This API solves
the race inherent in virDomainSnapshotListChildrenNames().

If @flags lacks VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS or contains
VIR_DOMAIN_SNAPSHOT_LIST_TOPOLOGICAL, @snaps is non-NULL, and no
other connection is modifying snapshots, then it is guaranteed that
for any snapshot in the resulting list, no snapshots later in the
list can be reached by a sequence of virDomainSnapshotGetParent()
starting from that earlier snapshot; otherwise, the order of
snapshots in the resulting list is unspecified.

By default, this command covers only direct children. It is also
possible to expand things to cover all descendants, when @flags
includes VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS. Additional filters
are provided via the remaining @flags values as documented in
virDomainListAllSnapshots(), with the exception that
VIR_DOMAIN_SNAPSHOT_LIST_ROOTS is not supported (in fact,
VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS has the same bit value but
opposite semantics of widening rather than narrowing the listing).]]></info>
      <return type='int' info='the number of domain snapshots found or -1 and sets @snaps to NULL in case of error.  On success, the array stored into @snaps is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virDomainSnapshotFree() on each array element, then calling free() on @snaps.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
      <arg name='snaps' type='virDomainSnapshotPtr **' info='pointer to variable to store the array containing snapshot objects or NULL if the list is not required (just returns number of snapshots)'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSnapshotListFlags'/>
    </function>
    <function name='virDomainSnapshotListChildrenNames' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Collect the list of domain snapshots that are children of the given
snapshot, and store their names in @names.  The value to use for
@nameslen can be determined by virDomainSnapshotNumChildren() with
the same @flags.

If @flags lacks VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS or contains
VIR_DOMAIN_SNAPSHOT_LIST_TOPOLOGICAL, and no other connection is
modifying snapshots, then it is guaranteed that for any snapshot in
the resulting list, no snapshots later in the list can be reached
by a sequence of virDomainSnapshotGetParent() starting from that
earlier snapshot; otherwise, the order of snapshots in the
resulting list is unspecified.

By default, this command covers only direct children. It is also
possible to expand things to cover all descendants, when @flags
includes VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS. Additional filters
are provided via the same @flags values as documented in
virDomainSnapshotListAllChildren().

Note that this command is inherently racy: another connection can
define a new snapshot between a call to virDomainSnapshotNumChildren()
and this call.  You are only guaranteed that all currently defined
snapshots were listed if the return is less than @nameslen.  Likewise,
you should be prepared for virDomainSnapshotLookupByName() to fail when
converting a name from this call into a snapshot object, if another
connection deletes the snapshot in the meantime.  For more control over
the results, see virDomainSnapshotListAllChildren().]]></info>
      <return type='int' info='the number of domain snapshots found or -1 in case of error. The caller is responsible to call free() for each member of the array.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
      <arg name='names' type='char **' info='array to collect the list of names of snapshots'/>
      <arg name='nameslen' type='int' info='size of @names'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSnapshotListFlags'/>
    </function>
    <function name='virDomainSnapshotListNames' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Collect the list of domain snapshots for the given domain, and store
their names in @names.  The value to use for @nameslen can be determined
by virDomainSnapshotNum() with the same @flags.

If @flags contains VIR_DOMAIN_SNAPSHOT_LIST_TOPOLOGICAL, and no
other connection is modifying snapshots, then it is guaranteed that
for any snapshot in the resulting list, no snapshots later in the
list can be reached by a sequence of virDomainSnapshotGetParent()
starting from that earlier snapshot; otherwise, the order of
snapshots in the resulting list is unspecified.

By default, this command covers all snapshots. It is also possible
to limit things to just snapshots with no parents, when @flags
includes VIR_DOMAIN_SNAPSHOT_LIST_ROOTS.  Additional filters are
provided via the same @flags values as documented in
virDomainListAllSnapshots().

Note that this command is inherently racy: another connection can
define a new snapshot between a call to virDomainSnapshotNum() and
this call.  You are only guaranteed that all currently defined
snapshots were listed if the return is less than @nameslen.  Likewise,
you should be prepared for virDomainSnapshotLookupByName() to fail when
converting a name from this call into a snapshot object, if another
connection deletes the snapshot in the meantime.  For more control over
the results, see virDomainListAllSnapshots().]]></info>
      <return type='int' info='the number of domain snapshots found or -1 in case of error. The caller is responsible to call free() for each member of the array.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='names' type='char **' info='array to collect the list of names of snapshots'/>
      <arg name='nameslen' type='int' info='size of @names'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSnapshotListFlags'/>
    </function>
    <function name='virDomainSnapshotLookupByName' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Try to lookup a domain snapshot based on its name.]]></info>
      <return type='virDomainSnapshotPtr' info='a domain snapshot object or NULL in case of failure.  If the domain snapshot cannot be found, then the VIR_ERR_NO_DOMAIN_SNAPSHOT error is raised.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='name' type='const char *' info='name for the domain snapshot'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virDomainSnapshotNum' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Provides the number of domain snapshots for this domain.

This function will accept VIR_DOMAIN_SNAPSHOT_LIST_TOPOLOGICAL in
@flags only if virDomainSnapshotListNames() can honor it, although
the flag has no other effect here.

By default, this command covers all snapshots. It is also possible
to limit things to just snapshots with no parents, when @flags
includes VIR_DOMAIN_SNAPSHOT_LIST_ROOTS.  Additional filters are
provided via the same @flags values as documented in
virDomainListAllSnapshots().]]></info>
      <return type='int' info='the number of domain snapshots found or -1 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSnapshotListFlags'/>
    </function>
    <function name='virDomainSnapshotNumChildren' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Provides the number of child snapshots for this domain snapshot.

This function will accept VIR_DOMAIN_SNAPSHOT_LIST_TOPOLOGICAL in
@flags only if virDomainSnapshotListChildrenNames() can honor it,
although the flag has no other effect here.

By default, this command covers only direct children. It is also
possible to expand things to cover all descendants, when @flags
includes VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS. Additional filters
are provided via the same @flags values as documented in
virDomainSnapshotListAllChildren().]]></info>
      <return type='int' info='the number of domain snapshots found or -1 in case of error.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainSnapshotListFlags'/>
    </function>
    <function name='virDomainSnapshotRef' file='libvirt-domain-snapshot' module='libvirt-domain-snapshot'>
      <info><![CDATA[Increment the reference count on the snapshot. For each
additional call to this method, there shall be a corresponding
call to virDomainSnapshotFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection and domain remain open until all threads have finished
using the snapshot. ie, each new thread using a snapshot would
increment the reference count.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='the snapshot to hold a reference on'/>
    </function>
    <function name='virDomainStatsRecordListFree' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Convenience function to free a list of domain stats returned by
virDomainListGetStats and virConnectGetAllDomainStats.]]></info>
      <return type='void'/>
      <arg name='stats' type='virDomainStatsRecordPtr *' info='NULL terminated array of virDomainStatsRecords to free'/>
    </function>
    <function name='virDomainSuspend' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Suspends an active domain, the process is frozen without further access
to CPU resources and I/O but the memory used by the domain at the
hypervisor level will stay allocated. Use virDomainResume() to reactivate
the domain.
This function may require privileged access.
Moreover, suspend may not be supported if domain is in some
special state like VIR_DOMAIN_PMSUSPENDED.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainUndefine' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Undefine a domain. If the domain is running, it's converted to
transient domain, without stopping it. If the domain is inactive,
the domain configuration is removed.

If the domain has a managed save image (see
virDomainHasManagedSaveImage()), or if it is inactive and has any
snapshot metadata (see virDomainSnapshotNum()) or checkpoint
metadata (see virDomainListAllCheckpoints()), then the undefine
will fail. See virDomainUndefineFlags() for more control.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <function name='virDomainUndefineFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Undefine a domain. If the domain is running, it's converted to
transient domain, without stopping it. If the domain is inactive,
the domain configuration is removed.

If the domain has a managed save image (see virDomainHasManagedSaveImage()),
then including VIR_DOMAIN_UNDEFINE_MANAGED_SAVE in @flags will also remove
that file, and omitting the flag will cause the undefine process to fail.

If the domain is inactive and has any snapshot metadata (see
virDomainSnapshotNum()), then including
VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA in @flags will also remove
that metadata.  Omitting the flag will cause the undefine of an
inactive domain with snapshots to fail.  Active domains will retain
snapshot metadata until the (now-transient) domain halts,
regardless of whether this flag is present.  On hypervisors that
support snapshots, but where snapshots do not use libvirt metadata,
this flag has no effect.

If the domain is inactive and has any checkpoint metadata (see
virDomainListAllCheckpoints()), then including
VIR_DOMAIN_UNDEFINE_CHECKPOINTS_METADATA in @flags will also remove
that metadata. Omitting the flag will cause the undefine of an
inactive domain with checkpoints to fail. Active domains will
retain checkpoint metadata until the (now-transient) domain halts,
regardless of whether this flag is present. On hypervisors that
support checkpoints, but where checkpoints do not use libvirt
metadata, this flag has no effect.

If the domain has any nvram specified, the undefine process will fail
unless VIR_DOMAIN_UNDEFINE_KEEP_NVRAM is specified, or if
VIR_DOMAIN_UNDEFINE_NVRAM is specified to remove the nvram file.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of supported virDomainUndefineFlagsValues'/>
    </function>
    <function name='virDomainUpdateDeviceFlags' file='libvirt-domain' module='libvirt-domain'>
      <info><![CDATA[Change a virtual device on a domain, using the flags parameter
to control how the device is changed.  VIR_DOMAIN_AFFECT_CURRENT
specifies that the device change is made based on current domain
state.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be
changed on the active domain instance only and is not added to the
persisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG
specifies that the device shall be changed on the persisted domain
configuration only.  Note that the target hypervisor must return an
error if unable to satisfy flags.  E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

This method is used for actions such changing CDROM/Floppy device
media, altering the graphics configuration such as password,
reconfiguring the NIC device backend connectivity, etc.

The supplied XML description of the device should contain all
the information that is found in the corresponding domain XML.
Leaving out any piece of information may be treated as a
request for its removal, which may be denied. For instance,
when users want to change CDROM media only for live XML, they
must provide live disk XML as found in the corresponding live
domain XML with only the disk path changed.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virDomainDeviceModifyFlags'/>
    </function>
    <functype name='virErrorFunc' file='virterror' module='virterror'>
      <info><![CDATA[Signature of a function to use when there is an error raised by the library.]]></info>
      <return type='void'/>
      <arg name='userData' type='void *' info='user provided data for the error callback'/>
      <arg name='error' type='virErrorPtr' info='the error being raised.'/>
    </functype>
    <function name='virEventAddHandle' file='libvirt-event' module='virevent'>
      <info><![CDATA[Register a callback for monitoring file handle events.  This function
requires that an event loop has previously been registered with
virEventRegisterImpl() or virEventRegisterDefaultImpl().

@fd must always always be a C runtime file descriptor. On Windows
if the caller only has a HANDLE, the _open_osfhandle() method can
be used to open an associated C runtime file descriptor for use
with this API. After opening a runtime file descriptor, CloseHandle()
must not be used, instead close() will close the runtime file
descriptor and its original associated HANDLE.]]></info>
      <return type='int' info='-1 if the file handle cannot be registered, otherwise a handle watch number to be used for updating and unregistering for events.'/>
      <arg name='fd' type='int' info='file handle to monitor for events'/>
      <arg name='events' type='int' info='bitset of events to watch from virEventHandleType constants'/>
      <arg name='cb' type='virEventHandleCallback' info='callback to invoke when an event occurs'/>
      <arg name='opaque' type='void *' info='user data to pass to callback'/>
      <arg name='ff' type='virFreeCallback' info='callback to free opaque when handle is removed'/>
    </function>
    <functype name='virEventAddHandleFunc' file='libvirt-event' module='libvirt-event'>
      <info><![CDATA[Part of the EventImpl, this callback adds a file handle callback to
listen for specific events. The same file handle can be registered
multiple times provided the requested event sets are non-overlapping

@fd will always be a C runtime file descriptor. On Windows
the _get_osfhandle() method can be used if a HANDLE is required
instead.

If the opaque user data requires free'ing when the handle
is unregistered, then a 2nd callback can be supplied for
this purpose. This callback needs to be invoked from a clean stack.
If 'ff' callbacks are invoked directly from the virEventRemoveHandleFunc
they will likely deadlock in libvirt.]]></info>
      <return type='int' info='-1 if the file handle cannot be registered, otherwise a handle watch number to be used for updating and unregistering for events'/>
      <arg name='fd' type='int' info='file descriptor to listen on'/>
      <arg name='event' type='int' info='bitset of events on which to fire the callback'/>
      <arg name='cb' type='virEventHandleCallback' info='the callback to be called when an event occurs'/>
      <arg name='opaque' type='void *' info='user data to pass to the callback'/>
      <arg name='ff' type='virFreeCallback' info='the callback invoked to free opaque data blob'/>
    </functype>
    <function name='virEventAddTimeout' file='libvirt-event' module='virevent'>
      <info><![CDATA[Register a callback for a timer event.  This function
requires that an event loop has previously been registered with
virEventRegisterImpl() or virEventRegisterDefaultImpl().

Setting @timeout to -1 will disable the timer. Setting @timeout
to zero will cause it to fire on every event loop iteration.]]></info>
      <return type='int' info='-1 if the timer cannot be registered, a positive integer timer id upon success.'/>
      <arg name='timeout' type='int' info='time between events in milliseconds'/>
      <arg name='cb' type='virEventTimeoutCallback' info='callback to invoke when an event occurs'/>
      <arg name='opaque' type='void *' info='user data to pass to callback'/>
      <arg name='ff' type='virFreeCallback' info='callback to free opaque when timeout is removed'/>
    </function>
    <functype name='virEventAddTimeoutFunc' file='libvirt-event' module='libvirt-event'>
      <info><![CDATA[Part of the EventImpl, this user-defined callback handles adding an
event timeout.

If the opaque user data requires free'ing when the handle
is unregistered, then a 2nd callback can be supplied for
this purpose.]]></info>
      <return type='int' info='a timer value'/>
      <arg name='timeout' type='int' info='The timeout to monitor'/>
      <arg name='cb' type='virEventTimeoutCallback' info='the callback to call when timeout has expired'/>
      <arg name='opaque' type='void *' info='user data to pass to the callback'/>
      <arg name='ff' type='virFreeCallback' info='the callback invoked to free opaque data blob'/>
    </functype>
    <functype name='virEventHandleCallback' file='libvirt-event' module='libvirt-event'>
      <info><![CDATA[Callback for receiving file handle events. The callback will
be invoked once for each event which is pending.]]></info>
      <return type='void'/>
      <arg name='watch' type='int' info='watch on which the event occurred'/>
      <arg name='fd' type='int' info='file handle on which the event occurred'/>
      <arg name='events' type='int' info='bitset of events from virEventHandleType constants'/>
      <arg name='opaque' type='void *' info='user data registered with handle'/>
    </functype>
    <function name='virEventRegisterDefaultImpl' file='libvirt-event' module='virevent'>
      <info><![CDATA[Registers a default event implementation based on the
poll() system call. This is a generic implementation
that can be used by any client application which does
not have a need to integrate with an external event
loop impl.

For proper event handling, it is important that the event implementation
is registered before a connection to the Hypervisor is opened.

Once registered, the application has to invoke virEventRunDefaultImpl() in
a loop to process events.  Failure to do so may result in connections being
closed unexpectedly as a result of keepalive timeout.  The default
event loop fully supports handle and timeout events, but only
wakes up on events registered by libvirt API calls such as
virEventAddHandle() or virConnectDomainEventRegisterAny().]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
    </function>
    <function name='virEventRegisterImpl' file='libvirt-event' module='virevent'>
      <info><![CDATA[Registers an event implementation, to allow integration
with an external event loop. Applications would use this
to integrate with the libglib2 event loop, or libevent
or the QT event loop.

For proper event handling, it is important that the event implementation
is registered before a connection to the Hypervisor is opened.

Use of the virEventAddHandle() and similar APIs require that the
corresponding handler is registered.  Use of the
virConnectDomainEventRegisterAny() and similar APIs requires that
the three timeout handlers are registered.  Likewise, the three
timeout handlers must be registered if the remote server has been
configured to send keepalive messages, or if the client intends
to call virConnectSetKeepAlive(), to avoid either side from
unexpectedly closing the connection due to inactivity.

If an application does not need to integrate with an
existing event loop implementation, then the
virEventRegisterDefaultImpl() method can be used to setup
the generic libvirt implementation.

Once registered, the event loop implementation cannot be
changed, and must be run continuously. Note that callbacks
may remain registered for a short time even after calling
virConnectClose on all open connections, so it is not safe
to stop running the event loop immediately after closing
the connection.]]></info>
      <return type='void'/>
      <arg name='addHandle' type='virEventAddHandleFunc' info='the callback to add fd handles'/>
      <arg name='updateHandle' type='virEventUpdateHandleFunc' info='the callback to update fd handles'/>
      <arg name='removeHandle' type='virEventRemoveHandleFunc' info='the callback to remove fd handles'/>
      <arg name='addTimeout' type='virEventAddTimeoutFunc' info='the callback to add a timeout'/>
      <arg name='updateTimeout' type='virEventUpdateTimeoutFunc' info='the callback to update a timeout'/>
      <arg name='removeTimeout' type='virEventRemoveTimeoutFunc' info='the callback to remove a timeout'/>
    </function>
    <function name='virEventRemoveHandle' file='libvirt-event' module='virevent'>
      <info><![CDATA[Unregister a callback from a file handle.  This function
requires that an event loop has previously been registered with
virEventRegisterImpl() or virEventRegisterDefaultImpl().]]></info>
      <return type='int' info='-1 if the file handle was not registered, 0 upon success.'/>
      <arg name='watch' type='int' info='watch whose file handle to remove'/>
    </function>
    <functype name='virEventRemoveHandleFunc' file='libvirt-event' module='libvirt-event'>
      <info><![CDATA[Part of the EventImpl, this user-provided callback is notified when
an fd is no longer being listened on.

If a virEventHandleFreeFunc was supplied when the handle was
registered, it will be invoked some time during, or after this
function call, when it is safe to release the user data.]]></info>
      <return type='int' info='-1 if the file handle was not registered, 0 upon success'/>
      <arg name='watch' type='int' info='file descriptor watch to stop listening on'/>
    </functype>
    <function name='virEventRemoveTimeout' file='libvirt-event' module='virevent'>
      <info><![CDATA[Unregister a callback for a timer.  This function
requires that an event loop has previously been registered with
virEventRegisterImpl() or virEventRegisterDefaultImpl().]]></info>
      <return type='int' info='-1 if the timer was not registered, 0 upon success.'/>
      <arg name='timer' type='int' info='the timer id to remove'/>
    </function>
    <functype name='virEventRemoveTimeoutFunc' file='libvirt-event' module='libvirt-event'>
      <info><![CDATA[Part of the EventImpl, this user-defined callback removes a timer

If a virEventTimeoutFreeFunc was supplied when the handle was
registered, it will be invoked some time during, or after this
function call, when it is safe to release the user data.]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='timer' type='int' info='the timer to remove'/>
    </functype>
    <function name='virEventRunDefaultImpl' file='libvirt-event' module='virevent'>
      <info><![CDATA[Run one iteration of the event loop. Applications
will generally want to have a thread which invokes
this method in an infinite loop.  Furthermore, it is wise
to set up a pipe-to-self handler (via virEventAddHandle())
or a timeout (via virEventAddTimeout()) before calling this
function, as it will block forever if there are no
registered events.

  static bool quit;

  while (!quit) {
    if (virEventRunDefaultImpl() < 0)
      ...print error...
  }]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
    </function>
    <functype name='virEventTimeoutCallback' file='libvirt-event' module='libvirt-event'>
      <info><![CDATA[callback for receiving timer events]]></info>
      <return type='void'/>
      <arg name='timer' type='int' info='timer id emitting the event'/>
      <arg name='opaque' type='void *' info='user data registered with handle'/>
    </functype>
    <function name='virEventUpdateHandle' file='libvirt-event' module='virevent'>
      <info><![CDATA[Change event set for a monitored file handle.  This function
requires that an event loop has previously been registered with
virEventRegisterImpl() or virEventRegisterDefaultImpl().

Will not fail if fd exists.]]></info>
      <return type='void'/>
      <arg name='watch' type='int' info='watch whose file handle to update'/>
      <arg name='events' type='int' info='bitset of events to watch from virEventHandleType constants'/>
    </function>
    <functype name='virEventUpdateHandleFunc' file='libvirt-event' module='libvirt-event'>
      <info><![CDATA[Part of the EventImpl, this user-provided callback is notified when
events to listen on change]]></info>
      <return type='void'/>
      <arg name='watch' type='int' info='file descriptor watch to modify'/>
      <arg name='event' type='int' info='new events to listen on'/>
    </functype>
    <function name='virEventUpdateTimeout' file='libvirt-event' module='virevent'>
      <info><![CDATA[Change frequency for a timer.  This function
requires that an event loop has previously been registered with
virEventRegisterImpl() or virEventRegisterDefaultImpl().

Setting frequency to -1 will disable the timer. Setting the frequency
to zero will cause it to fire on every event loop iteration.

Will not fail if timer exists.]]></info>
      <return type='void'/>
      <arg name='timer' type='int' info='timer id to change'/>
      <arg name='timeout' type='int' info='time between events in milliseconds'/>
    </function>
    <functype name='virEventUpdateTimeoutFunc' file='libvirt-event' module='libvirt-event'>
      <info><![CDATA[Part of the EventImpl, this user-defined callback updates an
event timeout.]]></info>
      <return type='void'/>
      <arg name='timer' type='int' info='the timer to modify'/>
      <arg name='timeout' type='int' info='the new timeout value'/>
    </functype>
    <functype name='virFreeCallback' file='libvirt-common' module='libvirt-common'>
      <info><![CDATA[Type for a callback cleanup function to be paired with a callback.  This
function will be called as a final chance to clean up the @opaque
registered with the primary callback, at the time when the primary
callback is deregistered.

It is forbidden to call any other libvirt APIs from an
implementation of this callback, since it can be invoked
from a context which is not re-entrant safe. Failure to
abide by this requirement may lead to application deadlocks
or crashes.]]></info>
      <return type='void'/>
      <arg name='opaque' type='void *' info='opaque user data provided at registration'/>
    </functype>
    <function name='virFreeError' file='virterror' module='virerror'>
      <info><![CDATA[Resets and frees the given error.]]></info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='error to free'/>
    </function>
    <function name='virGetLastError' file='virterror' module='virerror'>
      <info><![CDATA[Provide a pointer to the last error caught at the library level

The error object is kept in thread local storage, so separate
threads can safely access this concurrently.]]></info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occurred.'/>
    </function>
    <function name='virGetLastErrorCode' file='virterror' module='virerror'>
      <info><![CDATA[Get the most recent error code (enum virErrorNumber).]]></info>
      <return type='int' info='the most recent error code, or VIR_ERR_OK if none is set.'/>
    </function>
    <function name='virGetLastErrorDomain' file='virterror' module='virerror'>
      <info><![CDATA[Get the most recent error domain (enum virErrorDomain).]]></info>
      <return type='int' info='a numerical value of the most recent error&apos;s origin, or VIR_FROM_NONE if none is set.'/>
    </function>
    <function name='virGetLastErrorMessage' file='virterror' module='virerror'>
      <info><![CDATA[Get the most recent error message]]></info>
      <return type='const char *' info='the most recent error message string in this thread, or a generic message if none is set'/>
    </function>
    <function name='virGetVersion' file='libvirt-host' module='libvirt'>
      <info><![CDATA[Provides version information. @libVer is the version of the
library and will always be set unless an error occurs, in which case
an error code will be returned. @typeVer exists for historical
compatibility; if it is not NULL it will duplicate @libVer (it was
originally intended to return hypervisor information based on @type,
but due to the design of remote clients this is not reliable). To
get the version of the running hypervisor use the virConnectGetVersion()
function instead. To get the libvirt library version used by a
connection use the virConnectGetLibVersion() instead.

This function includes a call to virInitialize() when necessary.]]></info>
      <return type='int' info='-1 in case of failure, 0 otherwise, and values for @libVer and @typeVer have the format major * 1,000,000 + minor * 1,000 + release.'/>
      <arg name='libVer' type='unsigned long *' info='return value for the library version (OUT)'/>
      <arg name='type' type='const char *' info='ignored; pass NULL'/>
      <arg name='typeVer' type='unsigned long *' info='pass NULL; for historical purposes duplicates @libVer if non-NULL'/>
    </function>
    <function name='virInitialize' file='libvirt-host' module='libvirt'>
      <info><![CDATA[Initialize the library.

This method is invoked automatically by any of the virConnectOpen() API
calls, and by virGetVersion(). Since release 1.0.0, there is no need to
call this method even in a multithreaded application, since
initialization is performed in a thread safe manner; but applications
using an older version of the library should manually call this before
setting up competing threads that attempt virConnectOpen in parallel.

The only other time it would be necessary to call virInitialize is if the
application did not invoke virConnectOpen as its first API call, such
as when calling virEventRegisterImpl() before setting up connections,
or when using virSetErrorFunc() to alter error reporting of the first
connection attempt.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
    </function>
    <function name='virInterfaceChangeBegin' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[This function creates a restore point to which one can return
later by calling virInterfaceChangeRollback(). This function should
be called before any transaction with interface configuration.
Once it is known that a new configuration works, it can be committed via
virInterfaceChangeCommit(), which frees the restore point.

If virInterfaceChangeBegin() is called when a transaction is
already opened, this function will fail, and a
VIR_ERR_INVALID_OPERATION will be logged.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virInterfaceChangeCommit' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[This commits the changes made to interfaces and frees the restore point
created by virInterfaceChangeBegin().

If virInterfaceChangeCommit() is called when a transaction is not
opened, this function will fail, and a VIR_ERR_INVALID_OPERATION
will be logged.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virInterfaceChangeRollback' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[This cancels changes made to interfaces settings by restoring previous
state created by virInterfaceChangeBegin().

If virInterfaceChangeRollback() is called when a transaction is not
opened, this function will fail, and a VIR_ERR_INVALID_OPERATION
will be logged.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virInterfaceCreate' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Activate an interface (i.e. call "ifup").

If there was an open network config transaction at the time this
interface was defined (that is, if virInterfaceChangeBegin() had
been called), the interface will be brought back down (and then
undefined) if virInterfaceChangeRollback() is called.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='iface' type='virInterfacePtr' info='pointer to a defined interface'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virInterfaceDefineXML' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Define an inactive persistent physical host interface or modify an existing
persistent one from the XML description.

Normally this change in the interface configuration is immediately
permanent/persistent, but if virInterfaceChangeBegin() has been
previously called (i.e. if an interface config transaction is
open), the new interface definition will only become permanent if
virInterfaceChangeCommit() is called prior to the next reboot of
the system running libvirtd. Prior to that time, it can be
explicitly removed using virInterfaceChangeRollback(), or will be
automatically removed during the next reboot of the system running
libvirtd.

virInterfaceFree should be used to free the resources after the
interface object is no longer needed.]]></info>
      <return type='virInterfacePtr' info='NULL in case of error, a pointer to the interface otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the interface, preferably in UTF-8'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virInterfaceDestroy' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[deactivate an interface (ie call "ifdown")
This does not remove the interface from the config, and
does not free the associated virInterfacePtr object.

If there is an open network config transaction at the time this
interface is destroyed (that is, if virInterfaceChangeBegin() had
been called), and if the interface is later undefined and then
virInterfaceChangeRollback() is called, the restoral of the
interface definition will also bring the interface back up.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virInterfaceFree' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Free the interface object. The interface itself is unaltered.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
    </function>
    <function name='virInterfaceGetConnect' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Provides the connection pointer associated with an interface.  The
reference counter on the connection is not increased by this
call.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='iface' type='virInterfacePtr' info='pointer to an interface'/>
    </function>
    <function name='virInterfaceGetMACString' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Get the MAC for an interface as string. For more information about
MAC see RFC4122.]]></info>
      <return type='const char *' info='a pointer to the MAC address (in null-terminated ASCII format) or NULL, the string need not be deallocated its lifetime will be the same as the interface object.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
    </function>
    <function name='virInterfaceGetName' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Get the public name for that interface]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the interface object.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
    </function>
    <function name='virInterfaceGetXMLDesc' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[VIR_INTERFACE_XML_INACTIVE - return the static configuration,
                                  suitable for use redefining the
                                  interface via virInterfaceDefineXML()

Provide an XML description of the interface. If
VIR_INTERFACE_XML_INACTIVE is set, the description may be reused
later to redefine the interface with virInterfaceDefineXML(). If it
is not set, the ip address and netmask will be the current live
setting of the interface, not the settings from the config files.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of extraction flags. Current valid bits:'/>
    </function>
    <function name='virInterfaceIsActive' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Determine if the interface is currently running]]></info>
      <return type='int' info='1 if running, 0 if inactive, -1 on error'/>
      <arg name='iface' type='virInterfacePtr' info='pointer to the interface object'/>
    </function>
    <function name='virInterfaceLookupByMACString' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Try to lookup an interface on the given hypervisor based on its MAC.

virInterfaceFree should be used to free the resources after the
interface object is no longer needed.]]></info>
      <return type='virInterfacePtr' info='a new interface object or NULL in case of failure.  If the interface cannot be found, then VIR_ERR_NO_INTERFACE error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='macstr' type='const char *' info='the MAC for the interface (null-terminated ASCII format)'/>
    </function>
    <function name='virInterfaceLookupByName' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Try to lookup an interface on the given hypervisor based on its name.

virInterfaceFree should be used to free the resources after the
interface object is no longer needed.]]></info>
      <return type='virInterfacePtr' info='a new interface object or NULL in case of failure.  If the interface cannot be found, then VIR_ERR_NO_INTERFACE error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the interface'/>
    </function>
    <function name='virInterfaceRef' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Increment the reference count on the interface. For each
additional call to this method, there shall be a corresponding
call to virInterfaceFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using an interface would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='iface' type='virInterfacePtr' info='the interface to hold a reference on'/>
    </function>
    <function name='virInterfaceUndefine' file='libvirt-interface' module='libvirt-interface'>
      <info><![CDATA[Undefine an interface, ie remove it from the config.
This does not free the associated virInterfacePtr object.

Normally this change in the interface configuration is
permanent/persistent, but if virInterfaceChangeBegin() has been
previously called (i.e. if an interface config transaction is
open), the removal of the interface definition will only become
permanent if virInterfaceChangeCommit() is called prior to the next
reboot of the system running libvirtd. Prior to that time, the
definition can be explicitly restored using
virInterfaceChangeRollback(), or will be automatically restored
during the next reboot of the system running libvirtd.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='iface' type='virInterfacePtr' info='pointer to a defined interface'/>
    </function>
    <function name='virNWFilterBindingCreateXML' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Define a new network filter, based on an XML description
similar to the one returned by virNWFilterGetXMLDesc(). This
API may be used to associate a filter with a currently running
guest that does not have a filter defined for a specific network
port. Since the bindings are generally automatically managed by
the hypervisor, using this command to define a filter for a network
port and then starting the guest afterwards may prevent the guest
from starting if it attempts to use the network port and finds a
filter already defined.

virNWFilterFree should be used to free the resources after the
binding object is no longer needed.]]></info>
      <return type='virNWFilterBindingPtr' info='a new binding object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='an XML description of the binding'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virNWFilterBindingDelete' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Delete the binding object. This does not free the
associated virNWFilterBindingPtr object. This API
may be used to remove the network port binding filter
currently in use for the guest while the guest is
running without needing to restart the guest. Restoring
the network port binding filter for the running guest
would be accomplished by using virNWFilterBindingCreateXML.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='binding' type='virNWFilterBindingPtr' info='a binding object'/>
    </function>
    <function name='virNWFilterBindingFree' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Free the binding object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='binding' type='virNWFilterBindingPtr' info='a binding object'/>
    </function>
    <function name='virNWFilterBindingGetFilterName' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Get the filter name for the network filter binding]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the binding object.'/>
      <arg name='binding' type='virNWFilterBindingPtr' info='a binding object'/>
    </function>
    <function name='virNWFilterBindingGetPortDev' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Get the port dev name for the network filter binding]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the binding object.'/>
      <arg name='binding' type='virNWFilterBindingPtr' info='a binding object'/>
    </function>
    <function name='virNWFilterBindingGetXMLDesc' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Provide an XML description of the network filter. The description may be
reused later to redefine the network filter with virNWFilterCreateXML().]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='binding' type='virNWFilterBindingPtr' info='a binding object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNWFilterBindingLookupByPortDev' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Try to lookup a network filter binding on the given hypervisor based
on network port device name.

virNWFilterBindingFree should be used to free the resources after the
binding object is no longer needed.]]></info>
      <return type='virNWFilterBindingPtr' info='a new binding object or NULL in case of failure.  If the network filter cannot be found, then VIR_ERR_NO_NWFILTER_BINDING error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='portdev' type='const char *' info='name for the network port device'/>
    </function>
    <function name='virNWFilterBindingRef' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Increment the reference count on the binding. For each
additional call to this method, there shall be a corresponding
call to virNWFilterFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using an binding would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='binding' type='virNWFilterBindingPtr' info='the binding to hold a reference on'/>
    </function>
    <function name='virNWFilterDefineXML' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Define a new network filter, based on an XML description
similar to the one returned by virNWFilterGetXMLDesc()

virNWFilterFree should be used to free the resources after the
nwfilter object is no longer needed.]]></info>
      <return type='virNWFilterPtr' info='a new nwfilter object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='an XML description of the nwfilter'/>
    </function>
    <function name='virNWFilterFree' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Free the nwfilter object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
    </function>
    <function name='virNWFilterGetName' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Get the public name for the network filter]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the nwfilter object.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
    </function>
    <function name='virNWFilterGetUUID' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Get the UUID for a network filter]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virNWFilterGetUUIDString' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Get the UUID for a network filter as string. For more information about
UUID see RFC4122.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virNWFilterGetXMLDesc' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Provide an XML description of the network filter. The description may be
reused later to redefine the network filter with virNWFilterCreateXML().]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNWFilterLookupByName' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Try to lookup a network filter on the given hypervisor based on its name.

virNWFilterFree should be used to free the resources after the
nwfilter object is no longer needed.]]></info>
      <return type='virNWFilterPtr' info='a new nwfilter object or NULL in case of failure.  If the network filter cannot be found, then VIR_ERR_NO_NWFILTER error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the network filter'/>
    </function>
    <function name='virNWFilterLookupByUUID' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Try to lookup a network filter on the given hypervisor based on its UUID.

virNWFilterFree should be used to free the resources after the
nwfilter object is no longer needed.]]></info>
      <return type='virNWFilterPtr' info='a new nwfilter object or NULL in case of failure.  If the nwfdilter cannot be found, then VIR_ERR_NO_NWFILTER error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the network filter'/>
    </function>
    <function name='virNWFilterLookupByUUIDString' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Try to lookup an nwfilter on the given hypervisor based on its UUID.

virNWFilterFree should be used to free the resources after the
nwfilter object is no longer needed.]]></info>
      <return type='virNWFilterPtr' info='a new nwfilter object or NULL in case of failure.  If the nwfilter cannot be found, then VIR_ERR_NO_NWFILTER error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the nwfilter'/>
    </function>
    <function name='virNWFilterRef' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Increment the reference count on the nwfilter. For each
additional call to this method, there shall be a corresponding
call to virNWFilterFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using an nwfilter would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='the nwfilter to hold a reference on'/>
    </function>
    <function name='virNWFilterUndefine' file='libvirt-nwfilter' module='libvirt-nwfilter'>
      <info><![CDATA[Undefine the nwfilter object. This call will not succeed if
a running VM is referencing the filter. This does not free the
associated virNWFilterPtr object.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
    </function>
    <function name='virNetworkCreate' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Create and start a defined network. If the call succeed the network
moves from the defined to the running networks pools.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a defined network'/>
    </function>
    <function name='virNetworkCreateXML' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Create and start a new virtual network, based on an XML description
similar to the one returned by virNetworkGetXMLDesc()

virNetworkFree should be used to free the resources after the
network object is no longer needed.]]></info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='an XML description of the network'/>
    </function>
    <function name='virNetworkDHCPLeaseFree' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Frees all the memory occupied by @lease.]]></info>
      <return type='void'/>
      <arg name='lease' type='virNetworkDHCPLeasePtr' info='pointer to a leases object'/>
    </function>
    <function name='virNetworkDefineXML' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Define an inactive persistent virtual network or modify an existing
persistent one from the XML description.

virNetworkFree should be used to free the resources after the
network object is no longer needed.]]></info>
      <return type='virNetworkPtr' info='NULL in case of error, a pointer to the network otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the network, preferably in UTF-8'/>
    </function>
    <function name='virNetworkDestroy' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Destroy the network object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor. This
does not free the associated virNetworkPtr object.
This function may require privileged access]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkFree' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Free the network object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetAutostart' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Provides a boolean value indicating whether the network
configured to be automatically started when the host
machine boots.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='autostart' type='int *' info='the value returned'/>
    </function>
    <function name='virNetworkGetBridgeName' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Provides a bridge interface name to which a domain may connect
a network interface in order to join the network.]]></info>
      <return type='char *' info='a 0 terminated interface name, or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetConnect' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Provides the connection pointer associated with a network.  The
reference counter on the connection is not increased by this
call.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='net' type='virNetworkPtr' info='pointer to a network'/>
    </function>
    <function name='virNetworkGetDHCPLeases' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[For DHCPv4, the information returned:
- Network Interface Name
- Expiry Time
- MAC address
- IAID (NULL)
- IPv4 address (with type and prefix)
- Hostname (can be NULL)
- Client ID (can be NULL)

For DHCPv6, the information returned:
- Network Interface Name
- Expiry Time
- MAC address
- IAID (can be NULL, only in rare cases)
- IPv6 address (with type and prefix)
- Hostname (can be NULL)
- Client DUID

Note: @mac, @iaid, @ipaddr, @clientid are in ASCII form, not raw bytes.
Note: @expirytime can 0, in case the lease is for infinite time.

The API fetches leases info of guests in the specified network. If the
optional parameter @mac is specified, the returned list will contain only
lease info about a specific guest interface with @mac. There can be
multiple leases for a single @mac because this API supports DHCPv6 too.

On success, the array stored into @leases is guaranteed to
have an extra allocated element set to NULL but not included in the return
count, to make iteration easier. The caller is responsible for calling
virNetworkDHCPLeaseFree() on each array element, then calling free() on @leases.

See also virNetworkGetDHCPLeasesForMAC() as a convenience for filtering
the list to a single MAC address.

Example of usage:

  virNetworkDHCPLeasePtr *leases = NULL;
  virNetworkPtr network = ... obtain a network pointer here ...;
  size_t i;
  int nleases;
  unsigned int flags = 0;

  nleases = virNetworkGetDHCPLeases(network, NULL, &leases, flags);
  if (nleases < 0)
      error();

  ... do something with returned values, for example:

  for (i = 0; i < nleases; i++) {
      virNetworkDHCPLeasePtr lease = leases[i];

      printf("Time(epoch): %lu, MAC address: %s, "
             "IP address: %s, Hostname: %s, ClientID: %s\n",
             lease->expirytime, lease->mac, lease->ipaddr,
             lease->hostname, lease->clientid);

             virNetworkDHCPLeaseFree(leases[i]);
  }

  free(leases);]]></info>
      <return type='int' info='the number of leases found or -1 and sets @leases to NULL in case of error.'/>
      <arg name='network' type='virNetworkPtr' info='Pointer to network object'/>
      <arg name='mac' type='const char *' info='Optional ASCII formatted MAC address of an interface'/>
      <arg name='leases' type='virNetworkDHCPLeasePtr **' info='Pointer to a variable to store the array containing details on obtained leases, or NULL if the list is not required (just returns number of leases).'/>
      <arg name='flags' type='unsigned int' info='Extra flags, not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNetworkGetName' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Get the public name for that network]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the network object.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetUUID' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Get the UUID for a network]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkGetUUIDString' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Get the UUID for a network as string. For more information about
UUID see RFC4122.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkGetXMLDesc' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Provide an XML description of the network. The description may be reused
later to relaunch the network with virNetworkCreateXML().

Normally, if a network included a physical function, the output includes
all virtual functions tied to that physical interface.  If @flags includes
VIR_NETWORK_XML_INACTIVE, then the expansion of virtual interfaces is
not performed.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virNetworkXMLFlags'/>
    </function>
    <function name='virNetworkIsActive' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Determine if the network is currently running]]></info>
      <return type='int' info='1 if running, 0 if inactive, -1 on error'/>
      <arg name='net' type='virNetworkPtr' info='pointer to the network object'/>
    </function>
    <function name='virNetworkIsPersistent' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Determine if the network has a persistent configuration
which means it will still exist after shutting down]]></info>
      <return type='int' info='1 if persistent, 0 if transient, -1 on error'/>
      <arg name='net' type='virNetworkPtr' info='pointer to the network object'/>
    </function>
    <function name='virNetworkListAllPorts' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Collect the list of network ports, and allocate an array to store those
objects.]]></info>
      <return type='int' info='the number of network ports found or -1 and sets @ports to NULL in case of error.  On success, the array stored into @ports is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virNetworkPortFree() on each array element, then calling free() on @ports.'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a network object'/>
      <arg name='ports' type='virNetworkPortPtr **' info='Pointer to a variable to store the array containing network port objects or NULL if the list is not required (just returns number of ports).'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNetworkLookupByName' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Try to lookup a network on the given hypervisor based on its name.

virNetworkFree should be used to free the resources after the
network object is no longer needed.]]></info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the network'/>
    </function>
    <function name='virNetworkLookupByUUID' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Try to lookup a network on the given hypervisor based on its UUID.

virNetworkFree should be used to free the resources after the
network object is no longer needed.]]></info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the network'/>
    </function>
    <function name='virNetworkLookupByUUIDString' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Try to lookup a network on the given hypervisor based on its UUID.]]></info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the network'/>
    </function>
    <function name='virNetworkPortCreateXML' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Create a new network port, based on an XML description
similar to the one returned by virNetworkPortGetXMLDesc()

virNetworkPortFree should be used to free the resources after the
network port object is no longer needed.]]></info>
      <return type='virNetworkPortPtr' info='a new network port object or NULL in case of failure'/>
      <arg name='net' type='virNetworkPtr' info='pointer to the network object'/>
      <arg name='xmldesc' type='const char *' info='an XML description of the port'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virNetworkPortDelete' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Delete the network port. This does not free the
associated virNetworkPortPtr object. It is the
caller's responsibility to ensure the port is not
still in use by a virtual machine before deleting
port.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='port' type='virNetworkPortPtr' info='a port object'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virNetworkPortFree' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Free the network port object.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='port' type='virNetworkPortPtr' info='a network port object'/>
    </function>
    <function name='virNetworkPortGetNetwork' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Provides the network pointer associated with a port.  The
reference counter on the connection is not increased by this
call.]]></info>
      <return type='virNetworkPtr' info='the virNetworkPtr or NULL in case of failure.'/>
      <arg name='port' type='virNetworkPortPtr' info='pointer to a network port'/>
    </function>
    <function name='virNetworkPortGetParameters' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Get all interface parameters. On input, @params should be initialized
to NULL. On return @params will be allocated with the size large
enough to hold all parameters, and @nparams will be updated to say
how many parameters are present. @params should be freed by the caller
on success.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='port' type='virNetworkPortPtr' info='a network port object'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer to pointer of interface parameter objects'/>
      <arg name='nparams' type='int *' info='pointer to received number of interface parameter'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virNetworkPortGetUUID' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Get the UUID for a network port]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='port' type='virNetworkPortPtr' info='a network port object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkPortGetUUIDString' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Get the UUID for a network as string. For more information about
UUID see RFC4122.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='port' type='virNetworkPortPtr' info='a network port object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkPortGetXMLDesc' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Provide an XML description of the network port. The description may be reused
later to recreate the port with virNetworkPortCreateXML().]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='port' type='virNetworkPortPtr' info='a network port object'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virNetworkPortLookupByUUID' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Try to lookup a port on the given network based on its UUID.

virNetworkPortFree should be used to free the resources after the
network port object is no longer needed.]]></info>
      <return type='virNetworkPortPtr' info='a new network port object or NULL in case of failure.  If the network port cannot be found, then VIR_ERR_NO_NETWORK_PORT error is raised.'/>
      <arg name='net' type='virNetworkPtr' info='pointer to the network object'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the network port'/>
    </function>
    <function name='virNetworkPortLookupByUUIDString' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Try to lookup a port on the given network based on its UUID.]]></info>
      <return type='virNetworkPortPtr' info='a new network port object or NULL in case of failure.  If the network port cannot be found, then VIR_ERR_NO_NETWORK_PORT error is raised.'/>
      <arg name='net' type='virNetworkPtr' info='pointer to the network object'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the port'/>
    </function>
    <function name='virNetworkPortRef' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Increment the reference count on the network port. For each
additional call to this method, there shall be a corresponding
call to virNetworkPortFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a network port, and it is required that the
port remain resident until all threads have finished using
it. ie, each new thread using a network port would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='port' type='virNetworkPortPtr' info='a network port object'/>
    </function>
    <function name='virNetworkPortSetParameters' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Change a subset or all parameters of the network port; currently this
includes bandwidth parameters.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='port' type='virNetworkPortPtr' info='a network port object'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to interface parameter objects'/>
      <arg name='nparams' type='int' info='number of interface parameter (this value can be the same or less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virNetworkRef' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Increment the reference count on the network. For each
additional call to this method, there shall be a corresponding
call to virNetworkFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a network would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='the network to hold a reference on'/>
    </function>
    <function name='virNetworkSetAutostart' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Configure the network to be automatically started
when the host machine boots.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='autostart' type='int' info='whether the network should be automatically started 0 or 1'/>
    </function>
    <function name='virNetworkUndefine' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Undefine a network but does not stop it if it is running]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a defined network'/>
    </function>
    <function name='virNetworkUpdate' file='libvirt-network' module='libvirt-network'>
      <info><![CDATA[Update the definition of an existing network, either its live
running state, its persistent configuration, or both.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error virNetworkUpdateCommand virNetworkUpdateSection'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a defined network'/>
      <arg name='command' type='unsigned int' info='what action to perform (add/delete/modify) (see virNetworkUpdateCommand for descriptions)'/>
      <arg name='section' type='unsigned int' info='which section of the network to update (see virNetworkUpdateSection for descriptions)'/>
      <arg name='parentIndex' type='int' info='which parent element, if there are multiple parents of the same type (e.g. which &lt;ip&gt; element when modifying a &lt;dhcp&gt;/&lt;host&gt; element), or &quot;-1&quot; for &quot;don&apos;t care&quot; or &quot;automatically find appropriate one&quot;.'/>
      <arg name='xml' type='const char *' info='the XML description for the network, preferably in UTF-8'/>
      <arg name='flags' type='unsigned int' info='bitwise OR of virNetworkUpdateFlags.'/>
    </function>
    <function name='virNodeAllocPages' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Sometimes, when trying to start a new domain, it may be
necessary to reserve some huge pages in the system pool which
can be then allocated by the domain. This API serves that
purpose. On its input, @pageSizes and @pageCounts are arrays
of the same cardinality of @npages. The @pageSizes contains
page sizes which are to be allocated in the system (the size
unit is kibibytes), and @pageCounts then contains the number
of pages to reserve.  If @flags is 0
(VIR_NODE_ALLOC_PAGES_ADD), each pool corresponding to
@pageSizes grows by the number of pages specified in the
corresponding @pageCounts.  If @flags contains
VIR_NODE_ALLOC_PAGES_SET, each pool mentioned is resized to
the given number of pages.  The pages pool can be allocated
over several NUMA nodes at once, just point at @startCell and
tell how many subsequent NUMA nodes should be taken in. As a
special case, if @startCell is equal to negative one, then
kernel is instructed to allocate the pages over all NUMA nodes
proportionally.]]></info>
      <return type='int' info='the number of nodes successfully adjusted or -1 in case of an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='npages' type='unsigned int' info='number of items in the @pageSizes and @pageCounts arrays'/>
      <arg name='pageSizes' type='unsigned int *' info='which huge page sizes to allocate'/>
      <arg name='pageCounts' type='unsigned long long *' info='how many pages should be allocated'/>
      <arg name='startCell' type='int' info='index of first cell to allocate pages on'/>
      <arg name='cellCount' type='unsigned int' info='number of consecutive cells to allocate pages on'/>
      <arg name='flags' type='unsigned int' info='extra flags; binary-OR of virNodeAllocPagesFlags'/>
    </function>
    <function name='virNodeDeviceCreateXML' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Create a new device on the VM host machine, for example, virtual
HBAs created using vport_create.

virNodeDeviceFree should be used to free the resources after the
node device object is no longer needed.]]></info>
      <return type='virNodeDevicePtr' info='a node device object if successful, NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the device to be created'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeDeviceDestroy' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Destroy the device object. The virtual device (only works for vHBA
currently) is removed from the host operating system.  This function
may require privileged access.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='a device object'/>
    </function>
    <function name='virNodeDeviceDetachFlags' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Detach the node device from the node itself so that it may be
assigned to a guest domain.

Depending on the hypervisor, this may involve operations such as
unbinding any device drivers from the device, binding the device to
a dummy device driver and resetting the device. Different backend
drivers expect the device to be bound to different dummy
devices. For example, QEMU's "kvm" backend driver (the default)
expects the device to be bound to "pci-stub", but its "vfio"
backend driver expects the device to be bound to "vfio-pci".

If the device is currently in use by the node, this method may
fail.

Once the device is not assigned to any guest, it may be re-attached
to the node using the virNodeDeviceReAttach() method.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
      <arg name='driverName' type='const char *' info='name of backend driver that will be used for later device assignment to a domain. NULL means &quot;use the hypervisor default driver&quot;'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeDeviceDettach' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Detach the node device from the node itself so that it may be
assigned to a guest domain.

Depending on the hypervisor, this may involve operations such
as unbinding any device drivers from the device, binding the
device to a dummy device driver and resetting the device.

If the device is currently in use by the node, this method may
fail.

Once the device is not assigned to any guest, it may be re-attached
to the node using the virNodeDeviceReattach() method.

If the caller needs control over which backend driver will be used
during PCI device assignment (to use something other than the
default, for example VFIO), the newer virNodeDeviceDetachFlags()
API should be used instead.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
    </function>
    <function name='virNodeDeviceFree' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Drops a reference to the node device, freeing it if
this was the last reference.]]></info>
      <return type='int' info='the 0 for success, -1 for error.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
    </function>
    <function name='virNodeDeviceGetName' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Just return the device name]]></info>
      <return type='const char *' info='the device name or NULL in case of error'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
    </function>
    <function name='virNodeDeviceGetParent' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Accessor for the parent of the device]]></info>
      <return type='const char *' info='the name of the device&apos;s parent, or NULL if an error occurred or when the device has no parent.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
    </function>
    <function name='virNodeDeviceGetXMLDesc' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Fetch an XML document describing all aspects of
the device.]]></info>
      <return type='char *' info='the XML document, or NULL on error'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeDeviceListCaps' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Lists the names of the capabilities supported by the device.]]></info>
      <return type='int' info='the number of capability names listed in @names or -1 in case of error.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
      <arg name='names' type='char ** const' info='array to collect the list of capability names'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virNodeDeviceLookupByName' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Lookup a node device by its name.

virNodeDeviceFree should be used to free the resources after the
node device object is no longer needed.]]></info>
      <return type='virNodeDevicePtr' info='a virNodeDevicePtr if found, NULL otherwise.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='unique device name'/>
    </function>
    <function name='virNodeDeviceLookupSCSIHostByWWN' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Lookup SCSI Host which is capable with 'fc_host' by its WWNN and WWPN.

virNodeDeviceFree should be used to free the resources after the
node device object is no longer needed.]]></info>
      <return type='virNodeDevicePtr' info='a virNodeDevicePtr if found, NULL otherwise.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='wwnn' type='const char *' info='WWNN of the SCSI Host.'/>
      <arg name='wwpn' type='const char *' info='WWPN of the SCSI Host.'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeDeviceNumOfCaps' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Accessor for the number of capabilities supported by the device.]]></info>
      <return type='int' info='the number of capabilities supported by the device or -1 in case of error.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
    </function>
    <function name='virNodeDeviceReAttach' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Re-attach a previously detached node device to the node so that it
may be used by the node again.

Depending on the hypervisor, this may involve operations such
as resetting the device, unbinding it from a dummy device driver
and binding it to its appropriate driver.

If the device is currently in use by a guest, this method may fail.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
    </function>
    <function name='virNodeDeviceRef' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Increment the reference count on the dev. For each
additional call to this method, there shall be a corresponding
call to virNodeDeviceFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a dev would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the dev to hold a reference on'/>
    </function>
    <function name='virNodeDeviceReset' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Reset a previously detached node device to the node before or
after assigning it to a guest.

The exact reset semantics depends on the hypervisor and device
type but, for example, KVM will attempt to reset PCI devices with
a Function Level Reset, Secondary Bus Reset or a Power Management
D-State reset.

If the reset will affect other devices which are currently in use,
this function may fail.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
    </function>
    <function name='virNodeGetCPUMap' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Get CPU map of host node CPUs.]]></info>
      <return type='int' info='number of CPUs present on the host node, or -1 if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='cpumap' type='unsigned char **' info='optional pointer to a bit map of real CPUs on the host node (in 8-bit bytes) (OUT) In case of success each bit set to 1 means that corresponding CPU is online. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit. The bit map is allocated by virNodeGetCPUMap and needs to be released using free() by the caller.'/>
      <arg name='online' type='unsigned int *' info='optional number of online CPUs in cpumap (OUT) Contains the number of online CPUs if the call was successful.'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeGetCPUStats' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[This function provides individual cpu statistics of the node.
If you want to get total cpu statistics of the node, you must specify
VIR_NODE_CPU_STATS_ALL_CPUS to @cpuNum.
The @params array will be filled with the values equal to the number of
parameters suggested by @nparams

As the value of @nparams is dynamic, call the API setting @nparams to 0 and
@params as NULL, the API returns the number of parameters supported by the
HV by updating @nparams on SUCCESS. The caller should then allocate @params
array, i.e. (sizeof(@virNodeCPUStats) * @nparams) bytes and call
the API again.

Here is a sample code snippet:

  if (virNodeGetCPUStats(conn, cpuNum, NULL, &nparams, 0) == 0 &&
      nparams != 0) {
      if ((params = malloc(sizeof(virNodeCPUStats) * nparams)) == NULL)
          goto error;
      memset(params, 0, sizeof(virNodeCPUStats) * nparams);
      if (virNodeGetCPUStats(conn, cpuNum, params, &nparams, 0))
          goto error;
  }

This function doesn't require privileged access to the hypervisor.
This function expects the caller to allocate the @params.

CPU time Statistics:

VIR_NODE_CPU_STATS_KERNEL:
    The cumulative CPU time which spends by kernel,
    when the node booting up.(nanoseconds)
VIR_NODE_CPU_STATS_USER:
    The cumulative CPU time which spends by user processes,
    when the node booting up.(nanoseconds)
VIR_NODE_CPU_STATS_IDLE:
    The cumulative idle CPU time, when the node booting up.(nanoseconds)
VIR_NODE_CPU_STATS_IOWAIT:
    The cumulative I/O wait CPU time, when the node booting up.(nanoseconds)
VIR_NODE_CPU_STATS_UTILIZATION:
    The CPU utilization. The usage value is in percent and 100%
    represents all CPUs on the server.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection.'/>
      <arg name='cpuNum' type='int' info='number of node cpu. (VIR_NODE_CPU_STATS_ALL_CPUS means total cpu statistics)'/>
      <arg name='params' type='virNodeCPUStatsPtr' info='pointer to node cpu time parameter objects'/>
      <arg name='nparams' type='int *' info='number of node cpu time parameter (this value should be same or less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeGetCellsFreeMemory' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[This call returns the amount of free memory in one or more NUMA cells.
The @freeMems array must be allocated by the caller and will be filled
with the amount of free memory in bytes for each cell requested,
starting with startCell (in freeMems[0]), up to either
(startCell + maxCells), or the number of additional cells in the node,
whichever is smaller.]]></info>
      <return type='int' info='the number of entries filled in freeMems, or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='freeMems' type='unsigned long long *' info='pointer to the array of unsigned long long'/>
      <arg name='startCell' type='int' info='index of first cell to return freeMems info on.'/>
      <arg name='maxCells' type='int' info='Maximum number of cells for which freeMems information can be returned.'/>
    </function>
    <function name='virNodeGetFreeMemory' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[provides the free memory available on the Node
Note: most libvirt APIs provide memory sizes in kibibytes, but in this
function the returned value is in bytes. Divide by 1024 as necessary.]]></info>
      <return type='unsigned long long' info='the available free memory in bytes or 0 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virNodeGetFreePages' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[This calls queries the host system on free pages of
specified size. For the input, @pages is expected to be
filled with pages that caller is interested in (the size
unit is kibibytes, so e.g. pass 2048 for 2MB), then @startcell
refers to the first NUMA node that info should be collected
from, and @cellcount tells how many consecutive nodes should
be queried. On the function output, @counts is filled with
desired information, where items are grouped by NUMA node.
So from @counts[0] till @counts[@npages - 1] you'll find count
for the first node (@startcell), then from @counts[@npages]
till @count[2 * @npages - 1] you'll find info for the
(@startcell + 1) node, and so on. It's callers responsibility
to allocate the @counts array.

Example how to use this API:

  unsigned int pages[] = { 4, 2048, 1048576}
  unsigned int npages = G_N_ELEMENTS(pages);
  int startcell = 0;
  unsigned int cellcount = 2;

  unsigned long long counts = malloc(sizeof(long long) * npages * cellcount);

  virNodeGetFreePages(conn, pages, npages,
                      startcell, cellcount, counts, 0);

  for (i = 0 ; i < cellcount ; i++) {
      fprintf(stdout, "Cell %d\n", startcell + i);
      for (j = 0 ; j < npages ; j++) {
         fprintf(stdout, "  Page size=%d count=%d bytes=%llu\n",
                 pages[j], counts[(i * npages) +  j],
                 pages[j] * counts[(i * npages) +  j]);
      }
  }

  This little code snippet will produce something like this:
Cell 0
   Page size=4096 count=300 bytes=1228800
   Page size=2097152 count=0 bytes=0
   Page size=1073741824 count=1 bytes=1073741824
Cell 1
   Page size=4096 count=0 bytes=0
   Page size=2097152 count=20 bytes=41943040
   Page size=1073741824 count=0 bytes=0]]></info>
      <return type='int' info='the number of entries filled in @counts or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='npages' type='unsigned int' info='number of items in the @pages array'/>
      <arg name='pages' type='unsigned int *' info='page sizes to query'/>
      <arg name='startCell' type='int' info='index of first cell to return free pages info on.'/>
      <arg name='cellCount' type='unsigned int' info='maximum number of cells for which free pages information can be returned.'/>
      <arg name='counts' type='unsigned long long *' info='returned counts of free pages'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeGetInfo' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Extract hardware information about the node.

Use of this API is strongly discouraged as the information provided
is not guaranteed to be accurate on all hardware platforms.

The mHZ value merely reflects the speed that the first CPU in the
machine is currently running at. This speed may vary across CPUs
and changes continually as the host OS throttles.

The nodes/sockets/cores/threads data is potentially inaccurate as
it assumes a symmetric installation. If one NUMA node has more
sockets populated that another NUMA node this information will be
wrong. It is also not able to report about CPU dies.

Applications are recommended to use the virConnectGetCapabilities()
call instead, which provides all the information except CPU mHZ,
in a more accurate representation.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='info' type='virNodeInfoPtr' info='pointer to a virNodeInfo structure allocated by the user'/>
    </function>
    <function name='virNodeGetMemoryParameters' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Get all node memory parameters (parameters unsupported by OS will be
omitted).  On input, @nparams gives the size of the @params array;
on output, @nparams gives how many slots were filled with parameter
information, which might be less but will not exceed the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.  See virDomainGetMemoryParameters() for an equivalent usage
example.]]></info>
      <return type='int' info='0 in case of success, and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to memory parameter object (return value, allocated by the caller)'/>
      <arg name='nparams' type='int *' info='pointer to number of memory parameters; input and output'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeGetMemoryStats' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[This function provides memory stats of the node.
If you want to get total memory statistics of the node, you must specify
VIR_NODE_MEMORY_STATS_ALL_CELLS to @cellNum.
The @params array will be filled with the values equal to the number of
stats suggested by @nparams

As the value of @nparams is dynamic, call the API setting @nparams to 0 and
@params as NULL, the API returns the number of parameters supported by the
HV by updating @nparams on SUCCESS. The caller should then allocate @params
array, i.e. (sizeof(@virNodeMemoryStats) * @nparams) bytes and call
the API again.

Here is the sample code snippet:

  if (virNodeGetMemoryStats(conn, cellNum, NULL, &nparams, 0) == 0 &&
      nparams != 0) {
      if ((params = malloc(sizeof(virNodeMemoryStats) * nparams)) == NULL)
          goto error;
      memset(params, cellNum, 0, sizeof(virNodeMemoryStats) * nparams);
      if (virNodeGetMemoryStats(conn, params, &nparams, 0))
          goto error;
  }

This function doesn't require privileged access to the hypervisor.
This function expects the caller to allocate the @params.

Memory Stats:

VIR_NODE_MEMORY_STATS_TOTAL:
    The total memory usage.(KB)
VIR_NODE_MEMORY_STATS_FREE:
    The free memory usage.(KB)
    On linux, this usage includes buffers and cached.
VIR_NODE_MEMORY_STATS_BUFFERS:
    The buffers memory usage.(KB)
VIR_NODE_MEMORY_STATS_CACHED:
    The cached memory usage.(KB)]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection.'/>
      <arg name='cellNum' type='int' info='number of node cell. (VIR_NODE_MEMORY_STATS_ALL_CELLS means total cell statistics)'/>
      <arg name='params' type='virNodeMemoryStatsPtr' info='pointer to node memory stats objects'/>
      <arg name='nparams' type='int *' info='number of node memory stats (this value should be same or less than the number of stats supported)'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeGetSEVInfo' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[If hypervisor supports AMD's SEV feature, then @params will contain various
platform specific information like PDH and certificate chain. Caller is
responsible for freeing @params.]]></info>
      <return type='int' info='0 in case of success, and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='params' type='virTypedParameterPtr *' info='where to store  SEV information'/>
      <arg name='nparams' type='int *' info='pointer to number of SEV parameters returned in @params'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeGetSecurityModel' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Extract the security model of a hypervisor. The 'model' field
in the @secmodel argument may be initialized to the empty
string if the driver has not activated a security model.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='a connection object'/>
      <arg name='secmodel' type='virSecurityModelPtr' info='pointer to a virSecurityModel structure'/>
    </function>
    <function name='virNodeListDevices' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Collect the list of node devices, and store their names in @names

For more control over the results, see virConnectListAllNodeDevices().

If the optional 'cap'  argument is non-NULL, then the count
will be restricted to devices with the specified capability]]></info>
      <return type='int' info='the number of node devices found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='cap' type='const char *' info='capability name'/>
      <arg name='names' type='char ** const' info='array to collect the list of node device names'/>
      <arg name='maxnames' type='int' info='size of @names'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeNumOfDevices' file='libvirt-nodedev' module='libvirt-nodedev'>
      <info><![CDATA[Provides the number of node devices.

If the optional 'cap'  argument is non-NULL, then the count
will be restricted to devices with the specified capability]]></info>
      <return type='int' info='the number of node devices or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='cap' type='const char *' info='capability name'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeSetMemoryParameters' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Change all or a subset of the node memory tunables. The function
fails if not all of the tunables are supported.

Note that it's not recommended to use this function while the
outside tuning program is running (such as ksmtuned under Linux),
as they could change the tunables in parallel, which could cause
conflicts.

This function may require privileged access to the hypervisor.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='params' type='virTypedParameterPtr' info='pointer to scheduler parameter objects'/>
      <arg name='nparams' type='int' info='number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virNodeSuspendForDuration' file='libvirt-host' module='libvirt-host'>
      <info><![CDATA[Attempt to suspend the node (host machine) for the given duration of
time in the specified state (Suspend-to-RAM, Suspend-to-Disk or
Hybrid-Suspend). Schedule the node's Real-Time-Clock interrupt to
resume the node after the duration is complete.]]></info>
      <return type='int' info='0 on success (i.e., the node will be suspended after a short delay), -1 on failure (the operation is not supported, or an attempted suspend is already underway).'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='target' type='unsigned int' info='the state to which the host must be suspended to, such as: VIR_NODE_SUSPEND_TARGET_MEM (Suspend-to-RAM) VIR_NODE_SUSPEND_TARGET_DISK (Suspend-to-Disk) VIR_NODE_SUSPEND_TARGET_HYBRID (Hybrid-Suspend, which is a combination of the former modes).'/>
      <arg name='duration' type='unsigned long long' info='the time duration in seconds for which the host has to be suspended'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virResetError' file='virterror' module='virerror'>
      <info><![CDATA[Reset the error being pointed to]]></info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the virError to clean up'/>
    </function>
    <function name='virResetLastError' file='virterror' module='virerror'>
      <info><![CDATA[Reset the last error caught at the library level.

The error object is kept in thread local storage, so separate
threads can safely access this concurrently, only resetting
their own error object.]]></info>
      <return type='void'/>
    </function>
    <function name='virSaveLastError' file='virterror' module='virerror'>
      <info><![CDATA[Save the last error into a new error object.  On success, errno is
unchanged; on failure, errno is ENOMEM.]]></info>
      <return type='virErrorPtr' info='a pointer to the copied error or NULL if allocation failed. It is the caller&apos;s responsibility to free the error with virFreeError().'/>
    </function>
    <function name='virSecretDefineXML' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[If XML specifies a UUID, locates the specified secret and replaces all
attributes of the secret specified by UUID by attributes specified in xml
(any attributes not specified in xml are discarded).

Otherwise, creates a new secret with an automatically chosen UUID, and
initializes its attributes from xml.

virSecretFree should be used to free the resources after the
secret object is no longer needed.]]></info>
      <return type='virSecretPtr' info='a secret on success, NULL on failure.'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='xml' type='const char *' info='XML describing the secret.'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virSecretFree' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Release the secret handle. The underlying secret continues to exist.]]></info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='secret' type='virSecretPtr' info='pointer to a secret'/>
    </function>
    <function name='virSecretGetConnect' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Provides the connection pointer associated with a secret.  The reference
counter on the connection is not increased by this call.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
    </function>
    <function name='virSecretGetUUID' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Fetches the UUID of the secret.]]></info>
      <return type='int' info='0 on success with the uuid buffer being filled, or -1 upon failure.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
      <arg name='uuid' type='unsigned char *' info='buffer of VIR_UUID_BUFLEN bytes in size'/>
    </function>
    <function name='virSecretGetUUIDString' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Get the UUID for a secret as string. For more information about
UUID see RFC4122.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='secret' type='virSecretPtr' info='a secret object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virSecretGetUsageID' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Get the unique identifier of the object with which this
secret is to be used. The format of the identifier is
dependent on the usage type of the secret. For a secret
with a usage type of VIR_SECRET_USAGE_TYPE_VOLUME the
identifier will be a fully qualified path name. The
identifiers are intended to be unique within the set of
all secrets sharing the same usage type. ie, there shall
only ever be one secret for each volume path.]]></info>
      <return type='const char *' info='a string identifying the object using the secret, or NULL upon error'/>
      <arg name='secret' type='virSecretPtr' info='a secret object'/>
    </function>
    <function name='virSecretGetUsageType' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Get the type of object which uses this secret. The returned
value is one of the constants defined in the virSecretUsageType
enumeration. More values may be added to this enumeration in
the future, so callers should expect to see usage types they
do not explicitly know about.]]></info>
      <return type='int' info='a positive integer identifying the type of object, or -1 upon error.'/>
      <arg name='secret' type='virSecretPtr' info='a secret object'/>
    </function>
    <function name='virSecretGetValue' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Fetches the value of a secret.]]></info>
      <return type='unsigned char *' info='the secret value on success, NULL on failure.  The caller must free() the secret value.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret connection'/>
      <arg name='value_size' type='size_t *' info='Place for storing size of the secret value'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virSecretGetXMLDesc' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Fetches an XML document describing attributes of the secret.]]></info>
      <return type='char *' info='the XML document on success, NULL on failure.  The caller must free() the XML.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virSecretLookupByUUID' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Try to lookup a secret on the given hypervisor based on its UUID.
Uses the 16 bytes of raw data to describe the UUID

virSecretFree should be used to free the resources after the
secret object is no longer needed.]]></info>
      <return type='virSecretPtr' info='a new secret object or NULL in case of failure.  If the secret cannot be found, then VIR_ERR_NO_SECRET error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the secret'/>
    </function>
    <function name='virSecretLookupByUUIDString' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Try to lookup a secret on the given hypervisor based on its UUID.
Uses the printable string value to describe the UUID

virSecretFree should be used to free the resources after the
secret object is no longer needed.]]></info>
      <return type='virSecretPtr' info='a new secret object or NULL in case of failure.  If the secret cannot be found, then VIR_ERR_NO_SECRET error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the secret'/>
    </function>
    <function name='virSecretLookupByUsage' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Try to lookup a secret on the given hypervisor based on its usage
The usageID is unique within the set of secrets sharing the
same usageType value.

virSecretFree should be used to free the resources after the
secret object is no longer needed.]]></info>
      <return type='virSecretPtr' info='a new secret object or NULL in case of failure.  If the secret cannot be found, then VIR_ERR_NO_SECRET error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='usageType' type='int' info='the type of secret usage'/>
      <arg name='usageID' type='const char *' info='identifier of the object using the secret'/>
    </function>
    <function name='virSecretRef' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Increment the reference count on the secret. For each additional call to
this method, there shall be a corresponding call to virSecretFree to release
the reference count, once the caller no longer needs the reference to this
object.

This method is typically useful for applications where multiple threads are
using a connection, and it is required that the connection remain open until
all threads have finished using it. ie, each new thread using a secret would
increment the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='secret' type='virSecretPtr' info='the secret to hold a reference on'/>
    </function>
    <function name='virSecretSetValue' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Sets the value of a secret.]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
      <arg name='value' type='const unsigned char *' info='Value of the secret'/>
      <arg name='value_size' type='size_t' info='Size of the value'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virSecretUndefine' file='libvirt-secret' module='libvirt-secret'>
      <info><![CDATA[Deletes the specified secret.  This does not free the associated
virSecretPtr object.]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
    </function>
    <function name='virSetErrorFunc' file='virterror' module='virerror'>
      <info><![CDATA[Set a library global error handling function, if @handler is NULL,
it will reset to default printing on stderr. The error raised there
are those for which no handler at the connection level could caught.]]></info>
      <return type='void'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
    <function name='virStoragePoolBuild' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Currently only filesystem pool accepts flags VIR_STORAGE_POOL_BUILD_OVERWRITE
and VIR_STORAGE_POOL_BUILD_NO_OVERWRITE.

Build the underlying storage pool]]></info>
      <return type='int' info='0 on success, or -1 upon failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStoragePoolBuildFlags'/>
    </function>
    <function name='virStoragePoolCreate' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Starts an inactive storage pool]]></info>
      <return type='int' info='0 on success, or -1 if it could not be started'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStoragePoolCreateFlags'/>
    </function>
    <function name='virStoragePoolCreateXML' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Create a new storage based on its XML description. The
pool is not persistent, so its definition will disappear
when it is destroyed, or if the host is restarted

virStoragePoolFree should be used to free the resources after the
storage pool object is no longer needed.]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if creation failed'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='XML description for new pool'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStoragePoolCreateFlags'/>
    </function>
    <function name='virStoragePoolDefineXML' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Define an inactive persistent storage pool or modify an existing persistent
one from the XML description.

virStoragePoolFree should be used to free the resources after the
storage pool object is no longer needed.]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if creation failed'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='xml' type='const char *' info='XML description for new pool'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virStoragePoolDelete' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Delete the underlying pool resources. This is
a non-recoverable operation. The virStoragePoolPtr object
itself is not free'd.]]></info>
      <return type='int' info='0 on success, or -1 if it could not be obliterate'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStoragePoolDeleteFlags'/>
    </function>
    <function name='virStoragePoolDestroy' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Destroy an active storage pool. This will deactivate the
pool on the host, but keep any persistent config associated
with it. If it has a persistent config it can later be
restarted with virStoragePoolCreate(). This does not free
the associated virStoragePoolPtr object.]]></info>
      <return type='int' info='0 on success, or -1 if it could not be destroyed'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolFree' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Free a storage pool object, releasing all memory associated with
it. Does not change the state of the pool on the host.]]></info>
      <return type='int' info='0 on success, or -1 if it could not be free&apos;d.'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolGetAutostart' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetches the value of the autostart flag, which determines
whether the pool is automatically started at boot time]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='autostart' type='int *' info='location in which to store autostart flag'/>
    </function>
    <function name='virStoragePoolGetConnect' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Provides the connection pointer associated with a storage pool.  The
reference counter on the connection is not increased by this
call.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to a pool'/>
    </function>
    <function name='virStoragePoolGetInfo' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Get volatile information about the storage pool
such as free space / usage summary]]></info>
      <return type='int' info='0 on success, or -1 on failure.'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='info' type='virStoragePoolInfoPtr' info='pointer at which to store info'/>
    </function>
    <function name='virStoragePoolGetName' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch the locally unique name of the storage pool]]></info>
      <return type='const char *' info='the name of the pool, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolGetUUID' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch the globally unique ID of the storage pool]]></info>
      <return type='int' info='0 on success, or -1 on error;'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='uuid' type='unsigned char *' info='buffer of VIR_UUID_BUFLEN bytes in size'/>
    </function>
    <function name='virStoragePoolGetUUIDString' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch the globally unique ID of the storage pool as a string]]></info>
      <return type='int' info='0 on success, or -1 on error;'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='buf' type='char *' info='buffer of VIR_UUID_STRING_BUFLEN bytes in size'/>
    </function>
    <function name='virStoragePoolGetXMLDesc' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch an XML document describing all aspects of the
storage pool. This is suitable for later feeding back
into the virStoragePoolCreateXML method.]]></info>
      <return type='char *' info='a XML document (caller frees), or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStorageXMLFlags'/>
    </function>
    <function name='virStoragePoolIsActive' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Determine if the storage pool is currently running]]></info>
      <return type='int' info='1 if running, 0 if inactive, -1 on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to the storage pool object'/>
    </function>
    <function name='virStoragePoolIsPersistent' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Determine if the storage pool has a persistent configuration
which means it will still exist after shutting down]]></info>
      <return type='int' info='1 if persistent, 0 if transient, -1 on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to the storage pool object'/>
    </function>
    <function name='virStoragePoolListAllVolumes' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Collect the list of storage volumes, and allocate an array to store those
objects.]]></info>
      <return type='int' info='the number of storage volumes found or -1 and sets @vols to NULL in case of error.  On success, the array stored into @vols is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virStorageVolFree() on each array element, then calling free() on @vols.'/>
      <arg name='pool' type='virStoragePoolPtr' info='Pointer to storage pool'/>
      <arg name='vols' type='virStorageVolPtr **' info='Pointer to a variable to store the array containing storage volume objects or NULL if the list is not required (just returns number of volumes).'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virStoragePoolListVolumes' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch list of storage volume names, limiting to
at most maxnames.

To list the volume objects directly, see virStoragePoolListAllVolumes().]]></info>
      <return type='int' info='the number of names fetched, or -1 on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='names' type='char ** const' info='array in which to storage volume names'/>
      <arg name='maxnames' type='int' info='size of names array'/>
    </function>
    <function name='virStoragePoolLookupByName' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch a storage pool based on its unique name

virStoragePoolFree should be used to free the resources after the
storage pool object is no longer needed.]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='name' type='const char *' info='name of pool to fetch'/>
    </function>
    <function name='virStoragePoolLookupByTargetPath' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch a storage pool which maps to a particular target directory.
If more than one pool maps to the path, it is undefined which
will be returned first.

virStoragePoolFree should be used to free the resources after the
storage pool object is no longer needed.]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='path' type='const char *' info='path at which the pool is exposed'/>
    </function>
    <function name='virStoragePoolLookupByUUID' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch a storage pool based on its globally unique id

virStoragePoolFree should be used to free the resources after the
storage pool object is no longer needed.]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='globally unique id of pool to fetch'/>
    </function>
    <function name='virStoragePoolLookupByUUIDString' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch a storage pool based on its globally unique id

virStoragePoolFree should be used to free the resources after the
storage pool object is no longer needed.]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='globally unique id of pool to fetch'/>
    </function>
    <function name='virStoragePoolLookupByVolume' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch a storage pool which contains a particular volume

virStoragePoolFree should be used to free the resources after the
storage pool object is no longer needed.]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStoragePoolNumOfVolumes' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch the number of storage volumes within a pool]]></info>
      <return type='int' info='the number of storage pools, or -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolRef' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Increment the reference count on the pool. For each
additional call to this method, there shall be a corresponding
call to virStoragePoolFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a pool would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='pool' type='virStoragePoolPtr' info='the pool to hold a reference on'/>
    </function>
    <function name='virStoragePoolRefresh' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Request that the pool refresh its list of volumes. This may
involve communicating with a remote server, and/or initializing
new devices at the OS layer]]></info>
      <return type='int' info='0 if the volume list was refreshed, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virStoragePoolSetAutostart' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Configure the storage pool to be automatically started
when the host machine boots.]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='autostart' type='int' info='whether the storage pool should be automatically started 0 or 1'/>
    </function>
    <function name='virStoragePoolUndefine' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Undefine an inactive storage pool]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStorageVolCreateXML' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Create a storage volume within a pool based
on an XML description. Not all pools support
creation of volumes.

Since 1.0.1 VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA
in flags can be used to get higher performance with
qcow2 image files which don't support full preallocation,
by creating a sparse image file with metadata.

virStorageVolFree should be used to free the resources after the
storage volume object is no longer needed.]]></info>
      <return type='virStorageVolPtr' info='the storage volume, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='xmlDesc' type='const char *' info='description of volume to create'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStorageVolCreateFlags'/>
    </function>
    <function name='virStorageVolCreateXMLFrom' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Create a storage volume in the parent pool, using the
'clonevol' volume as input. Information for the new
volume (name, perms)  are passed via a typical volume
XML description.

Since 1.0.1 VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA
in flags can be used to get higher performance with
qcow2 image files which don't support full preallocation,
by creating a sparse image file with metadata.

virStorageVolFree should be used to free the resources after the
storage volume object is no longer needed.]]></info>
      <return type='virStorageVolPtr' info='the storage volume, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to parent pool for the new volume'/>
      <arg name='xmlDesc' type='const char *' info='description of volume to create'/>
      <arg name='clonevol' type='virStorageVolPtr' info='storage volume to use as input'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStorageVolCreateFlags'/>
    </function>
    <function name='virStorageVolDelete' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Delete the storage volume from the pool]]></info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStorageVolDeleteFlags'/>
    </function>
    <function name='virStorageVolDownload' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Download the content of the volume as a stream. If @length
is zero, then the remaining contents of the volume after
@offset will be downloaded.

If VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM is set in @flags
effective transmission of holes is enabled. This assumes using
the @stream with combination of virStreamSparseRecvAll() or
virStreamRecvFlags(stream, ..., flags =
VIR_STREAM_RECV_STOP_AT_HOLE) for honouring holes sent by
server.

This call sets up an asynchronous stream; subsequent use of
stream APIs is necessary to transfer the actual data,
determine how much data is successfully transferred, and
detect any errors. The results will be unpredictable if
another active stream is writing to the storage volume.]]></info>
      <return type='int' info='0, or -1 upon error.'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to volume to download from'/>
      <arg name='stream' type='virStreamPtr' info='stream to use as output'/>
      <arg name='offset' type='unsigned long long' info='position in @vol to start reading from'/>
      <arg name='length' type='unsigned long long' info='limit on amount of data to download'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStorageVolDownloadFlags'/>
    </function>
    <function name='virStorageVolFree' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Release the storage volume handle. The underlying
storage volume continues to exist.]]></info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetConnect' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Provides the connection pointer associated with a storage volume.  The
reference counter on the connection is not increased by this
call.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to a pool'/>
    </function>
    <function name='virStorageVolGetInfo' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetches volatile information about the storage
volume such as its current allocation]]></info>
      <return type='int' info='0 on success, or -1 on failure'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='info' type='virStorageVolInfoPtr' info='pointer at which to store info'/>
    </function>
    <function name='virStorageVolGetInfoFlags' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetches volatile information about the storage
volume such as its current allocation.

If the @flags argument is VIR_STORAGE_VOL_GET_PHYSICAL, then the physical
bytes used for the volume will be returned in the @info allocation field.
This is useful for sparse files and certain volume file types where the
physical on disk usage can be different than the calculated allocation value
as is the case with qcow2 files.]]></info>
      <return type='int' info='0 on success, or -1 on failure'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='info' type='virStorageVolInfoPtr' info='pointer at which to store info'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStorageVolInfoFlags'/>
    </function>
    <function name='virStorageVolGetKey' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch the storage volume key. This is globally
unique, so the same volume will have the same
key no matter what host it is accessed from]]></info>
      <return type='const char *' info='the volume key, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetName' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch the storage volume name. This is unique
within the scope of a pool]]></info>
      <return type='const char *' info='the volume name, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetPath' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch the storage volume path. Depending on the pool
configuration this is either persistent across hosts,
or dynamically assigned at pool startup. Consult
pool documentation for information on getting the
persistent naming]]></info>
      <return type='char *' info='the storage volume path, or NULL on error. The caller must free() the returned path after use.'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetXMLDesc' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch an XML document describing all aspects of
the storage volume]]></info>
      <return type='char *' info='the XML document, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virStorageVolLookupByKey' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch a pointer to a storage volume based on its
globally unique key

virStorageVolFree should be used to free the resources after the
storage volume object is no longer needed.]]></info>
      <return type='virStorageVolPtr' info='a storage volume, or NULL if not found / error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='key' type='const char *' info='globally unique key'/>
    </function>
    <function name='virStorageVolLookupByName' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch a pointer to a storage volume based on its name
within a pool

virStorageVolFree should be used to free the resources after the
storage volume object is no longer needed.]]></info>
      <return type='virStorageVolPtr' info='a storage volume, or NULL if not found / error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='name' type='const char *' info='name of storage volume'/>
    </function>
    <function name='virStorageVolLookupByPath' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Fetch a pointer to a storage volume based on its
locally (host) unique path

virStorageVolFree should be used to free the resources after the
storage volume object is no longer needed.]]></info>
      <return type='virStorageVolPtr' info='a storage volume, or NULL if not found / error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='path' type='const char *' info='locally unique path'/>
    </function>
    <function name='virStorageVolRef' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Increment the reference count on the vol. For each
additional call to this method, there shall be a corresponding
call to virStorageVolFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a vol would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='vol' type='virStorageVolPtr' info='the vol to hold a reference on'/>
    </function>
    <function name='virStorageVolResize' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Changes the capacity of the storage volume @vol to @capacity. The
operation will fail if the new capacity requires allocation that would
exceed the remaining free space in the parent pool.  The contents of
the new capacity will appear as all zero bytes. The capacity value will
be rounded to the granularity supported by the hypervisor.

Normally, the operation will attempt to affect capacity with a minimum
impact on allocation (that is, the default operation favors a sparse
resize).  If @flags contains VIR_STORAGE_VOL_RESIZE_ALLOCATE, then the
operation will ensure that allocation is sufficient for the new
capacity; this may make the operation take noticeably longer.

Normally, the operation treats @capacity as the new size in bytes;
but if @flags contains VIR_STORAGE_VOL_RESIZE_DELTA, then @capacity
represents the size difference to add to the current size.  It is
up to the storage pool implementation whether unaligned requests are
rounded up to the next valid boundary, or rejected.

Normally, this operation should only be used to enlarge capacity;
but if @flags contains VIR_STORAGE_VOL_RESIZE_SHRINK, it is possible to
attempt a reduction in capacity even though it might cause data loss.
If VIR_STORAGE_VOL_RESIZE_DELTA is also present, then @capacity is
subtracted from the current size; without it, @capacity represents
the absolute new size regardless of whether it is larger or smaller
than the current size.]]></info>
      <return type='int' info='0 on success, or -1 on error.'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='capacity' type='unsigned long long' info='new capacity, in bytes'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStorageVolResizeFlags'/>
    </function>
    <function name='virStorageVolUpload' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Upload new content to the volume from a stream. This call
will fail if @offset + @length exceeds the size of the
volume. Otherwise, if @length is non-zero, an error
will be raised if an attempt is made to upload greater
than @length bytes of data.

If VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM is set in @flags
effective transmission of holes is enabled. This assumes using
the @stream with combination of virStreamSparseSendAll() or
virStreamSendHole() to preserve source file sparseness.

This call sets up an asynchronous stream; subsequent use of
stream APIs is necessary to transfer the actual data,
determine how much data is successfully transferred, and
detect any errors. The results will be unpredictable if
another active stream is writing to the storage volume.

When the data stream is closed whether the upload is successful
or not an attempt will be made to refresh the target storage pool
if an asynchronous build is not running in order to reflect pool
and volume changes as a result of the upload. Depending on
the target volume storage backend and the source stream type
for a successful upload, the target volume may take on the
characteristics from the source stream such as format type,
capacity, and allocation.]]></info>
      <return type='int' info='0, or -1 upon error.'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to volume to upload'/>
      <arg name='stream' type='virStreamPtr' info='stream to use as input'/>
      <arg name='offset' type='unsigned long long' info='position to start writing to'/>
      <arg name='length' type='unsigned long long' info='limit on amount of data to upload'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStorageVolUploadFlags'/>
    </function>
    <function name='virStorageVolWipe' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Ensure data previously on a volume is not accessible to future reads.

The data to be wiped may include the format and possibly size information,
so non-raw images might become raw with a different size. It is storage
backend dependent whether the format and size information is regenerated
once the initial volume wipe is completed.

Depending on the actual volume representation, this call may not
overwrite the physical location of the volume. For instance, files
stored journaled, log structured, copy-on-write, versioned, and
network file systems are known to be problematic.]]></info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virStorageVolWipePattern' file='libvirt-storage' module='libvirt-storage'>
      <info><![CDATA[Similar to virStorageVolWipe, but one can choose between
different wiping algorithms. Also note, that depending on the
actual volume representation, this call may not really
overwrite the physical location of the volume. For instance,
files stored journaled, log structured, copy-on-write,
versioned, and network file systems are known to be
problematic.]]></info>
      <return type='int' info='0 on success, or -1 on error.'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='algorithm' type='unsigned int' info='one of virStorageVolWipeAlgorithm'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStreamAbort' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Request that the in progress data transfer be cancelled
abnormally before the end of the stream has been reached.
For output streams this can be used to inform the driver
that the stream is being terminated early. For input
streams this can be used to inform the driver that it
should stop sending data.

If the stream is non-blocking, any callback must be removed
beforehand.]]></info>
      <return type='int' info='0 on success, -1 upon error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
    </function>
    <function name='virStreamEventAddCallback' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Register a callback to be notified when a stream
becomes writable, or readable. This is most commonly
used in conjunction with non-blocking data streams
to integrate into an event loop]]></info>
      <return type='int' info='0 on success, -1 upon error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='events' type='int' info='set of events to monitor'/>
      <arg name='cb' type='virStreamEventCallback' info='callback to invoke when an event occurs'/>
      <arg name='opaque' type='void *' info='application defined data'/>
      <arg name='ff' type='virFreeCallback' info='callback to free @opaque data'/>
    </function>
    <functype name='virStreamEventCallback' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Callback for receiving stream events. The callback will
be invoked once for each event which is pending.]]></info>
      <return type='void'/>
      <arg name='stream' type='virStreamPtr' info='stream on which the event occurred'/>
      <arg name='events' type='int' info='bitset of events from virEventHandleType constants'/>
      <arg name='opaque' type='void *' info='user data registered with handle'/>
    </functype>
    <function name='virStreamEventRemoveCallback' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Remove an event callback from the stream]]></info>
      <return type='int' info='0 on success, -1 on error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
    </function>
    <function name='virStreamEventUpdateCallback' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Changes the set of events to monitor for a stream. This allows
for event notification to be changed without having to
unregister & register the callback completely. This method
is guaranteed to succeed if a callback is already registered]]></info>
      <return type='int' info='0 on success, -1 if no callback is registered'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='events' type='int' info='set of events to monitor'/>
    </function>
    <function name='virStreamFinish' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Indicate that there is no further data to be transmitted
on the stream. For output streams this should be called once
all data has been written. For input streams this should be
called once virStreamRecv returns end-of-file.

This method is a synchronization point for all asynchronous
errors, so if this returns a success code the application can
be sure that all data has been successfully processed.

If the stream is non-blocking, any callback must be removed
beforehand.]]></info>
      <return type='int' info='0 on success, -1 upon error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
    </function>
    <function name='virStreamFree' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Decrement the reference count on a stream, releasing
the stream object if the reference count has hit zero.

There must not be an active data transfer in progress
when releasing the stream. If a stream needs to be
disposed of prior to end of stream being reached, then
the virStreamAbort function should be called first.]]></info>
      <return type='int' info='0 upon success, or -1 on error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
    </function>
    <function name='virStreamNew' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Creates a new stream object which can be used to perform
streamed I/O with other public API function.

When no longer needed, a stream object must be released
with virStreamFree. If a data stream has been used,
then the application must call virStreamFinish or
virStreamAbort before free'ing to, in order to notify
the driver of termination.

If a non-blocking data stream is required passed
VIR_STREAM_NONBLOCK for flags, otherwise pass 0.]]></info>
      <return type='virStreamPtr' info='the new stream, or NULL upon error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStreamFlags'/>
    </function>
    <function name='virStreamRecv' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Reads a series of bytes from the stream. This method may
block the calling application for an arbitrary amount
of time.

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file download
API looks like

    virStreamPtr st = virStreamNew(conn, 0);
    int fd = open("demo.iso", O_WRONLY, 0600);

    virConnectDownloadFile(conn, "demo.iso", st);

    while (1) {
        char buf[1024];
        int got = virStreamRecv(st, buf, 1024);
        if (got < 0) {
           virStreamAbort(st);
           break;
        }
        if (got == 0) {
           virStreamFinish(st);
           break;
        }
        int offset = 0;
        while (offset < got) {
           int sent = write(fd, buf + offset, got - offset);
           if (sent < 0) {
              virStreamAbort(st);
              goto done;
           }
           offset += sent;
        }
    }
    if (virStreamFinish(st) < 0)
       ... report an error ....
  done:
    virStreamFree(st);
    close(fd);]]></info>
      <return type='int' info='the number of bytes read, which may be less than requested.  Returns 0 when the end of the stream is reached, at which time the caller should invoke virStreamFinish() to get confirmation of stream completion.  Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree.  Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking.'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='data' type='char *' info='buffer to read into from stream'/>
      <arg name='nbytes' type='size_t' info='size of @data buffer'/>
    </function>
    <function name='virStreamRecvAll' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Receive the entire data stream, sending the data to the
requested data sink. This is simply a convenient alternative
to virStreamRecv, for apps that do blocking-I/O.

An example using this with a hypothetical file download
API looks like

  int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
      int *fd = opaque;

      return write(*fd, buf, nbytes);
  }

  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_WRONLY);

  virConnectUploadFile(conn, st);
  if (virStreamRecvAll(st, mysink, &fd) < 0) {
     ...report an error ...
     goto done;
  }
  if (virStreamFinish(st) < 0)
     ...report an error...
  virStreamFree(st);
  close(fd);]]></info>
      <return type='int' info='0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree  Returns -1 upon any error, with virStreamAbort() already having been called,  so the caller need only call virStreamFree()'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='handler' type='virStreamSinkFunc' info='sink callback for writing data to application'/>
      <arg name='opaque' type='void *' info='application defined data'/>
    </function>
    <function name='virStreamRecvFlags' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Reads a series of bytes from the stream. This method may
block the calling application for an arbitrary amount
of time.

This is just like virStreamRecv except this one has extra
@flags. Calling this function with no @flags set (equal to
zero) is equivalent to calling virStreamRecv(stream, data, nbytes).

If flag VIR_STREAM_RECV_STOP_AT_HOLE is set, this function
will stop reading from stream if it has reached a hole. In
that case, -3 is returned and virStreamRecvHole() should be
called to get the hole size. An example using this flag might
look like this:

  while (1) {
    char buf[4096];

    int ret = virStreamRecvFlags(st, buf, len, VIR_STREAM_STOP_AT_HOLE);
    if (ret < 0) {
      if (ret == -3) {
        long long len;
        ret = virStreamRecvHole(st, &len, 0);
        if (ret < 0) {
          ...error..
        } else {
          ...seek len bytes in target...
        }
      } else {
        return -1;
      }
    } else {
        ...write buf to target...
    }
  }]]></info>
      <return type='int' info='0 when the end of the stream is reached, at which time the caller should invoke virStreamFinish() to get confirmation of stream completion.  Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree.  Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking.  Returns -3 if there is a hole in stream and caller requested to stop at a hole.'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='data' type='char *' info='buffer to read into from stream'/>
      <arg name='nbytes' type='size_t' info='size of @data buffer'/>
      <arg name='flags' type='unsigned int' info='bitwise-OR of virStreamRecvFlagsValues'/>
    </function>
    <function name='virStreamRecvHole' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[This API is used to determine the @length in bytes of the
empty space to be created in a @stream's target file when
uploading or downloading sparsely populated files. This is the
counterpart to virStreamSendHole().]]></info>
      <return type='int' info='0 on success, -1 on error or when there&apos;s currently no hole in the stream'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='length' type='long long *' info='number of bytes to skip'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <function name='virStreamRef' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Increment the reference count on the stream. For each
additional call to this method, there shall be a corresponding
call to virStreamFree to release the reference count, once
the caller no longer needs the reference to this object.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream'/>
    </function>
    <function name='virStreamSend' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Write a series of bytes to the stream. This method may
block the calling application for an arbitrary amount
of time. Once an application has finished sending data
it should call virStreamFinish to wait for successful
confirmation from the driver, or detect any error.

This method may not be used if a stream source has been
registered.

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file upload
API looks like

    virStreamPtr st = virStreamNew(conn, 0);
    int fd = open("demo.iso", O_RDONLY);

    virConnectUploadFile(conn, "demo.iso", st);

    while (1) {
         char buf[1024];
         int got = read(fd, buf, 1024);
         if (got < 0) {
            virStreamAbort(st);
            break;
         }
         if (got == 0) {
            virStreamFinish(st);
            break;
         }
         int offset = 0;
         while (offset < got) {
            int sent = virStreamSend(st, buf+offset, got-offset);
            if (sent < 0) {
               virStreamAbort(st);
               goto done;
            }
            offset += sent;
         }
     }
     if (virStreamFinish(st) < 0)
        ... report an error ....
   done:
     virStreamFree(st);
     close(fd);]]></info>
      <return type='int' info='the number of bytes written, which may be less than requested.  Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree.  Returns -2 if the outgoing transmit buffers are full &amp; the stream is marked as non-blocking.'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='data' type='const char *' info='buffer to write to stream'/>
      <arg name='nbytes' type='size_t' info='size of @data buffer'/>
    </function>
    <function name='virStreamSendAll' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Send the entire data stream, reading the data from the
requested data source. This is simply a convenient alternative
to virStreamSend, for apps that do blocking-I/O.

An example using this with a hypothetical file upload
API looks like

  int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
      int *fd = opaque;

      return read(*fd, buf, nbytes);
  }

  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_RDONLY);

  virConnectUploadFile(conn, st);
  if (virStreamSendAll(st, mysource, &fd) < 0) {
     ...report an error ...
     goto done;
  }
  if (virStreamFinish(st) < 0)
     ...report an error...
  virStreamFree(st);
  close(fd);]]></info>
      <return type='int' info='0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree  Returns -1 upon any error, with virStreamAbort() already having been called,  so the caller need only call virStreamFree().'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='handler' type='virStreamSourceFunc' info='source callback for reading data from application'/>
      <arg name='opaque' type='void *' info='application defined data'/>
    </function>
    <function name='virStreamSendHole' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Rather than transmitting empty file space, this API directs
the @stream target to create @length bytes of empty space.
This API would be used when uploading or downloading sparsely
populated files to avoid the needless copy of empty file
space.

An example using this with a hypothetical file upload API
looks like:

  virStream st;

  while (1) {
    char buf[4096];
    size_t len;
    if (..in hole...) {
      ..get hole size...
      virStreamSendHole(st, len, 0);
    } else {
      ...read len bytes...
      virStreamSend(st, buf, len);
    }
  }]]></info>
      <return type='int' info='0 on success, -1 error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='length' type='long long' info='number of bytes to skip'/>
      <arg name='flags' type='unsigned int' info='extra flags; not used yet, so callers should always pass 0'/>
    </function>
    <functype name='virStreamSinkFunc' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[The virStreamSinkFunc callback is used together with the
virStreamRecvAll or virStreamSparseRecvAll functions for
libvirt to provide the data that has been received.

The callback will be invoked multiple times,
providing data in small chunks. The application
should consume up 'nbytes' from the 'data' array
of data and then return the number actual number
of bytes consumed. The callback will continue to be
invoked until it indicates the end of the stream
has been reached. A return value of -1 at any time
will abort the receive operation

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.]]></info>
      <return type='int' info='the number of bytes consumed or -1 upon error'/>
      <arg name='st' type='virStreamPtr' info='the stream object'/>
      <arg name='data' type='const char *' info='preallocated array to be filled with data'/>
      <arg name='nbytes' type='size_t' info='size of the data array'/>
      <arg name='opaque' type='void *' info='optional application provided data'/>
    </functype>
    <functype name='virStreamSinkHoleFunc' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[This callback is used together with the virStreamSparseRecvAll
function for libvirt to provide the size of a hole that
occurred in the stream.

The callback may be invoked multiple times as holes are found
during processing a stream. The application should create the
hole in the stream target and then return. A return value of
-1 at any time will abort the receive operation.

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.]]></info>
      <return type='int' info='0 on success, -1 upon error'/>
      <arg name='st' type='virStreamPtr' info='the stream object'/>
      <arg name='length' type='long long' info='stream hole size'/>
      <arg name='opaque' type='void *' info='optional application provided data'/>
    </functype>
    <functype name='virStreamSourceFunc' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[The virStreamSourceFunc callback is used together with
the virStreamSendAll and virStreamSparseSendAll functions
for libvirt to obtain the data that is to be sent.

The callback will be invoked multiple times,
fetching data in small chunks. The application
should fill the 'data' array with up to 'nbytes'
of data and then return the number actual number
of bytes. The callback will continue to be
invoked until it indicates the end of the source
has been reached by returning 0. A return value
of -1 at any time will abort the send operation.

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.]]></info>
      <return type='int' info='the number of bytes filled, 0 upon end of file, or -1 upon error'/>
      <arg name='st' type='virStreamPtr' info='the stream object'/>
      <arg name='data' type='char *' info='preallocated array to be filled with data'/>
      <arg name='nbytes' type='size_t' info='size of the data array'/>
      <arg name='opaque' type='void *' info='optional application provided data'/>
    </functype>
    <functype name='virStreamSourceHoleFunc' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[The virStreamSourceHoleFunc callback is used together with the
virStreamSparseSendAll function for libvirt to obtain the
length of section stream is currently in.

Moreover, upon successful return, @length should be updated
with how many bytes are left until the current section ends
(either data section or hole section). Also the stream is
currently in data section, @inData should be set to a non-zero
value and vice versa.

NB: there's an implicit hole at the end of each file. If
that's the case, @inData and @length should be both set to 0.

This function should not adjust the current position within
the file.

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.]]></info>
      <return type='int' info='0 on success, -1 upon error'/>
      <arg name='st' type='virStreamPtr' info='the stream object'/>
      <arg name='inData' type='int *' info='are we in data section'/>
      <arg name='length' type='long long *' info='how long is the section we are currently in'/>
      <arg name='opaque' type='void *' info='optional application provided data'/>
    </functype>
    <functype name='virStreamSourceSkipFunc' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[This callback is used together with the virStreamSparseSendAll
to skip holes in the underlying file as reported by
virStreamSourceHoleFunc.

The callback may be invoked multiple times as holes are found
during processing a stream. The application should skip
processing the hole in the stream source and then return.
A return value of -1 at any time will abort the send operation.

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.]]></info>
      <return type='int' info='0 on success, -1 upon error.'/>
      <arg name='st' type='virStreamPtr' info='the stream object'/>
      <arg name='length' type='long long' info='stream hole size'/>
      <arg name='opaque' type='void *' info='optional application provided data'/>
    </functype>
    <function name='virStreamSparseRecvAll' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Receive the entire data stream, sending the data to the
requested data sink @handler and calling the skip @holeHandler
to generate holes for sparse stream targets. This is simply a
convenient alternative to virStreamRecvFlags, for apps that do
blocking-I/O.

An example using this with a hypothetical file download
API looks like:

  int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
      int *fd = opaque;

      return write(*fd, buf, nbytes);
  }

  int myskip(virStreamPtr st, long long offset, void *opaque) {
      int *fd = opaque;

      return lseek(*fd, offset, SEEK_CUR) == (off_t) -1 ? -1 : 0;
  }

  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_WRONLY);

  virConnectDownloadSparseFile(conn, st);
  if (virStreamSparseRecvAll(st, mysink, myskip, &fd) < 0) {
     ...report an error ...
     goto done;
  }
  if (virStreamFinish(st) < 0)
     ...report an error...
  virStreamFree(st);
  close(fd);

Note that @opaque data is shared between both @handler and
@holeHandler callbacks.]]></info>
      <return type='int' info='0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree(st).  Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree().'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='handler' type='virStreamSinkFunc' info='sink callback for writing data to application'/>
      <arg name='holeHandler' type='virStreamSinkHoleFunc' info='stream hole callback for skipping holes'/>
      <arg name='opaque' type='void *' info='application defined data'/>
    </function>
    <function name='virStreamSparseSendAll' file='libvirt-stream' module='libvirt-stream'>
      <info><![CDATA[Send the entire data stream, reading the data from the
requested data source. This is simply a convenient alternative
to virStreamSend, for apps that do blocking-I/O.

An example using this with a hypothetical file upload
API looks like

  int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
      int *fd = opaque;

      return read(*fd, buf, nbytes);
  }

  int myskip(virStreamPtr st, long long offset, void *opaque) {
      int *fd = opaque;

      return lseek(*fd, offset, SEEK_CUR) == (off_t) -1 ? -1 : 0;
  }

  int myindata(virStreamPtr st, int *inData,
               long long *offset, void *opaque) {
      int *fd = opaque;

      if (@fd in hole) {
          *inData = 0;
          *offset = holeSize;
      } else {
          *inData = 1;
          *offset = dataSize;
      }

      return 0;
  }

  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_RDONLY);

  virConnectUploadSparseFile(conn, st);
  if (virStreamSparseSendAll(st,
                             mysource,
                             myindata,
                             myskip,
                             &fd) < 0) {
     ...report an error ...
     goto done;
  }
  if (virStreamFinish(st) < 0)
     ...report an error...
  virStreamFree(st);
  close(fd);

Note that @opaque data are shared between @handler, @holeHandler and @skipHandler.]]></info>
      <return type='int' info='0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree.  Returns -1 upon any error, with virStreamAbort() already having been called,  so the caller need only call virStreamFree().'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='handler' type='virStreamSourceFunc' info='source callback for reading data from application'/>
      <arg name='holeHandler' type='virStreamSourceHoleFunc' info='source callback for determining holes'/>
      <arg name='skipHandler' type='virStreamSourceSkipFunc' info='skip holes as reported by @holeHandler'/>
      <arg name='opaque' type='void *' info='application defined data'/>
    </function>
    <function name='virTypedParamsAddBoolean' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Adds new parameter called @name with boolean type and sets its value to
@value. If @params array points to NULL or to a space that is not large
enough to accommodate the new parameter (@maxparams < @nparams + 1), the
function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer to the array of typed parameters'/>
      <arg name='nparams' type='int *' info='number of parameters in the @params array'/>
      <arg name='maxparams' type='int *' info='maximum number of parameters that can be stored in @params array without allocating more memory'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='int' info='the value to store into the new parameter'/>
    </function>
    <function name='virTypedParamsAddDouble' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Adds new parameter called @name with double type and sets its value to
@value. If @params array points to NULL or to a space that is not large
enough to accommodate the new parameter (@maxparams < @nparams + 1), the
function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer to the array of typed parameters'/>
      <arg name='nparams' type='int *' info='number of parameters in the @params array'/>
      <arg name='maxparams' type='int *' info='maximum number of parameters that can be stored in @params array without allocating more memory'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='double' info='the value to store into the new parameter'/>
    </function>
    <function name='virTypedParamsAddFromString' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Adds new parameter called @name with the requested @type and parses its
value from the @value string. If the requested type is string, the function
creates its own copy of the @value string, which needs to be freed using
virTypedParamsFree or virTypedParamsClear. If @params array points to NULL
or to a space that is not large enough to accommodate the new parameter
(@maxparams < @nparams + 1), the function allocates more space for it and
updates @maxparams. On success, @nparams is incremented by one. The
function fails with VIR_ERR_INVALID_ARG error if the parameter already
exists in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer to the array of typed parameters'/>
      <arg name='nparams' type='int *' info='number of parameters in the @params array'/>
      <arg name='maxparams' type='int *' info='maximum number of parameters that can be stored in @params array without allocating more memory'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='type' type='int' info='type of the parameter'/>
      <arg name='value' type='const char *' info='the value to store into the new parameter encoded as a string'/>
    </function>
    <function name='virTypedParamsAddInt' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Adds new parameter called @name with int type and sets its value to @value.
If @params array points to NULL or to a space that is not large enough to
accommodate the new parameter (@maxparams < @nparams + 1), the function
allocates more space for it and updates @maxparams. On success, @nparams
is incremented by one. The function fails with VIR_ERR_INVALID_ARG error
if the parameter already exists in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer to the array of typed parameters'/>
      <arg name='nparams' type='int *' info='number of parameters in the @params array'/>
      <arg name='maxparams' type='int *' info='maximum number of parameters that can be stored in @params array without allocating more memory'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='int' info='the value to store into the new parameter'/>
    </function>
    <function name='virTypedParamsAddLLong' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Adds new parameter called @name with long long int type and sets its value
to @value. If @params array points to NULL or to a space that is not large
enough to accommodate the new parameter (@maxparams < @nparams + 1), the
function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer to the array of typed parameters'/>
      <arg name='nparams' type='int *' info='number of parameters in the @params array'/>
      <arg name='maxparams' type='int *' info='maximum number of parameters that can be stored in @params array without allocating more memory'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='long long' info='the value to store into the new parameter'/>
    </function>
    <function name='virTypedParamsAddString' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Adds new parameter called @name with char * type and sets its value to
@value. The function creates its own copy of @value string, which needs to
be freed using virTypedParamsFree or virTypedParamsClear. If @params array
points to NULL or to a space that is not large enough to accommodate the
new parameter (@maxparams < @nparams + 1), the function allocates more
space for it and updates @maxparams. On success, @nparams is incremented
by one. The function fails with VIR_ERR_INVALID_ARG error if the parameter
already exists in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer to the array of typed parameters'/>
      <arg name='nparams' type='int *' info='number of parameters in the @params array'/>
      <arg name='maxparams' type='int *' info='maximum number of parameters that can be stored in @params array without allocating more memory'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='const char *' info='the value to store into the new parameter'/>
    </function>
    <function name='virTypedParamsAddStringList' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Packs NULL-terminated list of strings @values into @params under the
key @name.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr *' info='array of typed parameters'/>
      <arg name='nparams' type='int *' info='number of parameters in the @params array'/>
      <arg name='maxparams' type='int *' info='maximum number of parameters that can be stored in @params array without allocating more memory'/>
      <arg name='name' type='const char *' info='name of the parameter to store values to'/>
      <arg name='values' type='const char **' info='the values to store into the new parameters'/>
    </function>
    <function name='virTypedParamsAddUInt' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Adds new parameter called @name with unsigned int type and sets its value
to @value. If @params array points to NULL or to a space that is not large
enough to accommodate the new parameter (@maxparams < @nparams + 1), the
function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer to the array of typed parameters'/>
      <arg name='nparams' type='int *' info='number of parameters in the @params array'/>
      <arg name='maxparams' type='int *' info='maximum number of parameters that can be stored in @params array without allocating more memory'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='unsigned int' info='the value to store into the new parameter'/>
    </function>
    <function name='virTypedParamsAddULLong' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Adds new parameter called @name with unsigned long long type and sets its
value to @value. If @params array points to NULL or to a space that is not
large enough to accommodate the new parameter (@maxparams < @nparams + 1),
the function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.]]></info>
      <return type='int' info='0 on success, -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr *' info='pointer to the array of typed parameters'/>
      <arg name='nparams' type='int *' info='number of parameters in the @params array'/>
      <arg name='maxparams' type='int *' info='maximum number of parameters that can be stored in @params array without allocating more memory'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='unsigned long long' info='the value to store into the new parameter'/>
    </function>
    <function name='virTypedParamsClear' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Frees all memory used by string parameters. The memory occupied by @params
is not freed; use virTypedParamsFree if you want it to be freed too.]]></info>
      <return type='void'/>
      <arg name='params' type='virTypedParameterPtr' info='the array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
    </function>
    <function name='virTypedParamsFree' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Frees all memory used by string parameters and the memory occupied by
@params.]]></info>
      <return type='void'/>
      <arg name='params' type='virTypedParameterPtr' info='the array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
    </function>
    <function name='virTypedParamsGet' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Finds typed parameter called @name.]]></info>
      <return type='virTypedParameterPtr' info='pointer to the parameter or NULL if it does not exist in @params. This function does not raise an error, even when returning NULL.'/>
      <arg name='params' type='virTypedParameterPtr' info='array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
    </function>
    <function name='virTypedParamsGetBoolean' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Finds typed parameter called @name and store its boolean value in @value.
The function fails with VIR_ERR_INVALID_ARG error if the parameter does not
have the expected type. By passing NULL as @value, the function may be used
to check presence and type of the parameter.]]></info>
      <return type='int' info='1 on success, 0 when the parameter does not exist in @params, or -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr' info='array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='int *' info='where to store the parameter&apos;s value'/>
    </function>
    <function name='virTypedParamsGetDouble' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Finds typed parameter called @name and store its double value in @value.
The function fails with VIR_ERR_INVALID_ARG error if the parameter does not
have the expected type. By passing NULL as @value, the function may be used
to check presence and type of the parameter.]]></info>
      <return type='int' info='1 on success, 0 when the parameter does not exist in @params, or -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr' info='array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='double *' info='where to store the parameter&apos;s value'/>
    </function>
    <function name='virTypedParamsGetInt' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Finds typed parameter called @name and store its int value in @value. The
function fails with VIR_ERR_INVALID_ARG error if the parameter does not
have the expected type. By passing NULL as @value, the function may be
used to check presence and type of the parameter.]]></info>
      <return type='int' info='1 on success, 0 when the parameter does not exist in @params, or -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr' info='array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='int *' info='where to store the parameter&apos;s value'/>
    </function>
    <function name='virTypedParamsGetLLong' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Finds typed parameter called @name and store its long long int value in
@value. The function fails with VIR_ERR_INVALID_ARG error if the parameter
does not have the expected type. By passing NULL as @value, the function
may be used to check presence and type of the parameter.]]></info>
      <return type='int' info='1 on success, 0 when the parameter does not exist in @params, or -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr' info='array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='long long *' info='where to store the parameter&apos;s value'/>
    </function>
    <function name='virTypedParamsGetString' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Finds typed parameter called @name and store its char * value in @value.
The function does not create a copy of the string and the caller must not
free the string @value points to. The function fails with
VIR_ERR_INVALID_ARG error if the parameter does not have the expected type.
By passing NULL as @value, the function may be used to check presence and
type of the parameter.]]></info>
      <return type='int' info='1 on success, 0 when the parameter does not exist in @params, or -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr' info='array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='const char **' info='where to store the parameter&apos;s value'/>
    </function>
    <function name='virTypedParamsGetUInt' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Finds typed parameter called @name and store its unsigned int value in
@value. The function fails with VIR_ERR_INVALID_ARG error if the parameter
does not have the expected type. By passing NULL as @value, the function
may be used to check presence and type of the parameter.]]></info>
      <return type='int' info='1 on success, 0 when the parameter does not exist in @params, or -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr' info='array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='unsigned int *' info='where to store the parameter&apos;s value'/>
    </function>
    <function name='virTypedParamsGetULLong' file='libvirt-common' module='virtypedparam-public'>
      <info><![CDATA[Finds typed parameter called @name and store its unsigned long long int
value in @value. The function fails with VIR_ERR_INVALID_ARG error if the
parameter does not have the expected type. By passing NULL as @value, the
function may be used to check presence and type of the parameter.]]></info>
      <return type='int' info='1 on success, 0 when the parameter does not exist in @params, or -1 on error.'/>
      <arg name='params' type='virTypedParameterPtr' info='array of typed parameters'/>
      <arg name='nparams' type='int' info='number of parameters in the @params array'/>
      <arg name='name' type='const char *' info='name of the parameter to find'/>
      <arg name='value' type='unsigned long long *' info='where to store the parameter&apos;s value'/>
    </function>
  </symbols>
</api>
